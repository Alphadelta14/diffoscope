@@ -1,10116 +1,4941 @@
-%c%.matrix (closure) = function (e1, e2) 
-{
-    x <- as.sociomatrix.sna(e1)
-    y <- as.sociomatrix.sna(e2)
-    if (!(is.matrix(x) && is.matrix(y))) 
-        stop("Single graphs required for composition.")
-    round((x %*% y) > 0)
-}
+.__C__Biodetection (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("Biodetection", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__CD (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("CD", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__CountsBio (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("CountsBio", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__GCbias (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("GCbias", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__Output (S4) = new("classRepresentation", slots = list(results = structure("list", package = "methods"), 
+    method = structure("character", package = "methods"), k = structure("numeric", package = "methods"), 
+    lc = structure("numeric", package = "methods"), factor = structure("vector", package = "methods"), 
+    v = structure("numeric", package = "methods"), nss = structure("numeric", package = "methods"), 
+    pnr = structure("numeric", package = "methods"), comparison = structure("vector", package = "methods"), 
+    replicates = structure("character", package = "methods")), 
+    contains = list(myInfo = new("SClassExtension", subClass = structure("Output", package = "NOISeq"), 
+        superClass = structure("myInfo", package = "NOISeq"), 
+        package = "NOISeq", coerce = function (from, strict = TRUE) 
+        {
+            value <- new("myInfo")
+            for (what in c("method", "k", "lc", "factor", "v", 
+            "nss", "pnr", "comparison", "replicates")) slot(value, 
+                what) <- slot(from, what)
+            value
+        }, test = function (object) 
+        TRUE, replace = function (from, to, value) 
+        {
+            for (what in c("method", "k", "lc", "factor", "v", 
+            "nss", "pnr", "comparison", "replicates")) slot(from, 
+                what) <- slot(value, what)
+            from
+        }, simple = TRUE, by = character(0), dataPart = FALSE, 
+        distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = function (object) 
+    {
+        if (!(is.character(object@method))) {
+            return(paste("Method must be a string"))
+        }
+        else if (!(is.numeric(object@k))) {
+            return(paste("k must be numeric"))
+        }
+        else if (!(is.numeric(object@lc))) {
+            return(paste("lc must be numeric"))
+        }
+        else if (!(is.vector(object@factor))) {
+            return(paste("Factor must be a vector of strings"))
+        }
+        else if (!(is.numeric(object@v))) {
+            return(paste("v must be numeric"))
+        }
+        else if (!(is.numeric(object@nss))) {
+            return(paste("nss must be numeric"))
+        }
+        else if (!(is.numeric(object@pnr))) {
+            return(paste("pnr must be numeric"))
+        }
+        else if (!(is.vector(object@comparison))) {
+            return(paste("Comparison must be a vector of strings"))
+        }
+        else if (!(is.list(object@results))) {
+            return(paste("Results must be a list of data.frames"))
+        }
+        else {
+            return(TRUE)
+        }
+    }, access = list(), className = structure("Output", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__PCA (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("PCA", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__Saturation (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("Saturation", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__lengthbias (S4) = new("classRepresentation", slots = list(dat = structure("list", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("lengthbias", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(), versionKey = <pointer: (nil)>, 
+    sealed = FALSE)
+
+.__C__myInfo (S4) = new("classRepresentation", slots = list(method = structure("character", package = "methods"), 
+    k = structure("numeric", package = "methods"), lc = structure("numeric", package = "methods"), 
+    factor = structure("vector", package = "methods"), v = structure("numeric", package = "methods"), 
+    nss = structure("numeric", package = "methods"), pnr = structure("numeric", package = "methods"), 
+    comparison = structure("vector", package = "methods"), replicates = structure("character", package = "methods")), 
+    contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
+    validity = NULL, access = list(), className = structure("myInfo", package = "NOISeq"), 
+    package = "NOISeq", subclasses = list(Output = new("SClassExtension", 
+        subClass = structure("Output", package = "NOISeq"), superClass = structure("myInfo", package = "NOISeq"), 
+        package = "NOISeq", coerce = function (from, strict = TRUE) 
+        {
+            value <- new("myInfo")
+            for (what in c("method", "k", "lc", "factor", "v", 
+            "nss", "pnr", "comparison", "replicates")) slot(value, 
+                what) <- slot(from, what)
+            value
+        }, test = function (object) 
+        TRUE, replace = function (from, to, value) 
+        {
+            for (what in c("method", "k", "lc", "factor", "v", 
+            "nss", "pnr", "comparison", "replicates")) slot(from, 
+                what) <- slot(value, what)
+            from
+        }, simple = TRUE, by = character(0), dataPart = FALSE, 
+        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)
 
 .__NAMESPACE__. (environment) = 
 {
     "S3methods" = "structure(character(0), dim = c(0L, 4L))"
     "dynlibs" = "NULL"
     "exports" = "<environment>"
-    "imports" = "list(base = TRUE, utils = c(aspell_package_Rd_files = "aspell_package_Rd_files", "
-    "imports" = "vi = "vi", read.table = "read.table", URLdecode = "URLdecode", "
-    "imports" = "rc.status = "rc.status", write.csv = "write.csv", RweaveLatexOptions = "RweaveLatexOptions", "
-    "imports" = "formatUL = "formatUL", prompt = "prompt", upgrade = "upgrade", "
-    "imports" = "RShowDoc = "RShowDoc", argsAnywhere = "argsAnywhere", read.delim = "read.delim", "
-    "imports" = "de.ncols = "de.ncols", SweaveSyntConv = "SweaveSyntConv", new.packages = "new.packages", "
-    "imports" = "read.socket = "read.socket", personList = "personList", write.table = "write.table", "
-    "imports" = "read.delim2 = "read.delim2", aspell_package_vignettes = "aspell_package_vignettes", "
-    "imports" = "SweaveHooks = "SweaveHooks", hasName = "hasName", assignInNamespace = "assignInNamespace", "
-    "imports" = "is.relistable = "is.relistable", .DollarNames = ".DollarNames", "
-    "imports" = "toBibtex = "toBibtex", alarm = "alarm", RweaveLatexSetup = "RweaveLatexSetup", "
-    "imports" = "checkCRAN = "checkCRAN", setRepositories = "setRepositories", "
-    "imports" = "warnErrList = "warnErrList", dump.frames = "dump.frames", Rprof = "Rprof", "
-    "imports" = "sessionInfo = "sessionInfo", count.fields = "count.fields", create.post = "create.post", "
-    "imports" = "tail.matrix = "tail.matrix", person = "person", promptPackage = "promptPackage", "
-    "imports" = "install.packages = "install.packages", news = "news", URLencode = "URLencode", "
-    "imports" = "type.convert = "type.convert", help.start = "help.start", osVersion = "osVersion", "
-    "imports" = "de.setup = "de.setup", aregexec = "aregexec", rc.getOption = "rc.getOption", "
-    "imports" = "de.restore = "de.restore", file.edit = "file.edit", citHeader = "citHeader", "
-    "imports" = "fix = "fix", makeRweaveLatexCodeRunner = "makeRweaveLatexCodeRunner", "
-    "imports" = ".RtangleCodeLabel = ".RtangleCodeLabel", write.socket = "write.socket", "
-    "imports" = "unzip = "unzip", Sweave = "Sweave", nsl = "nsl", read.fwf = "read.fwf", "
-    "imports" = "RweaveEvalWithOpt = "RweaveEvalWithOpt", limitedLabels = "limitedLabels", "
-    "imports" = "readCitationFile = "readCitationFile", "?" = "?", process.events = "process.events", "
-    "imports" = "as.relistable = "as.relistable", getParseText = "getParseText", "
-    "imports" = "isS3stdGeneric = "isS3stdGeneric", modifyList = "modifyList", "
-    "imports" = "maintainer = "maintainer", available.packages = "available.packages", "
-    "imports" = "citeNatbib = "citeNatbib", rc.options = "rc.options", setBreakpoint = "setBreakpoint", "
-    "imports" = "Rtangle = "Rtangle", head.matrix = "head.matrix", getTxtProgressBar = "getTxtProgressBar", "
-    "imports" = "tail = "tail", changedFiles = "changedFiles", RweaveLatexFinish = "RweaveLatexFinish", "
-    "imports" = "getAnywhere = "getAnywhere", browseEnv = "browseEnv", object.size = "object.size", "
-    "imports" = "globalVariables = "globalVariables", packageVersion = "packageVersion", "
-    "imports" = "help.search = "help.search", package.skeleton = "package.skeleton", "
-    "imports" = "summaryRprof = "summaryRprof", setTxtProgressBar = "setTxtProgressBar", "
-    "imports" = "timestamp = "timestamp", getSrcref = "getSrcref", stack = "stack", "
-    "imports" = "capture.output = "capture.output", bug.report = "bug.report", "
-    "imports" = "rc.settings = "rc.settings", fileSnapshot = "fileSnapshot", hsearch_db_keywords = "hsearch_db_keywords", "
-    "imports" = "rtags = "rtags", browseVignettes = "browseVignettes", contrib.url = "contrib.url", "
-    "imports" = "strOptions = "strOptions", RweaveLatex = "RweaveLatex", packageDescription = "packageDescription", "
-    "imports" = "SweaveSyntaxNoweb = "SweaveSyntaxNoweb", flush.console = "flush.console", "
-    "imports" = "Rprofmem = "Rprofmem", asDateBuilt = "asDateBuilt", compareVersion = "compareVersion", "
-    "imports" = "charClass = "charClass", as.personList = "as.personList", getFromNamespace = "getFromNamespace", "
-    "imports" = "recover = "recover", packageStatus = "packageStatus", read.csv2 = "read.csv2", "
-    "imports" = "demo = "demo", edit = "edit", aspell_package_R_files = "aspell_package_R_files", "
-    "imports" = "isS3method = "isS3method", de = "de", packageDate = "packageDate", "
-    "imports" = "RSiteSearch = "RSiteSearch", read.DIF = "read.DIF", hsearch_db_concepts = "hsearch_db_concepts", "
-    "imports" = "getSrcLocation = "getSrcLocation", lsf.str = "lsf.str", tar = "tar", "
-    "imports" = "help.request = "help.request", cite = "cite", .S3methods = ".S3methods", "
-    "imports" = "select.list = "select.list", .romans = ".romans", getCRANmirrors = "getCRANmirrors", "
-    "imports" = "relist = "relist", ls.str = "ls.str", localeToCharset = "localeToCharset", "
-    "imports" = "download.packages = "download.packages", debugger = "debugger", "
-    "imports" = "chooseCRANmirror = "chooseCRANmirror", savehistory = "savehistory", "
-    "imports" = "citEntry = "citEntry", RweaveTryStop = "RweaveTryStop", close.socket = "close.socket", "
-    "imports" = "vignette = "vignette", getS3method = "getS3method", askYesNo = "askYesNo", "
-    "imports" = "combn = "combn", loadhistory = "loadhistory", update.packages = "update.packages", "
-    "imports" = "glob2rx = "glob2rx", old.packages = "old.packages", remove.packages = "remove.packages", "
-    "imports" = "RtangleFinish = "RtangleFinish", getParseData = "getParseData", "
-    "imports" = "xedit = "xedit", RtangleRuncode = "RtangleRuncode", SweaveSyntaxLatex = "SweaveSyntaxLatex", "
-    "imports" = "packageName = "packageName", bibentry = "bibentry", RtangleSetup = "RtangleSetup", "
-    "imports" = "findLineNum = "findLineNum", RtangleWritedoc = "RtangleWritedoc", "
-    "imports" = "txtProgressBar = "txtProgressBar", promptData = "promptData", "
-    "imports" = "file_test = "file_test", getSrcFilename = "getSrcFilename", help = "help", "
-    "imports" = "toLatex = "toLatex", installed.packages = "installed.packages", "
-    "imports" = "citFooter = "citFooter", unstack = "unstack", mirror2html = "mirror2html", "
-    "imports" = "debugcall = "debugcall", data.entry = "data.entry", str = "str", "
-    "imports" = "read.fortran = "read.fortran", dataentry = "dataentry", citation = "citation", "
-    "imports" = "emacs = "emacs", head = "head", promptImport = "promptImport", "
-    "imports" = "removeSource = "removeSource", make.packages.html = "make.packages.html", "
-    "imports" = "RweaveChunkPrefix = "RweaveChunkPrefix", page = "page", aspell_write_personal_dictionary_file = "aspell_write_personal_dictionary_file", "
-    "imports" = "formatOL = "formatOL", RweaveLatexWritedoc = "RweaveLatexWritedoc", "
-    "imports" = "memory.limit = "memory.limit", find = "find", pico = "pico", "
-    "imports" = "fixInNamespace = "fixInNamespace", adist = "adist", example = "example", "
-    "imports" = "data = "data", write.csv2 = "write.csv2", memory.size = "memory.size", "
-    "imports" = "menu = "menu", read.csv = "read.csv", url.show = "url.show", "
-    "imports" = "history = "history", chooseBioCmirror = "chooseBioCmirror", View = "View", "
-    "imports" = "assignInMyNamespace = "assignInMyNamespace", hsearch_db = "hsearch_db", "
-    "imports" = "browseURL = "browseURL", untar = "untar", aspell = "aspell", "
-    "imports" = "zip = "zip", make.socket = "make.socket", getSrcDirectory = "getSrcDirectory", "
-    "imports" = "suppressForeignCheck = "suppressForeignCheck", undebugcall = "undebugcall", "
-    "imports" = "Stangle = "Stangle", aspell_package_C_files = "aspell_package_C_files", "
-    "imports" = "download.file = "download.file", apropos = "apropos", as.roman = "as.roman", "
-    "imports" = "xemacs = "xemacs", strcapture = "strcapture", methods = "methods", "
-    "imports" = "as.person = "as.person"), statnet.common = c(NVL = "NVL", .Deprecate_once = ".Deprecate_once", "
-    "imports" = "simplify_simple = "simplify_simple", once = "once", log_mean_exp = "log_mean_exp", "
-    "imports" = ".Deprecate_method = ".Deprecate_method", nonsimp.update.formula = "nonsimp.update.formula", "
-    "imports" = "log_sum_exp = "log_sum_exp", EVL = "EVL", ERRVL = "ERRVL", lweighted.mean = "lweighted.mean", "
-    "imports" = "lweighted.var = "lweighted.var", collate_controls = "collate_controls", "
-    "imports" = "set.control.class = "set.control.class", is.linwmatrix = "is.linwmatrix", "
-    "imports" = "fixed.pval = "fixed.pval", statnet.cite.pkg = "statnet.cite.pkg", "
-    "imports" = "paste.and = "paste.and", is.wmatrix = "is.wmatrix", as.control.list = "as.control.list", "
-    "imports" = "term.list.formula = "term.list.formula", append_rhs.formula = "append_rhs.formula", "
-    "imports" = ""lrowweights<-" = "lrowweights<-", default_options = "default_options", "
-    "imports" = "all_identical = "all_identical", opttest = "opttest", as.linwmatrix = "as.linwmatrix", "
-    "imports" = "as.logwmatrix = "as.logwmatrix", forkTimeout = "forkTimeout", "
-    "imports" = ""ult<-" = "ult<-", persistEvalQ = "persistEvalQ", UPDATE_MY_SCTRL_EXPR = "UPDATE_MY_SCTRL_EXPR", "
-    "imports" = "sweep_cols.matrix = "sweep_cols.matrix", lapply.mcmc.list = "lapply.mcmc.list", "
-    "imports" = "statnet.cite.head = "statnet.cite.head", deInf = "deInf", unwhich = "unwhich", "
-    "imports" = "list_summands.call = "list_summands.call", colMeans.mcmc.list = "colMeans.mcmc.list", "
-    "imports" = "despace = "despace", append.rhs.formula = "append.rhs.formula", "
-    "imports" = "attr = "attr", locate_prefixed_function = "locate_prefixed_function", "
-    "imports" = "compress_rows = "compress_rows", empty_env = "empty_env", ult = "ult", "
-    "imports" = "statnet.cite.foot = "statnet.cite.foot", snctrl = "snctrl", EVL2 = "EVL2", "
-    "imports" = "order = "order", EVL3 = "EVL3", decompress_rows = "decompress_rows", "
-    "imports" = "vector.namesmatch = "vector.namesmatch", is.logwmatrix = "is.logwmatrix", "
-    "imports" = "message_print = "message_print", base_env = "base_env", trim_env = "trim_env", "
-    "imports" = "rowweights = "rowweights", sweep.mcmc.list = "sweep.mcmc.list", "
-    "imports" = "COLLATE_ALL_MY_CONTROLS_EXPR = "COLLATE_ALL_MY_CONTROLS_EXPR", "
-    "imports" = "NVL2 = "NVL2", NVL3 = "NVL3", snctrl_names = "snctrl_names", "
-    "imports" = ""NVL<-" = "NVL<-", nonsimp_update.formula = "nonsimp_update.formula", "
-    "imports" = "handle.controls = "handle.controls", persistEval = "persistEval", "
-    "imports" = "statnetStartupMessage = "statnetStartupMessage", logwmatrix = "logwmatrix", "
-    "imports" = ""EVL<-" = "EVL<-", eval_lhs.formula = "eval_lhs.formula", "rowweights<-" = "rowweights<-", "
-    "imports" = "list_rhs.formula = "list_rhs.formula", update_snctrl = "update_snctrl", "
-    "imports" = "control.remap = "control.remap", linwmatrix = "linwmatrix", filter_rhs.formula = "filter_rhs.formula", "
-    "imports" = "locate_function = "locate_function", lrowweights = "lrowweights", "
-    "imports" = "check.control.class = "check.control.class"), network = c(add.vertices.network = "add.vertices.network", "
-    "imports" = ""%s%" = "%s%", network.arrow = "network.arrow", is.na.network = "is.na.network", "
-    "imports" = ""[.network" = "[.network", "%v%<-" = "%v%<-", network.loop = "network.loop", "
-    "imports" = ""%c%.network" = "%c%.network", read.paj = "read.paj", set.network.attribute = "set.network.attribute", "
-    "imports" = ""&.network" = "&.network", "-.network" = "-.network", "|.network" = "|.network", "
-    "imports" = "get.dyads.eids = "get.dyads.eids", "%eattr%" = "%eattr%", which.matrix.type = "which.matrix.type", "
-    "imports" = ""%n%" = "%n%", "%e%<-" = "%e%<-", get.inducedSubgraph = "get.inducedSubgraph", "
-    "imports" = "as.network.data.frame = "as.network.data.frame", "%nattr%<-" = "%nattr%<-", "
-    "imports" = "network = "network", "%vattr%" = "%vattr%", add.edges = "add.edges", "
-    "imports" = ""%n%<-" = "%n%<-", is.multiplex = "is.multiplex", network.vertex = "network.vertex", "
-    "imports" = "network.bipartite = "network.bipartite", get.edge.attribute = "get.edge.attribute", "
-    "imports" = "as.sociomatrix = "as.sociomatrix", add.vertices = "add.vertices", "
-    "imports" = "get.neighborhood = "get.neighborhood", plot.network = "plot.network", "
-    "imports" = "network.edgelabel = "network.edgelabel", plotArgs.network = "plotArgs.network", "
-    "imports" = "network.layout.circle = "network.layout.circle", "%c%" = "%c%", "
-    "imports" = "as.color = "as.color", network.dyadcount = "network.dyadcount", "
-    "imports" = "network.naedgecount = "network.naedgecount", as.data.frame.network = "as.data.frame.network", "
-    "imports" = "network.layout.kamadakawai = "network.layout.kamadakawai", list.network.attributes = "list.network.attributes", "
-    "imports" = "get.edge.value = "get.edge.value", network.size = "network.size", "
-    "imports" = ""[<-.network" = "[<-.network", has.edges = "has.edges", list.vertex.attributes = "list.vertex.attributes", "
-    "imports" = "set.edge.value = "set.edge.value", print.summary.network = "print.summary.network", "
-    "imports" = "as.matrix.network.edgelist = "as.matrix.network.edgelist", "%v%" = "%v%", "
-    "imports" = "as.network = "as.network", network.layout.fruchtermanreingold = "network.layout.fruchtermanreingold", "
-    "imports" = ""<-.network" = "<-.network", as.matrix.network.incidence = "as.matrix.network.incidence", "
-    "imports" = "network.vertex.names = "network.vertex.names", "*.network" = "*.network", "
-    "imports" = "set.edge.attribute = "set.edge.attribute", network.copy = "network.copy", "
-    "imports" = "as.network.default = "as.network.default", is.directed = "is.directed", "
-    "imports" = "summary.network = "summary.network", delete.network.attribute = "delete.network.attribute", "
-    "imports" = "set.vertex.attribute = "set.vertex.attribute", "network.vertex.names<-" = "network.vertex.names<-", "
-    "imports" = "get.vertex.attribute = "get.vertex.attribute", as.network.network = "as.network.network", "
-    "imports" = ""+.network" = "+.network", network.edgelist = "network.edgelist", "
-    "imports" = "as.network.matrix = "as.network.matrix", is.discrete = "is.discrete", "
-    "imports" = "has.loops = "has.loops", get.edgeIDs = "get.edgeIDs", as.matrix.network = "as.matrix.network", "
-    "imports" = "is.network = "is.network", is.color = "is.color", "%e%" = "%e%", "
-    "imports" = "network.edgecount = "network.edgecount", add.edge = "add.edge", "
-    "imports" = ""%nattr%" = "%nattr%", is.adjacent = "is.adjacent", delete.edges = "delete.edges", "
-    "imports" = "valid.eids = "valid.eids", is.discrete.character = "is.discrete.character", "
-    "imports" = "mixingmatrix = "mixingmatrix", "%eattr%<-" = "%eattr%<-", get.network.attribute = "get.network.attribute", "
-    "imports" = "is.bipartite = "is.bipartite", is.discrete.numeric = "is.discrete.numeric", "
-    "imports" = ""!.network" = "!.network", as.edgelist.matrix = "as.edgelist.matrix", "
-    "imports" = "network.density = "network.density", sum.network = "sum.network", "
-    "imports" = "prod.network = "prod.network", network.initialize = "network.initialize", "
-    "imports" = "get.edges = "get.edges", add.edge.network = "add.edge.network", "
-    "imports" = "as.matrix.network.adjacency = "as.matrix.network.adjacency", "
-    "imports" = "is.hyper = "is.hyper", "%vattr%<-" = "%vattr%<-", network.adjacency = "network.adjacency", "
-    "imports" = "network.incidence = "network.incidence", plot.network.default = "plot.network.default", "
-    "imports" = "list.edge.attributes = "list.edge.attributes", is.edgelist = "is.edgelist", "
-    "imports" = "delete.vertices = "delete.vertices", permute.vertexIDs = "permute.vertexIDs", "
-    "imports" = "delete.vertex.attribute = "delete.vertex.attribute", print.network = "print.network", "
-    "imports" = "as.edgelist = "as.edgelist", add.edges.network = "add.edges.network", "
-    "imports" = "delete.edge.attribute = "delete.edge.attribute"), stats = c(confint.default = "confint.default", "
-    "imports" = "mahalanobis = "mahalanobis", optimize = "optimize", hat = "hat", "
-    "imports" = "Box.test = "Box.test", reorder = "reorder", phyper = "phyper", "
-    "imports" = "ar.mle = "ar.mle", rhyper = "rhyper", contr.SAS = "contr.SAS", "
-    "imports" = "na.exclude = "na.exclude", qgeom = "qgeom", is.ts = "is.ts", "
-    "imports" = "plogis = "plogis", drop.terms = "drop.terms", rlogis = "rlogis", "
-    "imports" = "convolve = "convolve", ts.intersect = "ts.intersect", KalmanSmooth = "KalmanSmooth", "
-    "imports" = "ts.union = "ts.union", smoothEnds = "smoothEnds", is.tskernel = "is.tskernel", "
-    "imports" = "as.formula = "as.formula", dexp = "dexp", inverse.gaussian = "inverse.gaussian", "
-    "imports" = "na.contiguous = "na.contiguous", line = "line", dgeom = "dgeom", "
-    "imports" = "qbirthday = "qbirthday", confint.lm = "confint.lm", cophenetic = "cophenetic", "
-    "imports" = "var.test = "var.test", diffinv = "diffinv", ar = "ar", dummy.coef = "dummy.coef", "
-    "imports" = "cooks.distance = "cooks.distance", density = "density", ptukey = "ptukey", "
-    "imports" = "as.dist = "as.dist", drop1 = "drop1", rbeta = "rbeta", fligner.test = "fligner.test", "
-    "imports" = "naprint = "naprint", qqnorm = "qqnorm", is.stepfun = "is.stepfun", "
-    "imports" = "lsfit = "lsfit", mad = "mad", shapiro.test = "shapiro.test", "
-    "imports" = "qqplot = "qqplot", eff.aovlist = "eff.aovlist", runif = "runif", "
-    "imports" = "isoreg = "isoreg", profile = "profile", is.leaf = "is.leaf", "
-    "imports" = "dchisq = "dchisq", contr.poly = "contr.poly", stepfun = "stepfun", "
-    "imports" = "quasipoisson = "quasipoisson", na.omit = "na.omit", pnbinom = "pnbinom", "
-    "imports" = "ppois = "ppois", model.matrix.default = "model.matrix.default", "
-    "imports" = "family = "family", plot.ecdf = "plot.ecdf", cor.test = "cor.test", "
-    "imports" = "pchisq = "pchisq", rchisq = "rchisq", na.fail = "na.fail", heatmap = "heatmap", "
-    "imports" = "rmultinom = "rmultinom", power.t.test = "power.t.test", qweibull = "qweibull", "
-    "imports" = "complete.cases = "complete.cases", loess.control = "loess.control", "
-    "imports" = "qnbinom = "qnbinom", df = "df", "tsp<-" = "tsp<-", rnorm = "rnorm", "
-    "imports" = "addmargins = "addmargins", asOneSidedFormula = "asOneSidedFormula", "
-    "imports" = "Pair = "Pair", nlm = "nlm", covratio = "covratio", C = "C", as.stepfun = "as.stepfun", "
-    "imports" = "D = "D", ar.burg = "ar.burg", cov2cor = "cov2cor", pgeom = "pgeom", "
-    "imports" = "chisq.test = "chisq.test", p.adjust = "p.adjust", nls = "nls", "
-    "imports" = "integrate = "integrate", fivenum = "fivenum", weighted.mean = "weighted.mean", "
-    "imports" = "rweibull = "rweibull", qqline = "qqline", as.dendrogram = "as.dendrogram", "
-    "imports" = "runmed = "runmed", aov = "aov", dt = "dt", influence = "influence", "
-    "imports" = "rnbinom = "rnbinom", coefficients = "coefficients", tsp = "tsp", "
-    "imports" = "dfbeta = "dfbeta", hasTsp = "hasTsp", dbinom = "dbinom", wilcox.test = "wilcox.test", "
-    "imports" = "scatter.smooth = "scatter.smooth", start = "start", delete.response = "delete.response", "
-    "imports" = "qsignrank = "qsignrank", is.mts = "is.mts", .getXlevels = ".getXlevels", "
-    "imports" = "BIC = "BIC", ks.test = "ks.test", .nknots.smspl = ".nknots.smspl", "
-    "imports" = "order.dendrogram = "order.dendrogram", SSD = "SSD", HoltWinters = "HoltWinters", "
-    "imports" = "qbeta = "qbeta", pbinom = "pbinom", effects = "effects", rbinom = "rbinom", "
-    "imports" = "monthplot = "monthplot", acf2AR = "acf2AR", splinefunH = "splinefunH", "
-    "imports" = "splinefun = "splinefun", qunif = "qunif", nls.control = "nls.control", "
-    "imports" = "dbeta = "dbeta", influence.measures = "influence.measures", as.ts = "as.ts", "
-    "imports" = "prop.trend.test = "prop.trend.test", summary.glm = "summary.glm", "
-    "imports" = "get_all_vars = "get_all_vars", preplot = "preplot", mood.test = "mood.test", "
-    "imports" = "dunif = "dunif", vcov = "vcov", glm.control = "glm.control", "
-    "imports" = "ar.ols = "ar.ols", qgamma = "qgamma", dendrapply = "dendrapply", "
-    "imports" = "arima0.diag = "arima0.diag", dnbinom = "dnbinom", qnorm = "qnorm", "
-    "imports" = ""contrasts<-" = "contrasts<-", SSbiexp = "SSbiexp", poisson.test = "poisson.test", "
-    "imports" = "add.scope = "add.scope", plot.spec.phase = "plot.spec.phase", "
-    "imports" = "dlnorm = "dlnorm", makeARIMA = "makeARIMA", tsSmooth = "tsSmooth", "
-    "imports" = "dnorm = "dnorm", nobs = "nobs", knots = "knots", fitted = "fitted", "
-    "imports" = "spline = "spline", symnum = "symnum", prcomp = "prcomp", friedman.test = "friedman.test", "
-    "imports" = "KalmanForecast = "KalmanForecast", aggregate.data.frame = "aggregate.data.frame", "
-    "imports" = "plot.spec.coherency = "plot.spec.coherency", frequency = "frequency", "
-    "imports" = "decompose = "decompose", dsignrank = "dsignrank", pcauchy = "pcauchy", "
-    "imports" = "dist = "dist", SSmicmen = "SSmicmen", predict = "predict", lag.plot = "lag.plot", "
-    "imports" = "plnorm = "plnorm", write.ftable = "write.ftable", factanal = "factanal", "
-    "imports" = "resid = "resid", rlnorm = "rlnorm", rstandard = "rstandard", "
-    "imports" = "plot.ts = "plot.ts", optim = "optim", glm.fit = "glm.fit", predict.lm = "predict.lm", "
-    "imports" = "dmultinom = "dmultinom", getCall = "getCall", ansari.test = "ansari.test", "
-    "imports" = "loadings = "loadings", NLSstAsymptotic = "NLSstAsymptotic", "window<-" = "window<-", "
-    "imports" = "residuals.glm = "residuals.glm", window = "window", pbeta = "pbeta", "
-    "imports" = "pairwise.t.test = "pairwise.t.test", mantelhaen.test = "mantelhaen.test", "
-    "imports" = "aggregate = "aggregate", qcauchy = "qcauchy", loess.smooth = "loess.smooth", "
-    "imports" = "predict.glm = "predict.glm", extractAIC = "extractAIC", punif = "punif", "
-    "imports" = "approxfun = "approxfun", napredict = "napredict", weights = "weights", "
-    "imports" = "quasibinomial = "quasibinomial", SSweibull = "SSweibull", ave = "ave", "
-    "imports" = "ARMAacf = "ARMAacf", bw.ucv = "bw.ucv", estVar = "estVar", cor = "cor", "
-    "imports" = "update.formula = "update.formula", pbirthday = "pbirthday", se.contrast = "se.contrast", "
-    "imports" = "alias = "alias", rcauchy = "rcauchy", cov = "cov", case.names = "case.names", "
-    "imports" = "ls.print = "ls.print", nlminb = "nlminb", TukeyHSD = "TukeyHSD", "
-    "imports" = "hatvalues = "hatvalues", contr.sum = "contr.sum", ppoints = "ppoints", "
-    "imports" = "filter = "filter", deviance = "deviance", KalmanRun = "KalmanRun", "
-    "imports" = "pnorm = "pnorm", lag = "lag", ar.yw = "ar.yw", lm = "lm", r2dtable = "r2dtable", "
-    "imports" = "cpgram = "cpgram", mcnemar.test = "mcnemar.test", NLSstClosestX = "NLSstClosestX", "
-    "imports" = "makepredictcall = "makepredictcall", NLSstLfAsymptote = "NLSstLfAsymptote", "
-    "imports" = "simulate = "simulate", toeplitz = "toeplitz", SSasympOrig = "SSasympOrig", "
-    "imports" = "summary.manova = "summary.manova", model.extract = "model.extract", "
-    "imports" = "qhyper = "qhyper", model.tables = "model.tables", add1 = "add1", "
-    "imports" = "SSfol = "SSfol", SSasymp = "SSasymp", ts.plot = "ts.plot", Gamma = "Gamma", "
-    "imports" = "plot.stepfun = "plot.stepfun", termplot = "termplot", bartlett.test = "bartlett.test", "
-    "imports" = "oneway.test = "oneway.test", step = "step", qlogis = "qlogis", "
-    "imports" = "df.kernel = "df.kernel", quasi = "quasi", coef = "coef", promax = "promax", "
-    "imports" = "factor.scope = "factor.scope", poisson = "poisson", embed = "embed", "
-    "imports" = "dcauchy = "dcauchy", na.action = "na.action", rect.hclust = "rect.hclust", "
-    "imports" = "SSfpl = "SSfpl", bw.bcv = "bw.bcv", as.hclust = "as.hclust", "
-    "imports" = "varimax = "varimax", model.offset = "model.offset", df.residual = "df.residual", "
-    "imports" = "nextn = "nextn", hclust = "hclust", smooth.spline = "smooth.spline", "
-    "imports" = "qtukey = "qtukey", bw.nrd0 = "bw.nrd0", ppr = "ppr", power.prop.test = "power.prop.test", "
-    "imports" = "pacf = "pacf", pwilcox = "pwilcox", bw.nrd = "bw.nrd", rsignrank = "rsignrank", "
-    "imports" = "quantile = "quantile", stl = "stl", AIC = "AIC", end = "end", "
-    "imports" = "sortedXyData = "sortedXyData", lowess = "lowess", lm.wfit = "lm.wfit", "
-    "imports" = "pf = "pf", princomp = "princomp", terms = "terms", lm.influence = "lm.influence", "
-    "imports" = "model.frame = "model.frame", qwilcox = "qwilcox", stat.anova = "stat.anova", "
-    "imports" = "qchisq = "qchisq", update.default = "update.default", model.response = "model.response", "
-    "imports" = "drop.scope = "drop.scope", residuals = "residuals", median = "median", "
-    "imports" = "cycle = "cycle", DF2formula = "DF2formula", constrOptim = "constrOptim", "
-    "imports" = "pt = "pt", deriv3 = "deriv3", variable.names = "variable.names", "
-    "imports" = "qf = "qf", summary.aov = "summary.aov", update = "update", rwilcox = "rwilcox", "
-    "imports" = "pairwise.table = "pairwise.table", model.matrix.lm = "model.matrix.lm", "
-    "imports" = "expand.model.frame = "expand.model.frame", acf = "acf", proj = "proj", "
-    "imports" = "bw.SJ = "bw.SJ", numericDeriv = "numericDeriv", uniroot = "uniroot", "
-    "imports" = "ARMAtoMA = "ARMAtoMA", ksmooth = "ksmooth", qt = "qt", dffits = "dffits", "
-    "imports" = ".checkMFClasses = ".checkMFClasses", rstudent = "rstudent", rf = "rf", "
-    "imports" = "plclust = "plclust", manova = "manova", dwilcox = "dwilcox", "
-    "imports" = ".vcov.aliased = ".vcov.aliased", kernapply = "kernapply", .MFclass = ".MFclass", "
-    "imports" = "cutree = "cutree", spec.ar = "spec.ar", cmdscale = "cmdscale", "
-    "imports" = "poly = "poly", dweibull = "dweibull", optimise = "optimise", "
-    "imports" = "formula = "formula", sd = "sd", rt = "rt", loglin = "loglin", "
-    "imports" = "qbinom = "qbinom", median.default = "median.default", gaussian = "gaussian", "
-    "imports" = "model.matrix = "model.matrix", fitted.values = "fitted.values", "
-    "imports" = "var = "var", binomial = "binomial", arima.sim = "arima.sim", "
-    "imports" = "logLik = "logLik", selfStart = "selfStart", reformulate = "reformulate", "
-    "imports" = "naresid = "naresid", StructTS = "StructTS", interaction.plot = "interaction.plot", "
-    "imports" = "SSlogis = "SSlogis", terms.formula = "terms.formula", supsmu = "supsmu", "
-    "imports" = "dgamma = "dgamma", weighted.residuals = "weighted.residuals", "
-    "imports" = "smooth = "smooth", kernel = "kernel", confint = "confint", mvfft = "mvfft", "
-    "imports" = "kruskal.test = "kruskal.test", spec.pgram = "spec.pgram", glm = "glm", "
-    "imports" = "ls.diag = "ls.diag", pairwise.wilcox.test = "pairwise.wilcox.test", "
-    "imports" = "NLSstRtAsymptote = "NLSstRtAsymptote", pgamma = "pgamma", rpois = "rpois", "
-    "imports" = "arima = "arima", rgamma = "rgamma", t.test = "t.test", biplot = "biplot", "
-    "imports" = "xtabs = "xtabs", ts = "ts", SSasympOff = "SSasympOff", is.empty.model = "is.empty.model", "
-    "imports" = "summary.lm = "summary.lm", dummy.coef.lm = "dummy.coef.lm", binom.test = "binom.test", "
-    "imports" = "sigma = "sigma", prop.test = "prop.test", na.pass = "na.pass", "
-    "imports" = "make.link = "make.link", summary.stepfun = "summary.stepfun", "
-    "imports" = "reshape = "reshape", ftable = "ftable", density.default = "density.default", "
-    "imports" = "dfbetas = "dfbetas", contrasts = "contrasts", psignrank = "psignrank", "
-    "imports" = "polym = "polym", model.frame.default = "model.frame.default", "
-    "imports" = "rgeom = "rgeom", contr.treatment = "contr.treatment", qlnorm = "qlnorm", "
-    "imports" = "lm.fit = "lm.fit", arima0 = "arima0", offset = "offset", power.anova.test = "power.anova.test", "
-    "imports" = "loess = "loess", pairwise.prop.test = "pairwise.prop.test", kmeans = "kmeans", "
-    "imports" = "aggregate.ts = "aggregate.ts", relevel = "relevel", spectrum = "spectrum", "
-    "imports" = "model.weights = "model.weights", rexp = "rexp", .lm.fit = ".lm.fit", "
-    "imports" = "printCoefmat = "printCoefmat", PP.test = "PP.test", cov.wt = "cov.wt", "
-    "imports" = "residuals.lm = "residuals.lm", replications = "replications", "
-    "imports" = "fisher.test = "fisher.test", qexp = "qexp", screeplot = "screeplot", "
-    "imports" = "contr.helmert = "contr.helmert", deltat = "deltat", medpolish = "medpolish", "
-    "imports" = "pexp = "pexp", rWishart = "rWishart", ccf = "ccf", time = "time", "
-    "imports" = "anova = "anova", IQR = "IQR", KalmanLike = "KalmanLike", optimHess = "optimHess", "
-    "imports" = "pweibull = "pweibull", p.adjust.methods = "p.adjust.methods", "
-    "imports" = "read.ftable = "read.ftable", cancor = "cancor", fft = "fft", "
-    "imports" = "qpois = "qpois", tsdiag = "tsdiag", power = "power", getInitial = "getInitial", "
-    "imports" = "SSgompertz = "SSgompertz", bandwidth.kernel = "bandwidth.kernel", "
-    "imports" = "quade.test = "quade.test", mauchly.test = "mauchly.test", approx = "approx", "
-    "imports" = ".preformat.ts = ".preformat.ts", deriv = "deriv", spec.taper = "spec.taper", "
-    "imports" = "ecdf = "ecdf", dhyper = "dhyper", dpois = "dpois", setNames = "setNames", "
-    "imports" = "dlogis = "dlogis"), graphics = c(assocplot = "assocplot", title = "title", "
-    "imports" = "axis.Date = "axis.Date", points = "points", pairs.default = "pairs.default", "
-    "imports" = "strheight = "strheight", rect = "rect", frame = "frame", identify = "identify", "
-    "imports" = "plot.xy = "plot.xy", stem = "stem", par = "par", plot.default = "plot.default", "
-    "imports" = "fourfoldplot = "fourfoldplot", yinch = "yinch", layout = "layout", "
-    "imports" = "panel.smooth = "panel.smooth", split.screen = "split.screen", "
-    "imports" = "screen = "screen", rug = "rug", plot.new = "plot.new", image.default = "image.default", "
-    "imports" = "boxplot.matrix = "boxplot.matrix", clip = "clip", pairs = "pairs", "
-    "imports" = "points.default = "points.default", lines.default = "lines.default", "
-    "imports" = "strwidth = "strwidth", persp = "persp", plot.design = "plot.design", "
-    "imports" = "matpoints = "matpoints", dotchart = "dotchart", sunflowerplot = "sunflowerplot", "
-    "imports" = ".filled.contour = ".filled.contour", arrows = "arrows", symbols = "symbols", "
-    "imports" = "hist.default = "hist.default", stripchart = "stripchart", xyinch = "xyinch", "
-    "imports" = "xinch = "xinch", contour = "contour", erase.screen = "erase.screen", "
-    "imports" = "Axis = "Axis", text.default = "text.default", grconvertX = "grconvertX", "
-    "imports" = "legend = "legend", text = "text", grconvertY = "grconvertY", "
-    "imports" = "lcm = "lcm", cdplot = "cdplot", hist = "hist", smoothScatter = "smoothScatter", "
-    "imports" = "layout.show = "layout.show", grid = "grid", polypath = "polypath", "
-    "imports" = "close.screen = "close.screen", xspline = "xspline", curve = "curve", "
-    "imports" = "filled.contour = "filled.contour", co.intervals = "co.intervals", "
-    "imports" = "contour.default = "contour.default", boxplot.default = "boxplot.default", "
-    "imports" = "plot.function = "plot.function", spineplot = "spineplot", plot = "plot", "
-    "imports" = "boxplot = "boxplot", rasterImage = "rasterImage", axis.POSIXct = "axis.POSIXct", "
-    "imports" = "bxp = "bxp", box = "box", mtext = "mtext", matplot = "matplot", "
-    "imports" = "abline = "abline", pie = "pie", image = "image", matlines = "matlines", "
-    "imports" = "segments = "segments", lines = "lines", barplot.default = "barplot.default", "
-    "imports" = "barplot = "barplot", locator = "locator", stars = "stars", coplot = "coplot", "
-    "imports" = "mosaicplot = "mosaicplot", polygon = "polygon", plot.window = "plot.window", "
-    "imports" = "axis = "axis", axTicks = "axTicks"), grDevices = c(dev.interactive = "dev.interactive", "
-    "imports" = "gray = "gray"))"
+    "imports" = "list(base = TRUE, Biobase = c(varLabels = "varLabels", "classVersion<-" = "classVersion<-", "
+    "imports" = "".__T__[:base" = ".__T__[:base", "description<-" = "description<-", "
+    "imports" = "".__T__protocolData<-:Biobase" = ".__T__protocolData<-:Biobase", "
+    "imports" = "read.AnnotatedDataFrame = "read.AnnotatedDataFrame", ".__T__normControls:Biobase" = ".__T__normControls:Biobase", "
+    "imports" = ""assayData<-" = "assayData<-", assayDataValidMembers = "assayDataValidMembers", "
+    "imports" = "".__T__notes<-:Biobase" = ".__T__notes<-:Biobase", updateOldESet = "updateOldESet", "
+    "imports" = "dumpPackTxt = "dumpPackTxt", write.exprs = "write.exprs", mkScalar = "mkScalar", "
+    "imports" = "".__T__phenoData:Biobase" = ".__T__phenoData:Biobase", ".__T__se.exprs<-:Biobase" = ".__T__se.exprs<-:Biobase", "
+    "imports" = "contents = "contents", "varLabels<-" = "varLabels<-", ".__T__samples:Biobase" = ".__T__samples:Biobase", "
+    "imports" = "".__T__$<-:base" = ".__T__$<-:base", "fvarLabels<-" = "fvarLabels<-", "
+    "imports" = "".__T__hybridizations:Biobase" = ".__T__hybridizations:Biobase", "
+    "imports" = "".__T__initialize:methods" = ".__T__initialize:methods", "channelNames<-" = "channelNames<-", "
+    "imports" = "sampleNames = "sampleNames", cache = "cache", openVignette = "openVignette", "
+    "imports" = ""pData<-" = "pData<-", copyEnv = "copyEnv", openPDF = "openPDF", "
+    "imports" = "".__T__annotation:BiocGenerics" = ".__T__annotation:BiocGenerics", "
+    "imports" = "expinfo = "expinfo", ".__T__dimLabels:Biobase" = ".__T__dimLabels:Biobase", "
+    "imports" = "".__T__expinfo:Biobase" = ".__T__expinfo:Biobase", ".__T__dims:BiocGenerics" = ".__T__dims:BiocGenerics", "
+    "imports" = "varMetadata = "varMetadata", .__C__Versioned = ".__C__Versioned", "
+    "imports" = ".__C__VersionedBiobase = ".__C__VersionedBiobase", esApply = "esApply", "
+    "imports" = "".__T__rowMedians:Biobase" = ".__T__rowMedians:Biobase", ".__T__preproc<-:Biobase" = ".__T__preproc<-:Biobase", "
+    "imports" = ".__C__Versions = ".__C__Versions", .__C__ScalarObject = ".__C__ScalarObject", "
+    "imports" = "addVigs2WinMenu = "addVigs2WinMenu", selectSome = "selectSome", "
+    "imports" = "Aggregate = "Aggregate", storageMode = "storageMode", .__C__MIAxE = ".__C__MIAxE", "
+    "imports" = "lcPrefix = "lcPrefix", isCurrent = "isCurrent", "fvarMetadata<-" = "fvarMetadata<-", "
+    "imports" = ""pubMedIds<-" = "pubMedIds<-", fvarLabels = "fvarLabels", readExpressionSet = "readExpressionSet", "
+    "imports" = ""notes<-" = "notes<-", ".__T__fData:Biobase" = ".__T__fData:Biobase", "
+    "imports" = "annotatedDataFrameFrom = "annotatedDataFrameFrom", multiassign = "multiassign", "
+    "imports" = "experimentData = "experimentData", rowQ = "rowQ", samples = "samples", "
+    "imports" = "makeDataPackage = "makeDataPackage", ".__T__updateObject:BiocGenerics" = ".__T__updateObject:BiocGenerics", "
+    "imports" = "".__T__featureData<-:Biobase" = ".__T__featureData<-:Biobase", "
+    "imports" = ""featureData<-" = "featureData<-", testBioCConnection = "testBioCConnection", "
+    "imports" = ""protocolData<-" = "protocolData<-", ".__T__varMetadata<-:Biobase" = ".__T__varMetadata<-:Biobase", "
+    "imports" = "".__T__storageMode<-:Biobase" = ".__T__storageMode<-:Biobase", "
+    "imports" = ".__C__ScalarNumeric = ".__C__ScalarNumeric", .__C__MIAME = ".__C__MIAME", "
+    "imports" = ".__C__ExpressionSet = ".__C__ExpressionSet", ".__T__varLabels<-:Biobase" = ".__T__varLabels<-:Biobase", "
+    "imports" = "write.AnnotatedDataFrame = "write.AnnotatedDataFrame", ".__T__featureNames<-:Biobase" = ".__T__featureNames<-:Biobase", "
+    "imports" = "".__T__experimentData:Biobase" = ".__T__experimentData:Biobase", "
+    "imports" = "".__T__coerce:methods" = ".__T__coerce:methods", ExpressionSet = "ExpressionSet", "
+    "imports" = "".__T__phenoData<-:Biobase" = ".__T__phenoData<-:Biobase", ".__T__$:base" = ".__T__$:base", "
+    "imports" = ""storageMode<-" = "storageMode<-", ".__T__snpCallProbability:Biobase" = ".__T__snpCallProbability:Biobase", "
+    "imports" = "show = "show", ".__T__exprs<-:Biobase" = ".__T__exprs<-:Biobase", "
+    "imports" = "".__T__fvarMetadata:Biobase" = ".__T__fvarMetadata:Biobase", "
+    "imports" = "".__T__fData<-:Biobase" = ".__T__fData<-:Biobase", ".__T__dim:base" = ".__T__dim:base", "
+    "imports" = ".__C__characterORMIAME = ".__C__characterORMIAME", initialize = "initialize", "
+    "imports" = "rowMedians = "rowMedians", .__C__AssayData = ".__C__AssayData", "
+    "imports" = "assayDataElement = "assayDataElement", "snpCall<-" = "snpCall<-", "
+    "imports" = "".__T__featureNames:Biobase" = ".__T__featureNames:Biobase", "
+    "imports" = "".__T__notes:Biobase" = ".__T__notes:Biobase", lcSuffix = "lcSuffix", "
+    "imports" = "abstract = "abstract", normControls = "normControls", "snpCallProbability<-" = "snpCallProbability<-", "
+    "imports" = "assayDataElementNames = "assayDataElementNames", phenoData = "phenoData", "
+    "imports" = "".__T__storageMode:Biobase" = ".__T__storageMode:Biobase", ".__T__varMetadata:Biobase" = ".__T__varMetadata:Biobase", "
+    "imports" = "rowMin = "rowMin", ".__T__dimLabels<-:Biobase" = ".__T__dimLabels<-:Biobase", "
+    "imports" = "".__T__otherInfo:Biobase" = ".__T__otherInfo:Biobase", ".__T__experimentData<-:Biobase" = ".__T__experimentData<-:Biobase", "
+    "imports" = ".__C__annotatedDataset = ".__C__annotatedDataset", ".__T__classVersion:Biobase" = ".__T__classVersion:Biobase", "
+    "imports" = "".__T__isCurrent:Biobase" = ".__T__isCurrent:Biobase", .__C__eSet = ".__C__eSet", "
+    "imports" = "".__T__dimnames<-:base" = ".__T__dimnames<-:base", ".__T__[[:base" = ".__T__[[:base", "
+    "imports" = "".__T__preproc:Biobase" = ".__T__preproc:Biobase", matchpt = "matchpt", "
+    "imports" = "isUnique = "isUnique", ".__T__pubMedIds<-:Biobase" = ".__T__pubMedIds<-:Biobase", "
+    "imports" = "channel = "channel", .__C__ScalarLogical = ".__C__ScalarLogical", "
+    "imports" = "".__T__contents:Biobase" = ".__T__contents:Biobase", ".__T__isVersioned:Biobase" = ".__T__isVersioned:Biobase", "
+    "imports" = "reverseSplit = "reverseSplit", ".__T__assayData:Biobase" = ".__T__assayData:Biobase", "
+    "imports" = "se.exprs = "se.exprs", ".__T__Compare:methods" = ".__T__Compare:methods", "
+    "imports" = "".__T__featureData:Biobase" = ".__T__featureData:Biobase", ".__T__pData:Biobase" = ".__T__pData:Biobase", "
+    "imports" = ".__C__ScalarCharacter = ".__C__ScalarCharacter", ".__T__[[<-:base" = ".__T__[[<-:base", "
+    "imports" = ".__C__aggregator = ".__C__aggregator", featureNames = "featureNames", "
+    "imports" = "".__T__description<-:Biobase" = ".__T__description<-:Biobase", "
+    "imports" = "fvarMetadata = "fvarMetadata", updateObjectTo = "updateObjectTo", "
+    "imports" = "assayDataNew = "assayDataNew", classVersion = "classVersion", "
+    "imports" = "fData = "fData", notes = "notes", snpCallProbability = "snpCallProbability", "
+    "imports" = "".__T__ExpressionSet:Biobase" = ".__T__ExpressionSet:Biobase", "
+    "imports" = "".__T__rowQ:Biobase" = ".__T__rowQ:Biobase", hybridizations = "hybridizations", "
+    "imports" = "".__T__snpCallProbability<-:Biobase" = ".__T__snpCallProbability<-:Biobase", "
+    "imports" = "NChannelSet = "NChannelSet", ".__T__se.exprs:Biobase" = ".__T__se.exprs:Biobase", "
+    "imports" = "package.version = "package.version", ".__T__length:base" = ".__T__length:base", "
+    "imports" = "snpCall = "snpCall", assayData = "assayData", Compare = "Compare", "
+    "imports" = "lcPrefixC = "lcPrefixC", ".__T__initfun:Biobase" = ".__T__initfun:Biobase", "
+    "imports" = "coerce = "coerce", ".__T__varLabels:Biobase" = ".__T__varLabels:Biobase", "
+    "imports" = ""sampleNames<-" = "sampleNames<-", ".__T__channelNames:Biobase" = ".__T__channelNames:Biobase", "
+    "imports" = "".__T__assayData<-:Biobase" = ".__T__assayData<-:Biobase", .__C__data.frameOrNULL = ".__C__data.frameOrNULL", "
+    "imports" = "pubMedIds = "pubMedIds", ".__T__AnnotatedDataFrame:Biobase" = ".__T__AnnotatedDataFrame:Biobase", "
+    "imports" = "".__T__dimnames:base" = ".__T__dimnames:base", userQuery = "userQuery", "
+    "imports" = "".__T__content:Biobase" = ".__T__content:Biobase", .__C__VersionsNull = ".__C__VersionsNull", "
+    "imports" = "locked = "locked", selectChannels = "selectChannels", ".__T__annotatedDataFrameFrom:Biobase" = ".__T__annotatedDataFrameFrom:Biobase", "
+    "imports" = ""annotation<-" = "annotation<-", ".__T__show:methods" = ".__T__show:methods", "
+    "imports" = "dimLabels = "dimLabels", read.MIAME = "read.MIAME", ".__T__combine:BiocGenerics" = ".__T__combine:BiocGenerics", "
+    "imports" = "".__T__pData<-:Biobase" = ".__T__pData<-:Biobase", "se.exprs<-" = "se.exprs<-", "
+    "imports" = ""featureNames<-" = "featureNames<-", content = "content", otherInfo = "otherInfo", "
+    "imports" = "dims = "dims", assayDataElementReplace = "assayDataElementReplace", "
+    "imports" = "as.data.frame.ExpressionSet = "as.data.frame.ExpressionSet", "
+    "imports" = "".__T__channel:Biobase" = ".__T__channel:Biobase", initfun = "initfun", "
+    "imports" = "".__T__sampleNames:Biobase" = ".__T__sampleNames:Biobase", AnnotatedDataFrame = "AnnotatedDataFrame", "
+    "imports" = ".__C__SnpSet = ".__C__SnpSet", ".__T__abstract:Biobase" = ".__T__abstract:Biobase", "
+    "imports" = ""fData<-" = "fData<-", "dimLabels<-" = "dimLabels<-", ".__T__makeDataPackage:Biobase" = ".__T__makeDataPackage:Biobase", "
+    "imports" = "strbreak = "strbreak", note = "note", ".__T__snpCall:Biobase" = ".__T__snpCall:Biobase", "
+    "imports" = "".__T__annotation<-:BiocGenerics" = ".__T__annotation<-:BiocGenerics", "
+    "imports" = "exprs = "exprs", "exprs<-" = "exprs<-", copySubstitute = "copySubstitute", "
+    "imports" = "".__T__pubMedIds:Biobase" = ".__T__pubMedIds:Biobase", ".__T__locked:Biobase" = ".__T__locked:Biobase", "
+    "imports" = ".__C__container = ".__C__container", ".__T__description:Biobase" = ".__T__description:Biobase", "
+    "imports" = "aggfun = "aggfun", "assayDataElement<-" = "assayDataElement<-", "
+    "imports" = "".__T__write.exprs:Biobase" = ".__T__write.exprs:Biobase", pData = "pData", "
+    "imports" = "".__T__classVersion<-:Biobase" = ".__T__classVersion<-:Biobase", "
+    "imports" = "getPkgVigs = "getPkgVigs", validMsg = "validMsg", .__C__ScalarInteger = ".__C__ScalarInteger", "
+    "imports" = "".__T__fvarLabels<-:Biobase" = ".__T__fvarLabels<-:Biobase", "
+    "imports" = "".__T__fvarMetadata<-:Biobase" = ".__T__fvarMetadata<-:Biobase", "
+    "imports" = "".__T__snpCall<-:Biobase" = ".__T__snpCall<-:Biobase", rowMax = "rowMax", "
+    "imports" = "MIAME = "MIAME", createPackage = "createPackage", ".__T__fvarLabels:Biobase" = ".__T__fvarLabels:Biobase", "
+    "imports" = "channelNames = "channelNames", featureData = "featureData", ".__T__aggenv:Biobase" = ".__T__aggenv:Biobase", "
+    "imports" = ""experimentData<-" = "experimentData<-", preproc = "preproc", "
+    "imports" = "".__T__updateObjectTo:Biobase" = ".__T__updateObjectTo:Biobase", "
+    "imports" = ".__C__AnnotatedDataFrame = ".__C__AnnotatedDataFrame", ".__T__selectChannels:Biobase" = ".__T__selectChannels:Biobase", "
+    "imports" = "".__T__channelNames<-:Biobase" = ".__T__channelNames<-:Biobase", "
+    "imports" = "".__T__protocolData:Biobase" = ".__T__protocolData:Biobase", "
+    "imports" = "updateObject = "updateObject", ".__T__esApply:Biobase" = ".__T__esApply:Biobase", "
+    "imports" = ".__C__NChannelSet = ".__C__NChannelSet", annotation = "annotation", "
+    "imports" = ".__C__MultiSet = ".__C__MultiSet", subListExtract = "subListExtract", "
+    "imports" = ""preproc<-" = "preproc<-", "phenoData<-" = "phenoData<-", description = "description", "
+    "imports" = "combine = "combine", ".__T__[<-:base" = ".__T__[<-:base", protocolData = "protocolData", "
+    "imports" = "".__T__aggfun:Biobase" = ".__T__aggfun:Biobase", ".__T__sampleNames<-:Biobase" = ".__T__sampleNames<-:Biobase", "
+    "imports" = "anyMissing = "anyMissing", listLen = "listLen", ".__T__exprs:Biobase" = ".__T__exprs:Biobase", "
+    "imports" = "aggenv = "aggenv", isVersioned = "isVersioned", "varMetadata<-" = "varMetadata<-""
+    "imports" = "), methods = c(extends = "extends", "S3Class<-" = "S3Class<-", "
+    "imports" = "makeMethodsList = "makeMethodsList", assignMethodsMetaData = "assignMethodsMetaData", "
+    "imports" = "Summary = "Summary", setReplaceMethod = "setReplaceMethod", .__C__EmptyMethodsList = ".__C__EmptyMethodsList", "
+    "imports" = "methodSignatureMatrix = "methodSignatureMatrix", el = "el", .__C__lm = ".__C__lm", "
+    "imports" = "completeClassDefinition = "completeClassDefinition", newEmptyObject = "newEmptyObject", "
+    "imports" = "isGrammarSymbol = "isGrammarSymbol", findFunction = "findFunction", "
+    "imports" = "hasMethods = "hasMethods", .__C__ObjectsWithPackage = ".__C__ObjectsWithPackage", "
+    "imports" = "sigToEnv = "sigToEnv", .__C__namedList = ".__C__namedList", SignatureMethod = "SignatureMethod", "
+    "imports" = "method.skeleton = "method.skeleton", .hasSlot = ".hasSlot", .__C__PossibleMethod = ".__C__PossibleMethod", "
+    "imports" = "selectMethod = "selectMethod", metaNameUndo = "metaNameUndo", "
+    "imports" = ".__C__matrix = ".__C__matrix", .__C__refObject = ".__C__refObject", "
+    "imports" = ".__C__nonstandardGroupGenericFunction = ".__C__nonstandardGroupGenericFunction", "
+    "imports" = ".__C__refMethodDefWithTrace = ".__C__refMethodDefWithTrace", "
+    "imports" = ""slot<-" = "slot<-", .__C__classGeneratorFunction = ".__C__classGeneratorFunction", "
+    "imports" = "findMethod = "findMethod", possibleExtends = "possibleExtends", "
+    "imports" = "".__T__rbind2:methods" = ".__T__rbind2:methods", showMethods = "showMethods", "
+    "imports" = "findUnique = "findUnique", initialize = "initialize", formalArgs = "formalArgs", "
+    "imports" = ".__C__NULL = ".__C__NULL", .__C__glm.null = ".__C__glm.null", "
+    "imports" = "initRefFields = "initRefFields", "packageSlot<-" = "packageSlot<-", "
+    "imports" = "className = "className", S3Class = "S3Class", setGenericImplicit = "setGenericImplicit", "
+    "imports" = "makeClassRepresentation = "makeClassRepresentation", hasMethod = "hasMethod", "
+    "imports" = "MethodAddCoerce = "MethodAddCoerce", getGeneric = "getGeneric", "
+    "imports" = ".__C__list = ".__C__list", evalqOnLoad = "evalqOnLoad", resetGeneric = "resetGeneric", "
+    "imports" = "makePrototypeFromClassDef = "makePrototypeFromClassDef", .__C__functionWithTrace = ".__C__functionWithTrace", "
+    "imports" = ".__C__MethodDefinitionWithTrace = ".__C__MethodDefinitionWithTrace", "
+    "imports" = ".debugMethod = ".debugMethod", setLoadActions = "setLoadActions", "
+    "imports" = "slotNames = "slotNames", .__C__OptionalFunction = ".__C__OptionalFunction", "
+    "imports" = ".__C__derivedDefaultMethod = ".__C__derivedDefaultMethod", checkAtAssignment = "checkAtAssignment", "
+    "imports" = ".__C__traceable = ".__C__traceable", setOldClass = "setOldClass", "
+    "imports" = "".__T__Complex:base" = ".__T__Complex:base", substituteDirect = "substituteDirect", "
+    "imports" = "requireMethods = "requireMethods", Complex = "Complex", setIs = "setIs", "
+    "imports" = "methodsPackageMetaName = "methodsPackageMetaName", linearizeMlist = "linearizeMlist", "
+    "imports" = "isSealedClass = "isSealedClass", kronecker = "kronecker", cbind2 = "cbind2", "
+    "imports" = ".__C__builtin = ".__C__builtin", .__C__ClassUnionRepresentation = ".__C__ClassUnionRepresentation", "
+    "imports" = "isGeneric = "isGeneric", .__C__refClassRepresentation = ".__C__refClassRepresentation", "
+    "imports" = "".__T__Arith:base" = ".__T__Arith:base", canCoerce = "canCoerce", "
+    "imports" = "newBasic = "newBasic", .__C__.environment = ".__C__.environment", "
+    "imports" = ".__C__refClass = ".__C__refClass", completeSubclasses = "completeSubclasses", "
+    "imports" = ".__C__table = ".__C__table", getLoadActions = "getLoadActions", "
+    "imports" = "getClassDef = "getClassDef", findClass = "findClass", .__C__language = ".__C__language", "
+    "imports" = ".__C__anova.glm.null = ".__C__anova.glm.null", registerImplicitGenerics = "registerImplicitGenerics", "
+    "imports" = "".__T__body<-:base" = ".__T__body<-:base", isClassDef = "isClassDef", "
+    "imports" = "setValidity = "setValidity", setPrimitiveMethods = "setPrimitiveMethods", "
+    "imports" = "is = "is", ".__T__Logic:base" = ".__T__Logic:base", Logic = "Logic", "
+    "imports" = ".S4methods = ".S4methods", .__C__socket = ".__C__socket", cacheMethod = "cacheMethod", "
+    "imports" = ""S3Part<-" = "S3Part<-", asMethodDefinition = "asMethodDefinition", "
+    "imports" = ".__C__special = ".__C__special", representation = "representation", "
+    "imports" = ".__C__SealedMethodDefinition = ".__C__SealedMethodDefinition", "
+    "imports" = "isSealedMethod = "isSealedMethod", .__C__raw = ".__C__raw", S3Part = "S3Part", "
+    "imports" = ".__C__environment = ".__C__environment", .__C__integer = ".__C__integer", "
+    "imports" = "listFromMlist = "listFromMlist", .__C__mts = ".__C__mts", .doTracePrint = ".doTracePrint", "
+    "imports" = ".OldClassesList = ".OldClassesList", .__C__standardGeneric = ".__C__standardGeneric", "
+    "imports" = ".__C__MethodsList = ".__C__MethodsList", ".__T__Math2:methods" = ".__T__Math2:methods", "
+    "imports" = "promptMethods = "promptMethods", setPackageName = "setPackageName", "
+    "imports" = ".__C__groupGenericFunction = ".__C__groupGenericFunction", tryNew = "tryNew", "
+    "imports" = ".classEnv = ".classEnv", ".__C__(" = ".__C__(", Arith = "Arith", "
+    "imports" = ".isMethodDebugged = ".isMethodDebugged", .__C__LinearMethodsList = ".__C__LinearMethodsList", "
+    "imports" = ".__C__formula = ".__C__formula", assignClassDef = "assignClassDef", "
+    "imports" = ".__C__ordered = ".__C__ordered", setMethod = "setMethod", .__C__SClassExtension = ".__C__SClassExtension", "
+    "imports" = ".__C__expression = ".__C__expression", .__C__classRepresentation = ".__C__classRepresentation", "
+    "imports" = "setRefClass = "setRefClass", .__C__numeric = ".__C__numeric", "
+    "imports" = "evalSource = "evalSource", rbind2 = "rbind2", balanceMethodsList = "balanceMethodsList", "
+    "imports" = ".__C__VIRTUAL = ".__C__VIRTUAL", conformMethod = "conformMethod", "
+    "imports" = "getClass = "getClass", .__C__complex = ".__C__complex", getMethod = "getMethod", "
+    "imports" = "getGenerics = "getGenerics", finalDefaultMethod = "finalDefaultMethod", "
+    "imports" = "showClass = "showClass", .__C__name = ".__C__name", "elNamed<-" = "elNamed<-", "
+    "imports" = ".__C__nonstandardGeneric = ".__C__nonstandardGeneric", .__C__POSIXct = ".__C__POSIXct", "
+    "imports" = ".__C__factor = ".__C__factor", .__C__libraryIQR = ".__C__libraryIQR", "
+    "imports" = "empty.dump = "empty.dump", validSlotNames = "validSlotNames", "
+    "imports" = "new = "new", ".__T__coerce<-:methods" = ".__T__coerce<-:methods", "
+    "imports" = ".__C__listOfMethods = ".__C__listOfMethods", existsFunction = "existsFunction", "
+    "imports" = ""el<-" = "el<-", .__C__.externalptr = ".__C__.externalptr", .__C__classPrototypeDef = ".__C__classPrototypeDef", "
+    "imports" = "getClasses = "getClasses", isVirtualClass = "isVirtualClass", "
+    "imports" = "elNamed = "elNamed", getDataPart = "getDataPart", .__C__mtable = ".__C__mtable", "
+    "imports" = ".__C__anova = ".__C__anova", sealClass = "sealClass", .selectSuperClasses = ".selectSuperClasses", "
+    "imports" = "getMethodsMetaData = "getMethodsMetaData", .__C__maov = ".__C__maov", "
+    "imports" = "isClassUnion = "isClassUnion", "languageEl<-" = "languageEl<-", "
+    "imports" = "matchSignature = "matchSignature", .EmptyPrimitiveSkeletons = ".EmptyPrimitiveSkeletons", "
+    "imports" = "signature = "signature", loadMethod = "loadMethod", .__C__packageInfo = ".__C__packageInfo", "
+    "imports" = "".__C__{" = ".__C__{", evalOnLoad = "evalOnLoad", .__C__MethodWithNextWithTrace = ".__C__MethodWithNextWithTrace", "
+    "imports" = ".__C__dump.frames = ".__C__dump.frames", fixPre1.8 = "fixPre1.8", "
+    "imports" = "getMethodsForDispatch = "getMethodsForDispatch", setLoadAction = "setLoadAction", "
+    "imports" = ".TraceWithMethods = ".TraceWithMethods", missingArg = "missingArg", "
+    "imports" = "externalRefMethod = "externalRefMethod", .__C__function = ".__C__function", "
+    "imports" = ".__C__envRefClass = ".__C__envRefClass", defaultPrototype = "defaultPrototype", "
+    "imports" = ".__C__glm = ".__C__glm", insertSource = "insertSource", dumpMethod = "dumpMethod", "
+    "imports" = ".__C__if = ".__C__if", .__C__oldClass = ".__C__oldClass", coerce = "coerce", "
+    "imports" = "hasArg = "hasArg", .__C__refGeneratorSlot = ".__C__refGeneratorSlot", "
+    "imports" = "testInheritedMethods = "testInheritedMethods", insertClassMethods = "insertClassMethods", "
+    "imports" = ".__C__call = ".__C__call", .__C__data.frame = ".__C__data.frame", "
+    "imports" = "Math = "Math", .__C__for = ".__C__for", removeMethods = "removeMethods", "
+    "imports" = ".__C__array = ".__C__array", getPackageName = "getPackageName", "
+    "imports" = ".__C__MethodDefinition = ".__C__MethodDefinition", .__C__nonstandardGenericWithTrace = ".__C__nonstandardGenericWithTrace", "
+    "imports" = "rematchDefinition = "rematchDefinition", insertMethod = "insertMethod", "
+    "imports" = "findMethods = "findMethods", mergeMethods = "mergeMethods", .__C__POSIXt = ".__C__POSIXt", "
+    "imports" = ""coerce<-" = "coerce<-", .undebugMethod = ".undebugMethod", unRematchDefinition = "unRematchDefinition", "
+    "imports" = ".__C__refObjectGenerator = ".__C__refObjectGenerator", .__C__Date = ".__C__Date", "
+    "imports" = ".__C__missing = ".__C__missing", callGeneric = "callGeneric", "
+    "imports" = ".__C__externalptr = ".__C__externalptr", .__C__derivedDefaultMethodWithTrace = ".__C__derivedDefaultMethodWithTrace", "
+    "imports" = ".__C__ANY = ".__C__ANY", existsMethod = "existsMethod", showExtends = "showExtends", "
+    "imports" = "MethodsList = "MethodsList", showMlist = "showMlist", makeStandardGeneric = "makeStandardGeneric", "
+    "imports" = ".__C__className = ".__C__className", .__C__character = ".__C__character", "
+    "imports" = "initFieldArgs = "initFieldArgs", .__C__genericFunction = ".__C__genericFunction", "
+    "imports" = ".__C__signature = ".__C__signature", .__C__uninitializedField = ".__C__uninitializedField", "
+    "imports" = ".untracedFunction = ".untracedFunction", ".__T__Ops:base" = ".__T__Ops:base", "
+    "imports" = ".__C__while = ".__C__while", validObject = "validObject", resetClass = "resetClass", "
+    "imports" = ".__C__hsearch = ".__C__hsearch", isGroup = "isGroup", substituteFunctionArgs = "substituteFunctionArgs", "
+    "imports" = "multipleClasses = "multipleClasses", cacheGenericsMetaData = "cacheGenericsMetaData", "
+    "imports" = "dumpMethods = "dumpMethods", .__C__conditionalExtension = ".__C__conditionalExtension", "
+    "imports" = "prototype = "prototype", packageSlot = "packageSlot", setGeneric = "setGeneric", "
+    "imports" = "testVirtual = "testVirtual", prohibitGeneric = "prohibitGeneric", "
+    "imports" = ".__C__groupGenericFunctionWithTrace = ".__C__groupGenericFunctionWithTrace", "
+    "imports" = "".__T__addNextMethod:methods" = ".__T__addNextMethod:methods", "
+    "imports" = "selectSuperClasses = "selectSuperClasses", slot = "slot", doPrimitiveMethod = "doPrimitiveMethod", "
+    "imports" = ".__C__summaryDefault = ".__C__summaryDefault", .__C__recordedplot = ".__C__recordedplot", "
+    "imports" = ".ShortPrimitiveSkeletons = ".ShortPrimitiveSkeletons", show = "show", "
+    "imports" = ".__C__nonstandardGenericFunction = ".__C__nonstandardGenericFunction", "
+    "imports" = "cacheMetaData = "cacheMetaData", .__C__repeat = ".__C__repeat", "
+    "imports" = "Ops = "Ops", superClassDepth = "superClassDepth", .__C__vector = ".__C__vector", "
+    "imports" = ".__C__POSIXlt = ".__C__POSIXlt", makeExtends = "makeExtends", "
+    "imports" = "getValidity = "getValidity", functionBody = "functionBody", ".__C__<-" = ".__C__<-", "
+    "imports" = "completeExtends = "completeExtends", .__C__integrate = ".__C__integrate", "
+    "imports" = ".__C__structure = ".__C__structure", slotsFromS3 = "slotsFromS3", "
+    "imports" = ""as<-" = "as<-", .__C__genericFunctionWithTrace = ".__C__genericFunctionWithTrace", "
+    "imports" = ".__C__rle = ".__C__rle", .__C__activeBindingFunction = ".__C__activeBindingFunction", "
+    "imports" = "Math2 = "Math2", .__C__SuperClassMethod = ".__C__SuperClassMethod", "
+    "imports" = "promptClass = "promptClass", Quote = "Quote", .__C__internalDispatchMethod = ".__C__internalDispatchMethod", "
+    "imports" = "setClassUnion = "setClassUnion", "body<-" = "body<-", removeMethod = "removeMethod", "
+    "imports" = "newClassRepresentation = "newClassRepresentation", .__C__localRefClass = ".__C__localRefClass", "
+    "imports" = ".__C__refMethodDef = ".__C__refMethodDef", generic.skeleton = "generic.skeleton", "
+    "imports" = ".__C__.name = ".__C__.name", isRematched = "isRematched", hasLoadAction = "hasLoadAction", "
+    "imports" = "setAs = "setAs", .__C__aov = ".__C__aov", ".__T__cbind2:methods" = ".__T__cbind2:methods", "
+    "imports" = "listFromMethods = "listFromMethods", .__C__data.frameRowLabels = ".__C__data.frameRowLabels", "
+    "imports" = "classesToAM = "classesToAM", classLabel = "classLabel", allNames = "allNames", "
+    "imports" = "getSlots = "getSlots", .__C__double = ".__C__double", .__C__S3 = ".__C__S3", "
+    "imports" = ".__C__S4 = ".__C__S4", inheritedSlotNames = "inheritedSlotNames", "
+    "imports" = "showDefault = "showDefault", reconcilePropertiesAndPrototype = "reconcilePropertiesAndPrototype", "
+    "imports" = "removeGeneric = "removeGeneric", getRefClass = "getRefClass", "
+    "imports" = ".__C__anova.glm = ".__C__anova.glm", addNextMethod = "addNextMethod", "
+    "imports" = ".__C__packageIQR = ".__C__packageIQR", Compare = "Compare", MethodsListSelect = "MethodsListSelect", "
+    "imports" = "as = "as", .__C__standardGenericWithTrace = ".__C__standardGenericWithTrace", "
+    "imports" = "isXS3Class = "isXS3Class", languageEl = "languageEl", removeClass = "removeClass", "
+    "imports" = ".__C__nonStructure = ".__C__nonStructure", callNextMethod = "callNextMethod", "
+    "imports" = "defaultDumpName = "defaultDumpName", makeGeneric = "makeGeneric", "
+    "imports" = "isClass = "isClass", ".__T__slotsFromS3:methods" = ".__T__slotsFromS3:methods", "
+    "imports" = ".__C__.NULL = ".__C__.NULL", setGroupGeneric = "setGroupGeneric", "
+    "imports" = ".__C__density = ".__C__density", getFunction = "getFunction", "
+    "imports" = ".__C__logLik = ".__C__logLik", classMetaName = "classMetaName", "
+    "imports" = ".__C__externalRefMethod = ".__C__externalRefMethod", .__C__MethodSelectionReport = ".__C__MethodSelectionReport", "
+    "imports" = "setClass = "setClass", .valueClassTest = ".valueClassTest", .__C__optionalMethod = ".__C__optionalMethod", "
+    "imports" = "getGroup = "getGroup", checkSlotAssignment = "checkSlotAssignment", "
+    "imports" = "implicitGeneric = "implicitGeneric", getAllSuperClasses = "getAllSuperClasses", "
+    "imports" = ".__C__ts = ".__C__ts", getGroupMembers = "getGroupMembers", .__C__MethodWithNext = ".__C__MethodWithNext", "
+    "imports" = ".__C__logical = ".__C__logical", setDataPart = "setDataPart", "
+    "imports" = "getMethods = "getMethods", .__C__defaultBindingFunction = ".__C__defaultBindingFunction", "
+    "imports" = "findMethodSignatures = "findMethodSignatures", .__C__.Other = ".__C__.Other", "
+    "imports" = "emptyMethodsList = "emptyMethodsList", .__C__summary.table = ".__C__summary.table", "
+    "imports" = ".__C__mlm = ".__C__mlm", .slotNames = ".slotNames", .__C__sourceEnvironment = ".__C__sourceEnvironment", "
+    "imports" = "".__T__Summary:base" = ".__T__Summary:base", ".__T__Math:base" = ".__T__Math:base", "
+    "imports" = ""functionBody<-" = "functionBody<-", ".__T__loadMethod:methods" = ".__T__loadMethod:methods", "
+    "imports" = "".__T__kronecker:base" = ".__T__kronecker:base"), splines = c(bs = "bs", "
+    "imports" = "splineKnots = "splineKnots", as.polySpline = "as.polySpline", "
+    "imports" = "interpSpline = "interpSpline", splineDesign = "splineDesign", "
+    "imports" = "asVector = "asVector", spline.des = "spline.des", backSpline = "backSpline", "
+    "imports" = "ns = "ns", xyVector = "xyVector", periodicSpline = "periodicSpline", "
+    "imports" = "splineOrder = "splineOrder", polySpline = "polySpline"), Matrix = c(".__T__qr.Q:base" = ".__T__qr.Q:base", "
+    "imports" = ".__C__indMatrix = ".__C__indMatrix", onenormest = "onenormest", "
+    "imports" = ".nC2l = ".nC2l", .__C__sparseQR = ".__C__sparseQR", ".__T__diag:base" = ".__T__diag:base", "
+    "imports" = "isDiagonal = "isDiagonal", expm = "expm", cbind2 = "cbind2", "
+    "imports" = "nnzero = "nnzero", .__C__ldenseMatrix = ".__C__ldenseMatrix", "
+    "imports" = ".__C__atomicVector = ".__C__atomicVector", expand = "expand", "
+    "imports" = "fac2Sparse = "fac2Sparse", ".__T__is.na:base" = ".__T__is.na:base", "
+    "imports" = ".__C__zMatrix = ".__C__zMatrix", zapsmall = "zapsmall", ".__T__-:base" = ".__T__-:base", "
+    "imports" = "".__T__diag<-:base" = ".__T__diag<-:base", cov2cor = "cov2cor", "
+    "imports" = "sparseMatrix = "sparseMatrix", .__C__dppMatrix = ".__C__dppMatrix", "
+    "imports" = ".__C__lgTMatrix = ".__C__lgTMatrix", .__C__CsparseMatrix = ".__C__CsparseMatrix", "
+    "imports" = "".__T__unname:base" = ".__T__unname:base", which = "which", .__C__RsparseMatrix = ".__C__RsparseMatrix", "
+    "imports" = "KhatriRao = "KhatriRao", mean = "mean", colSums = "colSums", "
+    "imports" = "".__T__colSums:base" = ".__T__colSums:base", band = "band", ".__T__format:base" = ".__T__format:base", "
+    "imports" = "".__T__head:utils" = ".__T__head:utils", .m2lgC = ".m2lgC", ".__T__as.logical:base" = ".__T__as.logical:base", "
+    "imports" = "".__T__%%:base" = ".__T__%%:base", .__C__ngRMatrix = ".__C__ngRMatrix", "
+    "imports" = "Schur = "Schur", ".__T__update:stats" = ".__T__update:stats", "
+    "imports" = ".__C__ltTMatrix = ".__C__ltTMatrix", qr.qty = "qr.qty", ".__T__summary:base" = ".__T__summary:base", "
+    "imports" = "..2dge = "..2dge", ".__T__chol2inv:base" = ".__T__chol2inv:base", "
+    "imports" = ".__C__rleDiff = ".__C__rleDiff", unname = "unname", .__C__ntpMatrix = ".__C__ntpMatrix", "
+    "imports" = "".__T__tril:Matrix" = ".__T__tril:Matrix", .dsy2dsp = ".dsy2dsp", "
+    "imports" = "rep2abI = "rep2abI", .__C__triangularMatrix = ".__C__triangularMatrix", "
+    "imports" = "qr.coef = "qr.coef", .__C__abIndex = ".__C__abIndex", .__C__pBunchKaufman = ".__C__pBunchKaufman", "
+    "imports" = ".__C__CHMsuper = ".__C__CHMsuper", Diagonal = "Diagonal", .__C__nsyMatrix = ".__C__nsyMatrix", "
+    "imports" = "qrR = "qrR", .__C__lsTMatrix = ".__C__lsTMatrix", rowSums = "rowSums", "
+    "imports" = "skewpart = "skewpart", .diag.dsC = ".diag.dsC", .__C__ngeMatrix = ".__C__ngeMatrix", "
+    "imports" = ".__C__ntRMatrix = ".__C__ntRMatrix", .__C__dpoMatrix = ".__C__dpoMatrix", "
+    "imports" = "head = "head", printSpMatrix = "printSpMatrix", ".__T__all:base" = ".__T__all:base", "
+    "imports" = "".__T__as.integer:base" = ".__T__as.integer:base", .__C__nsCMatrix = ".__C__nsCMatrix", "
+    "imports" = ".solve.dgC.qr = ".solve.dgC.qr", .__C__nspMatrix = ".__C__nspMatrix", "
+    "imports" = "".__T__qr.R:base" = ".__T__qr.R:base", .__C__zsparseVector = ".__C__zsparseVector", "
+    "imports" = ".__C__ltCMatrix = ".__C__ltCMatrix", drop = "drop", .__C__sparseVector = ".__C__sparseVector", "
+    "imports" = "".__T__qr:base" = ".__T__qr:base", rankMatrix = "rankMatrix", "
+    "imports" = "rbind2 = "rbind2", .__C__BunchKaufman = ".__C__BunchKaufman", "
+    "imports" = "rsparsematrix = "rsparsematrix", Cholesky = "Cholesky", qr.resid = "qr.resid", "
+    "imports" = ".diag2mat = ".diag2mat", .__C__nsRMatrix = ".__C__nsRMatrix", "
+    "imports" = ".__C__dgTMatrix = ".__C__dgTMatrix", .dsy2mat = ".dsy2mat", .__C__Cholesky = ".__C__Cholesky", "
+    "imports" = "tcrossprod = "tcrossprod", ".__T__qr.fitted:base" = ".__T__qr.fitted:base", "
+    "imports" = "".__T__cov2cor:stats" = ".__T__cov2cor:stats", ".__T__updown:Matrix" = ".__T__updown:Matrix", "
+    "imports" = "".__T__is.infinite:base" = ".__T__is.infinite:base", .__C__denseMatrix = ".__C__denseMatrix", "
+    "imports" = "qr.Q = "qr.Q", qr.R = "qr.R", ".__T__prod:base" = ".__T__prod:base", "
+    "imports" = "forceSymmetric = "forceSymmetric", .__C__ntrMatrix = ".__C__ntrMatrix", "
+    "imports" = ".__C__lsparseVector = ".__C__lsparseVector", Logic = "Logic", "
+    "imports" = "mat2triplet = "mat2triplet", diag = "diag", .__C__dtTMatrix = ".__C__dtTMatrix", "
+    "imports" = ".__C__lsparseMatrix = ".__C__lsparseMatrix", ".__T__nnzero:Matrix" = ".__T__nnzero:Matrix", "
+    "imports" = ".__C__xsparseVector = ".__C__xsparseVector", ".__T__expand:Matrix" = ".__T__expand:Matrix", "
+    "imports" = ".bdiag = ".bdiag", sparseVector = "sparseVector", anyDuplicatedT = "anyDuplicatedT", "
+    "imports" = "colMeans = "colMeans", T2graph = "T2graph", .__C__CHMfactor = ".__C__CHMfactor", "
+    "imports" = "chol2inv = "chol2inv", .sparseDiagonal = ".sparseDiagonal", unpack = "unpack", "
+    "imports" = ".__C__Matrix = ".__C__Matrix", ".__T__anyNA:base" = ".__T__anyNA:base", "
+    "imports" = ""diag<-" = "diag<-", .__C__corMatrix = ".__C__corMatrix", .__C__dsTMatrix = ".__C__dsTMatrix", "
+    "imports" = ".__C__lgCMatrix = ".__C__lgCMatrix", ".__T__as.vector:base" = ".__T__as.vector:base", "
+    "imports" = "".__T__rowMeans:base" = ".__T__rowMeans:base", ".__T__as.matrix:base" = ".__T__as.matrix:base", "
+    "imports" = ".__C__LU = ".__C__LU", ".__T__^:base" = ".__T__^:base", ".__T__rowSums:base" = ".__T__rowSums:base", "
+    "imports" = "".__T__as.numeric:base" = ".__T__as.numeric:base", .__C__CholeskyFactorization = ".__C__CholeskyFactorization", "
+    "imports" = "is.null.DN = "is.null.DN", norm = "norm", Arith = "Arith", .__C__dtCMatrix = ".__C__dtCMatrix", "
+    "imports" = "".__T__qr.coef:base" = ".__T__qr.coef:base", t = "t", ".__T__Cholesky:Matrix" = ".__T__Cholesky:Matrix", "
+    "imports" = "".__T__solve:base" = ".__T__solve:base", ".__T__as.array:base" = ".__T__as.array:base", "
+    "imports" = ".__C__dCHMsimpl = ".__C__dCHMsimpl", ".__T__qr.resid:base" = ".__T__qr.resid:base", "
+    "imports" = "spMatrix = "spMatrix", kronecker = "kronecker", invPerm = "invPerm", "
+    "imports" = ".__C__ddenseMatrix = ".__C__ddenseMatrix", ".__T__which:base" = ".__T__which:base", "
+    "imports" = ".__C__symmetricMatrix = ".__C__symmetricMatrix", Compare = "Compare", "
+    "imports" = "graph2T = "graph2T", ".__T__crossprod:base" = ".__T__crossprod:base", "
+    "imports" = "rcond = "rcond", .__C__nMatrix = ".__C__nMatrix", ".__T__chol:base" = ".__T__chol:base", "
+    "imports" = ".__C__nsparseVector = ".__C__nsparseVector", abIseq = "abIseq", "
+    "imports" = "as.matrix = "as.matrix", lu = "lu", ".__T__/:base" = ".__T__/:base", "
+    "imports" = "".__T__tail:utils" = ".__T__tail:utils", ".__T__mean:base" = ".__T__mean:base", "
+    "imports" = "".__T__isSymmetric:base" = ".__T__isSymmetric:base", symmpart = "symmpart", "
+    "imports" = ""%&%" = "%&%", ".__T__all.equal:base" = ".__T__all.equal:base", "
+    "imports" = ".diag2sT = ".diag2sT", bdiag = "bdiag", updown = "updown", Math2 = "Math2", "
+    "imports" = "".__T__%*%:base" = ".__T__%*%:base", .__C__Schur = ".__C__Schur", "
+    "imports" = "".__T__symmpart:Matrix" = ".__T__symmpart:Matrix", .__C__lgRMatrix = ".__C__lgRMatrix", "
+    "imports" = "condest = "condest", .dense2sy = ".dense2sy", .T2Cmat = ".T2Cmat", "
+    "imports" = "cBind = "cBind", .__C__pCholesky = ".__C__pCholesky", .validateCsparse = ".validateCsparse", "
+    "imports" = "".__T__colMeans:base" = ".__T__colMeans:base", .__C__replValue = ".__C__replValue", "
+    "imports" = "qr.fitted = "qr.fitted", printSpMatrix2 = "printSpMatrix2", format = "format", "
+    "imports" = "diagN2U = "diagN2U", ".__T__Schur:Matrix" = ".__T__Schur:Matrix", "
+    "imports" = ".__C__ltpMatrix = ".__C__ltpMatrix", tail = "tail", .__C__sparseMatrix = ".__C__sparseMatrix", "
+    "imports" = "".__T__&:base" = ".__T__&:base", ".__T__lu:Matrix" = ".__T__lu:Matrix", "
+    "imports" = "".__T__%/%:base" = ".__T__%/%:base", .diag2tT = ".diag2tT", .__C__dgCMatrix = ".__C__dgCMatrix", "
+    "imports" = "".__T__determinant:base" = ".__T__determinant:base", ".__T__facmul:Matrix" = ".__T__facmul:Matrix", "
+    "imports" = ".__C__lsyMatrix = ".__C__lsyMatrix", Matrix = "Matrix", .__C__index = ".__C__index", "
+    "imports" = ".__C__lgeMatrix = ".__C__lgeMatrix", .__C__ltRMatrix = ".__C__ltRMatrix", "
+    "imports" = "".__T__any:base" = ".__T__any:base", diff = "diff", .__C__dCHMsuper = ".__C__dCHMsuper", "
+    "imports" = "formatSpMatrix = "formatSpMatrix", .__C__lsCMatrix = ".__C__lsCMatrix", "
+    "imports" = ".__C__lspMatrix = ".__C__lspMatrix", .__C__ndenseMatrix = ".__C__ndenseMatrix", "
+    "imports" = "bandSparse = "bandSparse", .__C__lMatrix = ".__C__lMatrix", readHB = "readHB", "
+    "imports" = "coerce = "coerce", .diagU2N = ".diagU2N", Summary = "Summary", "
+    "imports" = ".asmatrix = ".asmatrix", solve = "solve", .__C__sparseLU = ".__C__sparseLU", "
+    "imports" = "isSymmetric = "isSymmetric", rowMeans = "rowMeans", .__C__lsRMatrix = ".__C__lsRMatrix", "
+    "imports" = "".__T__print:base" = ".__T__print:base", Math = "Math", ".__T__drop:base" = ".__T__drop:base", "
+    "imports" = "image = "image", drop0 = "drop0", Ops = "Ops", .__C__nCHMsimpl = ".__C__nCHMsimpl", "
+    "imports" = "c.sparseVector = "c.sparseVector", determinant = "determinant", "
+    "imports" = ".symDiagonal = ".symDiagonal", .__C__iMatrix = ".__C__iMatrix", "
+    "imports" = ".__C__ldiMatrix = ".__C__ldiMatrix", .__C__ngTMatrix = ".__C__ngTMatrix", "
+    "imports" = "".__T__qr.qy:base" = ".__T__qr.qy:base", ".__T__t:base" = ".__T__t:base", "
+    "imports" = "".__T__*:base" = ".__T__*:base", .__C__ltrMatrix = ".__C__ltrMatrix", "
+    "imports" = "sparse.model.matrix = "sparse.model.matrix", .__C__dgRMatrix = ".__C__dgRMatrix", "
+    "imports" = "".__T__triu:Matrix" = ".__T__triu:Matrix", abIseq1 = "abIseq1", "
+    "imports" = "".__T__zapsmall:base" = ".__T__zapsmall:base", ".__T__unpack:Matrix" = ".__T__unpack:Matrix", "
+    "imports" = "pack = "pack", .__C__diagonalMatrix = ".__C__diagonalMatrix", "
+    "imports" = "".__T__forceSymmetric:Matrix" = ".__T__forceSymmetric:Matrix", "
+    "imports" = "".__T__skewpart:Matrix" = ".__T__skewpart:Matrix", update = "update", "
+    "imports" = ".__C__dtpMatrix = ".__C__dtpMatrix", .__C__isparseVector = ".__C__isparseVector", "
+    "imports" = ".formatSparseSimple = ".formatSparseSimple", summary = "summary", "
+    "imports" = "uniqTsparse = "uniqTsparse", isTriangular = "isTriangular", .__C__ntTMatrix = ".__C__ntTMatrix", "
+    "imports" = "facmul = "facmul", qr = "qr", .__C__CHMsimpl = ".__C__CHMsimpl", "
+    "imports" = ".__C__MatrixFactorization = ".__C__MatrixFactorization", ".__T__BunchKaufman:Matrix" = ".__T__BunchKaufman:Matrix", "
+    "imports" = ".updateCHMfactor = ".updateCHMfactor", .__C__dsyMatrix = ".__C__dsyMatrix", "
+    "imports" = "Hilbert = "Hilbert", ".__T__!:base" = ".__T__!:base", .__C__dgeMatrix = ".__C__dgeMatrix", "
+    "imports" = ".__C__dtRMatrix = ".__C__dtRMatrix", .__C__nsparseMatrix = ".__C__nsparseMatrix", "
+    "imports" = ".solve.dgC.chol = ".solve.dgC.chol", ".__T__dim<-:base" = ".__T__dim<-:base", "
+    "imports" = "".__T__band:Matrix" = ".__T__band:Matrix", toeplitz = "toeplitz", "
+    "imports" = ".__C__dsCMatrix = ".__C__dsCMatrix", .__C__dspMatrix = ".__C__dspMatrix", "
+    "imports" = "rBind = "rBind", ".__T__diff:base" = ".__T__diff:base", nearPD = "nearPD", "
+    "imports" = "".__T__image:graphics" = ".__T__image:graphics", print = "print", "
+    "imports" = ".__C__pMatrix = ".__C__pMatrix", .__C__nsTMatrix = ".__C__nsTMatrix", "
+    "imports" = "".__T__toeplitz:stats" = ".__T__toeplitz:stats", ".__T__tcrossprod:base" = ".__T__tcrossprod:base", "
+    "imports" = ".__C__compMatrix = ".__C__compMatrix", diagU2N = "diagU2N", .__C__generalMatrix = ".__C__generalMatrix", "
+    "imports" = "tril = "tril", .SuiteSparse_version = ".SuiteSparse_version", "
+    "imports" = ".__C__dsRMatrix = ".__C__dsRMatrix", .solve.dgC.lu = ".solve.dgC.lu", "
+    "imports" = ".__C__ntCMatrix = ".__C__ntCMatrix", ".__T__log:base" = ".__T__log:base", "
+    "imports" = "show = "show", qr2rankMatrix = "qr2rankMatrix", chol = "chol", "
+    "imports" = "triu = "triu", ".__T__rep:base" = ".__T__rep:base", all.equal = "all.equal", "
+    "imports" = ".__C__number = ".__C__number", .__C__ddiMatrix = ".__C__ddiMatrix", "
+    "imports" = "".__T__sum:base" = ".__T__sum:base", ".__T__norm:base" = ".__T__norm:base", "
+    "imports" = "".__T__pack:Matrix" = ".__T__pack:Matrix", .__C__dtrMatrix = ".__C__dtrMatrix", "
+    "imports" = "fac2sparse = "fac2sparse", det = "det", ".__T__expm:Matrix" = ".__T__expm:Matrix", "
+    "imports" = "".__T__+:base" = ".__T__+:base", .m2ngC = ".m2ngC", formatSparseM = "formatSparseM", "
+    "imports" = "".__T__writeMM:Matrix" = ".__T__writeMM:Matrix", .__C__TsparseMatrix = ".__C__TsparseMatrix", "
+    "imports" = ".m2dgC = ".m2dgC", .trDiagonal = ".trDiagonal", ".__T__qr.qty:base" = ".__T__qr.qty:base", "
+    "imports" = "BunchKaufman = "BunchKaufman", readMM = "readMM", qr.qy = "qr.qy", "
+    "imports" = "".__T__is.finite:base" = ".__T__is.finite:base", .__C__denseLU = ".__C__denseLU", "
+    "imports" = ".__C__dMatrix = ".__C__dMatrix", crossprod = "crossprod", ".__T__isTriangular:Matrix" = ".__T__isTriangular:Matrix", "
+    "imports" = "".__T__rcond:base" = ".__T__rcond:base", writeMM = "writeMM", "
+    "imports" = "".__T__isDiagonal:Matrix" = ".__T__isDiagonal:Matrix", isLDL = "isLDL", "
+    "imports" = "as.array = "as.array", .__C__dsparseVector = ".__C__dsparseVector", "
+    "imports" = ".dxC2mat = ".dxC2mat", MatrixClass = "MatrixClass", ".__T__%&%:Matrix" = ".__T__%&%:Matrix", "
+    "imports" = ".C2nC = ".C2nC", .__C__dsparseMatrix = ".__C__dsparseMatrix", "
+    "imports" = ".__C__nCHMsuper = ".__C__nCHMsuper", .__C__ngCMatrix = ".__C__ngCMatrix", "
+    "imports" = ".nC2d = ".nC2d"))"
     "lazydata" = "<environment>"
-    "path" = ""/home/lamby/temp/cdt.20210914113251.VJOf4Hj4SO.repro.r-cran-sna/build-a/r-cran-sna-2.6/debian/r-cran-sna/usr/lib/R/site-library/sna""
-    "spec" = "c(name = "sna", version = "2.6")"
+    "path" = ""/home/lamby/temp/cdt.20210914135949.reGD4eUmXv.repro.r-bioc-noiseq/build-b/r-bioc-noiseq-2.36.0/debian/r-bioc-noiseq/usr/lib/R/site-library/NOISeq""
+    "spec" = "c(name = "NOISeq", version = "2.36.0")"
 }
 
 .__S3MethodsTable__. (environment) = 
 {
 }
 
-.onAttach (closure) = function (libname, pkgname) 
+.__T__dat2save:NOISeq (environment) = 
 {
-    temp <- packageDescription("sna")
-    msg <- paste(temp$Package, ": ", temp$Title, "\n", "Version ", 
-        temp$Version, " created on ", temp$Date, ".\n", sep = "")
-    msg <- paste(msg, "copyright (c) 2005, Carter T. Butts, University of California-Irvine\n", 
-        sep = "")
-    msg <- paste(msg, "For citation information, type citation(\"sna\").\n")
-    msg <- paste(msg, "Type help(package=\"sna\") to get started.\n")
-    packageStartupMessage(msg)
-}
-
-.onLoad (closure) = function (libname, pkgname) 
-{
-    library.dynam("sna", package = pkgname, lib.loc = libname)
-}
-
-.packageName (character) = "sna"
-
-add.isolates (closure) = function (dat, n, return.as.edgelist = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, add.isolates, n = n, return.as.edgelist = return.as.edgelist))
-    attr(dat, "n") <- attr(dat, "n") + n
-    if (return.as.edgelist) 
-        dat
-    else as.sociomatrix(dat)
-}
-
-as.edgelist.sna (closure) = function (x, attrname = NULL, as.digraph = TRUE, suppress.diag = FALSE, 
-    force.bipartite = FALSE, ...) 
-{
-    if ((is.list(x) && !inherits(x, "network")) && (!inherits(x, 
-        c("network", "matrix.csr", "matrix.csc", "matrix.ssr", 
-            "matrix.ssc", "matrix.hb", "data.frame")))) {
-        return(lapply(x, as.edgelist.sna, attrname = attrname, 
-            as.digraph = as.digraph, suppress.diag = suppress.diag, 
-            force.bipartite = force.bipartite))
-    }
-    if (inherits(x, "network")) {
-        out <- as.matrix.network.edgelist(x, attrname = attrname, 
-            as.sna.edgelist = TRUE)
-        if (!("as.sna.edgelist" %in% names(formals(as.matrix.network.edgelist)))) {
-            if (NCOL(out) == 2) 
-                out <- cbind(out, rep(1, NROW(out)))
-            if (suppress.diag && has.loops(x)) 
-                out <- out[!(out[, 1] == out[, 2]), ]
-            if ((!is.directed(x)) && as.digraph) {
-                if (has.loops(x)) {
-                  temp <- out[, 1] == out[, 2]
-                  if (any(temp)) {
-                    temp2 <- out[temp, ]
-                    out <- out[!temp, ]
-                    out <- rbind(out, out[, c(2, 1, 3)])
-                    out <- rbind(out, temp2)
-                  }
-                  else out <- rbind(out, out[, c(2, 1, 3)])
-                }
-                else out <- rbind(out, out[, c(2, 1, 3)])
-            }
-            attr(out, "n") <- network.size(x)
-            attr(out, "vnames") <- network.vertex.names(x)
-        }
-        if (is.bipartite(x)) 
-            attr(out, "bipartite") <- get.network.attribute(x, 
-                "bipartite")
-        else if (force.bipartite) 
-            out <- as.edgelist.sna(out, attrname = attrname, 
-                as.digraph = as.digraph, suppress.diag = suppress.diag, 
-                force.bipartite = force.bipartite)
-    }
-    else if (inherits(x, c("matrix.csr", "matrix.csc", "matrix.ssr", 
-        "matrix.ssc", "matrix.hb"))) {
-        requireNamespace("SparseM")
-        if (force.bipartite || (!is.null(attr(x, "bipartite"))) || 
-            (x@dimension[1] != x@dimension[2])) {
-            nr <- x@dimension[1]
-            nc <- x@dimension[2]
-            val <- x@ra
-            if ((!suppress.diag) && inherits(x, c("matrix.ssr", 
-                "matrix.ssc"))) {
-                snd <- rep(1:nr, each = diff(x@ia))
-                rec <- nr + x@ja
-                out <- cbind(snd, rec, val)
-                out <- rbind(out, out[, c(2, 1, 3)])
-            }
-            else {
-                snd <- switch(class(x)[1], matrix.csr = rep(1:nr, 
-                  each = diff(x@ia)), matrix.csc = x@ja, matrix.ssr = c(rep(1:nr, 
-                  each = diff(x@ia)), x@ja), matrix.ssc = c(x@ja, 
-                  rep(1:nr, each = diff(x@ia))))
-                rec <- switch(class(x)[1], matrix.csr = nr + 
-                  x@ja, matrix.csc = rep(nr + (1:nc), each = diff(x@ia)), 
-                  matrix.ssr = c(nr + x@ja, rep(1:n, each = diff(x@ia))), 
-                  matrix.ssc = c(rep(nr + (1:nc), each = diff(x@ia)), 
-                    x@ja))
-                out <- cbind(snd, rec, val)
-                out <- rbind(out, out[, c(2, 1, 3)])
-            }
-            attr(out, "n") <- nr + nc
-            attr(out, "vnames") <- NULL
-            attr(out, "bipartite") <- nr
-        }
-        else {
-            n <- x@dimension[1]
-            val <- x@ra
-            if ((!suppress.diag) && inherits(x, c("matrix.ssr", 
-                "matrix.ssc"))) {
-                snd <- rep(1:n, times = diff(x@ia))
-                rec <- x@ja
-                temp <- snd == rec
-                out <- cbind(snd, rec, val)
-                temp2 <- out[temp, ]
-                out <- out[!temp, ]
-                out <- rbind(out, out[, c(2, 1, 3)])
-                out <- rbind(out, temp2)
+    "Biodetection" = "new("MethodDefinition", .Data = function (object) "
+    "Biodetection" = "object@dat, target = new("signature", .Data = "Biodetection", "
+    "Biodetection" = "    names = "object", package = "NOISeq"), defined = new("signature", "
+    "Biodetection" = "    .Data = "Biodetection", names = "object", package = "NOISeq"), "
+    "Biodetection" = "    generic = structure("dat2save", package = "NOISeq"))"
+    "CD" = "new("MethodDefinition", .Data = function (object) "
+    "CD" = "object@dat, target = new("signature", .Data = "CD", names = "object", "
+    "CD" = "    package = "NOISeq"), defined = new("signature", .Data = "CD", "
+    "CD" = "    names = "object", package = "NOISeq"), generic = structure("dat2save", package = "NOISeq"))"
+    "CountsBio" = "new("MethodDefinition", .Data = function (object) "
+    "CountsBio" = "object@dat$summary, target = new("signature", .Data = "CountsBio", "
+    "CountsBio" = "    names = "object", package = "NOISeq"), defined = new("signature", "
+    "CountsBio" = "    .Data = "CountsBio", names = "object", package = "NOISeq"), "
+    "CountsBio" = "    generic = structure("dat2save", package = "NOISeq"))"
+    "GCbias" = "new("MethodDefinition", .Data = function (object) "
+    "GCbias" = "object@dat$data2plot, target = new("signature", .Data = "GCbias", "
+    "GCbias" = "    names = "object", package = "NOISeq"), defined = new("signature", "
+    "GCbias" = "    .Data = "GCbias", names = "object", package = "NOISeq"), "
+    "GCbias" = "    generic = structure("dat2save", package = "NOISeq"))"
+    "PCA" = "new("MethodDefinition", .Data = function (object) "
+    "PCA" = "object@dat$result, target = new("signature", .Data = "PCA", names = "object", "
+    "PCA" = "    package = "NOISeq"), defined = new("signature", .Data = "PCA", "
+    "PCA" = "    names = "object", package = "NOISeq"), generic = structure("dat2save", package = "NOISeq"))"
+    "Saturation" = "new("MethodDefinition", .Data = function (object) "
+    "Saturation" = "{"
+    "Saturation" = "    muestras = vector("list", length = length(object@dat$depth))"
+    "Saturation" = "    names(muestras) = names(object@dat$depth)"
+    "Saturation" = "    for (i in 1:length(muestras)) {"
+    "Saturation" = "        muestras[[i]] = object@dat$depth[[i]]"
+    "Saturation" = "        for (j in 1:length(object@dat$saturation)) {"
+    "Saturation" = "            muestras[[i]] = cbind(muestras[[i]], object@dat$saturation[[j]][[i]])"
+    "Saturation" = "        }"
+    "Saturation" = "        colnames(muestras[[i]]) <- c("depth", names(object@dat$saturation))"
+    "Saturation" = "    }"
+    "Saturation" = "    muestras"
+    "Saturation" = "}, target = new("signature", .Data = "Saturation", names = "object", "
+    "Saturation" = "    package = "NOISeq"), defined = new("signature", .Data = "Saturation", "
+    "Saturation" = "    names = "object", package = "NOISeq"), generic = structure("dat2save", package = "NOISeq"))"
+    "lengthbias" = "new("MethodDefinition", .Data = function (object) "
+    "lengthbias" = "object@dat$data2plot, target = new("signature", .Data = "lengthbias", "
+    "lengthbias" = "    names = "object", package = "NOISeq"), defined = new("signature", "
+    "lengthbias" = "    .Data = "lengthbias", names = "object", package = "NOISeq"), "
+    "lengthbias" = "    generic = structure("dat2save", package = "NOISeq"))"
+}
+
+.__T__explo.plot:NOISeq (environment) = 
+{
+    "Biodetection" = "new("MethodDefinition", .Data = function (object, ...) "
+    "Biodetection" = "{"
+    "Biodetection" = "    .local <- function (object, samples = c(1, 2), plottype = c("persample", "
+    "Biodetection" = "        "comparison"), toplot = "protein_coding", ...) "
+    "Biodetection" = "    biodetection.plot(object@dat, samples = samples, plottype = plottype, "
+    "Biodetection" = "        toplot = toplot, ...)"
+    "Biodetection" = "    .local(object, ...)"
+    "Biodetection" = "}, target = new("signature", .Data = "Biodetection", names = "object", "
+    "Biodetection" = "    package = "NOISeq"), defined = new("signature", .Data = "Biodetection", "
+    "Biodetection" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "CD" = "new("MethodDefinition", .Data = function (object, ...) "
+    "CD" = "{"
+    "CD" = "    .local <- function (object, samples = NULL, ...) "
+    "CD" = "    cd.plot(object@dat, samples = samples, ...)"
+    "CD" = "    .local(object, ...)"
+    "CD" = "}, target = new("signature", .Data = "CD", names = "object", "
+    "CD" = "    package = "NOISeq"), defined = new("signature", .Data = "CD", "
+    "CD" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "CountsBio" = "new("MethodDefinition", .Data = function (object, ...) "
+    "CountsBio" = "{"
+    "CountsBio" = "    .local <- function (object, samples = c(1, 2), toplot = "global", "
+    "CountsBio" = "        plottype = c("barplot", "boxplot"), ...) "
+    "CountsBio" = "    countsbio.plot(object@dat, samples, toplot, plottype, ...)"
+    "CountsBio" = "    .local(object, ...)"
+    "CountsBio" = "}, target = new("signature", .Data = "CountsBio", names = "object", "
+    "CountsBio" = "    package = "NOISeq"), defined = new("signature", .Data = "CountsBio", "
+    "CountsBio" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "GCbias" = "new("MethodDefinition", .Data = function (object, ...) "
+    "GCbias" = "{"
+    "GCbias" = "    .local <- function (object, samples = NULL, toplot = "global", "
+    "GCbias" = "        ...) "
+    "GCbias" = "    GC.plot(object@dat, samples = samples, toplot = toplot, ...)"
+    "GCbias" = "    .local(object, ...)"
+    "GCbias" = "}, target = new("signature", .Data = "GCbias", names = "object", "
+    "GCbias" = "    package = "NOISeq"), defined = new("signature", .Data = "GCbias", "
+    "GCbias" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "PCA" = "new("MethodDefinition", .Data = function (object, ...) "
+    "PCA" = "{"
+    "PCA" = "    .local <- function (object, samples = 1:2, plottype = "scores", "
+    "PCA" = "        factor = NULL) "
+    "PCA" = "    PCA.plot(object@dat, samples = samples, plottype = plottype, "
+    "PCA" = "        factor = factor)"
+    "PCA" = "    .local(object, ...)"
+    "PCA" = "}, target = new("signature", .Data = "PCA", names = "object", "
+    "PCA" = "    package = "NOISeq"), defined = new("signature", .Data = "PCA", "
+    "PCA" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "Saturation" = "new("MethodDefinition", .Data = function (object, ...) "
+    "Saturation" = "{"
+    "Saturation" = "    .local <- function (object, samples = NULL, toplot = 1, yleftlim = NULL, "
+    "Saturation" = "        yrightlim = NULL, ...) "
+    "Saturation" = "    saturation.plot(object@dat, samples = samples, toplot = toplot, "
+    "Saturation" = "        yleftlim = yleftlim, yrightlim = yrightlim, ...)"
+    "Saturation" = "    .local(object, ...)"
+    "Saturation" = "}, target = new("signature", .Data = "Saturation", names = "object", "
+    "Saturation" = "    package = "NOISeq"), defined = new("signature", .Data = "Saturation", "
+    "Saturation" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+    "lengthbias" = "new("MethodDefinition", .Data = function (object, ...) "
+    "lengthbias" = "{"
+    "lengthbias" = "    .local <- function (object, samples = NULL, toplot = "global", "
+    "lengthbias" = "        ...) "
+    "lengthbias" = "    length.plot(object@dat, samples = samples, toplot = toplot, "
+    "lengthbias" = "        ...)"
+    "lengthbias" = "    .local(object, ...)"
+    "lengthbias" = "}, target = new("signature", .Data = "lengthbias", names = "object", "
+    "lengthbias" = "    package = "NOISeq"), defined = new("signature", .Data = "lengthbias", "
+    "lengthbias" = "    names = "object", package = "NOISeq"), generic = structure("explo.plot", package = "NOISeq"))"
+}
+
+.__T__show:methods (environment) = 
+{
+    "Biodetection" = "new("MethodDefinition", .Data = function (object) "
+    "Biodetection" = "{"
+    "Biodetection" = "    cat("\n Reference genome: \n==========\n")"
+    "Biodetection" = "    names(dimnames(object@dat$genome)) = NULL"
+    "Biodetection" = "    print(object@dat$genome)"
+    "Biodetection" = "    for (i in c(1:length(object@dat$biotables))) {"
+    "Biodetection" = "        cat("\n", names(object@dat$biotables)[i], "\n==========\n")"
+    "Biodetection" = "        print(object@dat$biotables[[i]])"
+    "Biodetection" = "    }"
+    "Biodetection" = "}, target = new("signature", .Data = "Biodetection", names = "object", "
+    "Biodetection" = "    package = "NOISeq"), defined = new("signature", .Data = "Biodetection", "
+    "Biodetection" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "CD" = "new("MethodDefinition", .Data = function (object) "
+    "CD" = "{"
+    "CD" = "    cat("\n Confidence intervals for median of M to compare each sample to reference:\n=======\n")"
+    "CD" = "    print(object@dat$DiagnosticTest)"
+    "CD" = "    cat("\n Reference sample is:\n=======\n")"
+    "CD" = "    print(object@dat$refColumn)"
+    "CD" = "}, target = new("signature", .Data = "CD", names = "object", "
+    "CD" = "    package = "NOISeq"), defined = new("signature", .Data = "CD", "
+    "CD" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "CountsBio" = "new("MethodDefinition", .Data = function (object) "
+    "CountsBio" = "{"
+    "CountsBio" = "    cat("\n Summary: \n============\n")"
+    "CountsBio" = "    print(object@dat$summary[[1]])"
+    "CountsBio" = "}, target = new("signature", .Data = "CountsBio", names = "object", "
+    "CountsBio" = "    package = "NOISeq"), defined = new("signature", .Data = "CountsBio", "
+    "CountsBio" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "GCbias" = "new("MethodDefinition", .Data = function (object) "
+    "GCbias" = "{"
+    "GCbias" = "    x <- object@dat$RegressionModels"
+    "GCbias" = "    for (i in 1:length(x)) {"
+    "GCbias" = "        print(names(x)[i])"
+    "GCbias" = "        print(summary(x[[i]]))"
+    "GCbias" = "    }"
+    "GCbias" = "}, target = new("signature", .Data = "GCbias", names = "object", "
+    "GCbias" = "    package = "NOISeq"), defined = new("signature", .Data = "GCbias", "
+    "GCbias" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "Output" = "new("MethodDefinition", .Data = function (object) "
+    "Output" = "{"
+    "Output" = "    if (object@method == "n") "
+    "Output" = "        object@method = "none""
+    "Output" = "    for (i in 1:length(object@results)) {"
+    "Output" = "        cat("\nSummary", i, "\n=========\n")"
+    "Output" = "        cat("\nYou are comparing", object@comparison[i], "from", "
+    "Output" = "            object@factor[i], "\n\n")"
+    "Output" = "        print(head(object@results[[i]][order(object@results[[i]][, "
+    "Output" = "            5], decreasing = TRUE), ]))"
+    "Output" = "    }"
+    "Output" = "    cat("\nNormalization\n")"
+    "Output" = "    cat("\tmethod:", object@method, "\n")"
+    "Output" = "    cat("\tk:", object@k, "\n")"
+    "Output" = "    cat("\tlc:", object@lc, "\n")"
+    "Output" = "    if (object@replicates == "no") {"
+    "Output" = "        cat("\nYou are working with simulated replicates:\n")"
+    "Output" = "        cat("\tpnr:", object@pnr, "\n")"
+    "Output" = "        cat("\tnss:", object@nss, "\n")"
+    "Output" = "        cat("\tv:", object@v, "\n")"
+    "Output" = "    }"
+    "Output" = "    else {"
+    "Output" = "        cat("\nYou are working with", object@replicates, "replicates\n")"
+    "Output" = "    }"
+    "Output" = "}, target = new("signature", .Data = "Output", names = "object", "
+    "Output" = "    package = "NOISeq"), defined = new("signature", .Data = "Output", "
+    "Output" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "PCA" = "new("MethodDefinition", .Data = function (object) "
+    "PCA" = "{"
+    "PCA" = "    x <- object$result$var.exp"
+    "PCA" = "    x = round(x * 100, 4)"
+    "PCA" = "    colnames(x) = c("%Var", "Cum %Var")"
+    "PCA" = "    rownames(x) = paste("PC", 1:nrow(x))"
+    "PCA" = "    cat("\n Percentage of total variance explained by each component: \n============\n")"
+    "PCA" = "    print(x)"
+    "PCA" = "}, target = new("signature", .Data = "PCA", names = "object", "
+    "PCA" = "    package = "NOISeq"), defined = new("signature", .Data = "PCA", "
+    "PCA" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "Saturation" = "new("MethodDefinition", .Data = function (object) "
+    "Saturation" = "{"
+    "Saturation" = "    x <- dat2save(object)"
+    "Saturation" = "    cat("\n Number of detected features at each sequencing depth: \n============\n")"
+    "Saturation" = "    for (i in 1:length(x)) {"
+    "Saturation" = "        print(names(x)[i])"
+    "Saturation" = "        print(x[[i]])"
+    "Saturation" = "    }"
+    "Saturation" = "}, target = new("signature", .Data = "Saturation", names = "object", "
+    "Saturation" = "    package = "NOISeq"), defined = new("signature", .Data = "Saturation", "
+    "Saturation" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+    "lengthbias" = "new("MethodDefinition", .Data = function (object) "
+    "lengthbias" = "{"
+    "lengthbias" = "    x <- object@dat$RegressionModels"
+    "lengthbias" = "    for (i in 1:length(x)) {"
+    "lengthbias" = "        print(names(x)[i])"
+    "lengthbias" = "        print(summary(x[[i]]))"
+    "lengthbias" = "    }"
+    "lengthbias" = "}, target = new("signature", .Data = "lengthbias", names = "object", "
+    "lengthbias" = "    package = "NOISeq"), defined = new("signature", .Data = "lengthbias", "
+    "lengthbias" = "    names = "object", package = "NOISeq"), generic = structure("show", package = "methods"))"
+}
+
+.calcFactorQuantile (closure) = function (data, lib.size, q = 0.75) 
+{
+    y <- t(t(data)/lib.size)
+    f <- apply(y, 2, function(x) quantile(x, p = q))
+    f/exp(mean(log(f)))
+}
+
+.calcFactorWeighted (closure) = function (obs, ref, logratioTrim = 0.3, sumTrim = 0.05, doWeighting = TRUE, 
+    Acutoff = -1e+10) 
+{
+    if (all(obs == ref)) 
+        return(1)
+    obs <- as.numeric(obs)
+    ref <- as.numeric(ref)
+    nO <- sum(obs)
+    nR <- sum(ref)
+    logR <- log2((obs/nO)/(ref/nR))
+    absE <- (log2(obs/nO) + log2(ref/nR))/2
+    v <- (nO - obs)/nO/obs + (nR - ref)/nR/ref
+    fin <- is.finite(logR) & is.finite(absE) & (absE > Acutoff)
+    logR <- logR[fin]
+    absE <- absE[fin]
+    v <- v[fin]
+    n <- sum(fin)
+    loL <- floor(n * logratioTrim) + 1
+    hiL <- n + 1 - loL
+    loS <- floor(n * sumTrim) + 1
+    hiS <- n + 1 - loS
+    keep <- (rank(logR) >= loL & rank(logR) <= hiL) & (rank(absE) >= 
+        loS & rank(absE) <= hiS)
+    if (doWeighting) 
+        2^(sum(logR[keep]/v[keep], na.rm = TRUE)/sum(1/v[keep], 
+            na.rm = TRUE))
+    else 2^(mean(logR[keep], na.rm = TRUE))
+}
+
+.calcNormFactors (closure) = function (object, method = c("TMM", "quantile"), refColumn = NULL, 
+    logratioTrim = 0.3, sumTrim = 0.05, doWeighting = TRUE, Acutoff = -1e+10, 
+    quantile = 0.75) 
+{
+    method <- match.arg(method)
+    if (is.matrix(object)) {
+        if (is.null(refColumn)) 
+            refColumn <- 1
+        data <- object
+        libsize <- colSums(data)
+    }
+    else {
+        stop("calcNormFactors() only operates on 'matrix' objects")
+    }
+    f <- switch(method, TMM = apply(data, 2, .calcFactorWeighted, 
+        ref = data[, refColumn], logratioTrim = logratioTrim, 
+        sumTrim = sumTrim, doWeighting = doWeighting, Acutoff = Acutoff), 
+        quantile = .calcFactorQuantile(data, libsize, q = quantile))
+    f <- f/exp(mean(log(f)))
+    return(f)
+}
+
+.packageName (character) = "NOISeq"
+
+ARSyNcomponents (closure) = function (asca = asca, Variability = 0.75, beta = 2) 
+{
+    MODEL <- asca[-length(asca)]
+    M <- length(MODEL) - 1
+    output <- NULL
+    if (Variability == "average") {
+        for (i in 1:M) {
+            lim <- 1/rankMatrix(MODEL[[i]]$X)[1]
+            t <- table(MODEL[[i]]$var.exp[, 1] > lim)
+            if (length(t) == 1) {
+                t[2] = 0
+            }
+            t <- t[2]
+            names(t) <- names(MODEL)[i]
+            output <- c(output, t)
+        }
+    }
+    if (Variability != "average") {
+        lim <- Variability
+        for (i in 1:M) {
+            t <- which(MODEL[[i]]$var.exp[, 2] > lim)[1]
+            names(t) <- names(MODEL)[i]
+            output <- c(output, t)
+        }
+    }
+    i = M + 1
+    lim <- beta * 1/rankMatrix(MODEL[[i]]$X)[1]
+    t <- table(MODEL[[i]]$var.exp[, 1] > lim)
+    if (length(t) == 1) {
+        t[2] = 0
+    }
+    t <- t[2]
+    names(t) <- names(MODEL)[i]
+    output <- c(output, t)
+    output
+}
+
+ARSyNmodel (closure) = function (X = X, Factors = 2, Designa = Designa, Designb = Designb, 
+    Designc = Designc, Variability = "average", Join = TRUE, 
+    Interaction = TRUE, beta = 2) 
+{
+    if (Factors == 1) {
+        Fac0 <- c(1, 2)
+        names(Fac0) <- c("Model.a", "Model.res")
+        asca0 <- ASCA.1f(X = X, Designa = Designa, Fac = Fac0)
+        Fac <- ARSyNcomponents(asca0, Variability = Variability, 
+            beta = beta)
+        for (i in 1:length(Fac)) {
+            Fac0[names(Fac[i])] <- Fac[names(Fac[i])]
+        }
+        asca <- ASCA.1f(X = X, Designa = Designa, Fac = Fac0)
+    }
+    if (Factors == 2) {
+        Fac0 <- c(1, 2, 2, 2)
+        names(Fac0) <- c("Model.a", "Model.b", "Model.ab", "Model.res")
+        if (Join[1]) {
+            names(Fac0)[3] <- c("Model.bab")
+        }
+        asca0 <- ASCA.2f(X = X, Designa = Designa, Designb = Designb, 
+            Fac = Fac0, Join = Join, Interaction = Interaction)
+        Fac <- ARSyNcomponents(asca0, Variability = Variability, 
+            beta = beta)
+        for (i in 1:length(Fac)) {
+            Fac0[names(Fac[i])] <- Fac[names(Fac[i])]
+        }
+        asca <- ASCA.2f(X = X, Designa = Designa, Designb = Designb, 
+            Fac = Fac0, Join = Join, Interaction = Interaction)
+    }
+    if (Factors == 3) {
+        Fac0 = c(0, 2, 2, 2, 2, 2, 2, 2)
+        names(Fac0) <- c("Model.a", "Model.b", "Model.c", "Model.ab", 
+            "Model.ac", "Model.bc", "Model.abc", "Model.res")
+        if (Join[1]) {
+            names(Fac0)[4] <- c("Model.bab")
+        }
+        if (Join[2]) {
+            names(Fac0)[5] <- c("Model.cac")
+        }
+        asca0 <- ASCA.3f(X = X, Designa = Designa, Designb = Designb, 
+            Designc = Designc, Fac = Fac0, Join = Join, Interaction = Interaction)
+        Fac <- ARSyNcomponents(asca0, Variability = Variability, 
+            beta = beta)
+        for (i in 1:length(Fac)) {
+            Fac0[names(Fac[i])] <- Fac[names(Fac[i])]
+        }
+        asca <- ASCA.3f(X = X, Designa = Designa, Designb = Designb, 
+            Designc = Designc, Fac = Fac0, Join = Join, Interaction = Interaction)
+    }
+    Input <- asca$Input
+    asca$Input <- c(Input, Factors)
+    names(asca$Input) <- c(names(Input), "Factors")
+    output <- asca
+    output
+}
+
+ARSyNseq (closure) = function (data, factor = NULL, batch = FALSE, norm = "rpkm", 
+    logtransf = FALSE, Variability = 0.75, beta = 2) 
+{
+    Join = TRUE
+    Interaction = TRUE
+    dat <- as.matrix(assayData(data)$exprs)
+    long <- featureData(data)@data[rownames(dat), "Length"]
+    if (is.null(long)) 
+        long = 1000
+    if (norm == "rpkm") {
+        dat <- rpkm(dat, long = long, k = 0, lc = 1)
+    }
+    if (norm == "uqua") {
+        dat <- uqua(dat, long = long, lc = 1, k = 0)
+    }
+    if (norm == "tmm") {
+        dat <- tmm(dat, long = long, lc = 1, k = 0)
+    }
+    if (!logtransf) 
+        dat <- log(dat + 1)
+    X <- t(dat)
+    if (is.null(factor)) {
+        Covariates <- t(pData(data))
+        Num.factors <- nrow(Covariates)
+        labels.factors <- rownames(Covariates)
+        Design <- list(NULL, NULL, NULL)
+        for (i in 1:Num.factors) {
+            x <- as.character(Covariates[i, ])
+            Design[[i]] <- make.ASCA.design(x)
+        }
+    }
+    else {
+        Covariates <- pData(data)[, factor]
+        Num.factors <- 1
+        labels.factors <- factor
+        Design <- list(NULL, NULL, NULL)
+        x <- as.character(Covariates)
+        Design[[1]] <- make.ASCA.design(x)
+    }
+    my.asca <- ARSyNmodel(Factors = Num.factors, X = X, Designa = Design[[1]], 
+        Designb = Design[[2]], Designc = Design[[3]], Join = Join, 
+        Interaction = Interaction, Variability = Variability, 
+        beta = beta)
+    X.filtered <- X
+    M <- length(my.asca) - 1
+    if (!batch) {
+        X.filtered <- X.filtered - my.asca[[M]]$TP
+    }
+    if (batch) {
+        X.filtered <- X.filtered - my.asca[[1]]$TP
+    }
+    data.filtered <- t(X.filtered)
+    if (!logtransf) 
+        data.filtered <- exp(data.filtered) + 1
+    exprs(data) = data.filtered
+    return(data)
+}
+
+ASCA.1f (closure) = function (X = X, Designa = Designa, Designb = NULL, Designc = NULL, 
+    Fac = c(1, 2), Join = NULL, Interaction = NULL) 
+{
+    n <- ncol(X)
+    p <- nrow(X)
+    I <- ncol(Designa)
+    Faca = Fac[1]
+    Facres = Fac[2]
+    offset <- apply(X, 2, mean)
+    Xoff <- X - (cbind(matrix(1, nrow = p, ncol = 1)) %*% rbind(offset))
+    Model.a <- ASCAfun1(Xoff, Designa, Faca)
+    Xres <- Xoff - Model.a$X
+    models <- ls(pattern = "Model")
+    output <- vector(mode = "list")
+    Xres <- Xoff
+    for (i in 1:length(models)) {
+        mymodel <- get(models[i], envir = environment())
+        output <- c(output, list(mymodel))
+        Xres <- Xres - mymodel$X
+        rm(mymodel)
+        gc()
+    }
+    names(output) <- models
+    Model.res <- ASCAfun.res(Xres, Facres)
+    Model.res <- list(Model.res)
+    names(Model.res) <- c("Model.res")
+    output <- c(output, Model.res)
+    Input <- list(X, Designa, Designb, Designc, Fac, Join, Interaction)
+    names(Input) <- c("X", "Designa", "Designb", "Designc", "Fac", 
+        "Join", "Interaction")
+    Input <- list(Input)
+    names(Input) <- "Input"
+    output <- c(output, Input)
+    output
+}
+
+ASCA.2f (closure) = function (X = X, Designa = Designa, Designb = Designb, Designc = NULL, 
+    Fac = c(1, 2, 2, 2), Join = TRUE, Interaction = TRUE) 
+{
+    n <- ncol(X)
+    p <- nrow(X)
+    I <- ncol(Designa)
+    J <- ncol(Designb)
+    Faca = Fac[1]
+    Facb = Fac[2]
+    Facab = Fac[3]
+    Facres = Fac[4]
+    offset <- apply(X, 2, mean)
+    Xoff <- X - (cbind(matrix(1, nrow = p, ncol = 1)) %*% rbind(offset))
+    Model.a <- ASCAfun1(Xoff, Designa, Faca)
+    Xres <- Xoff - Model.a$X
+    if (!Join) {
+        Model.b <- ASCAfun1(Xoff, Designb, Facb)
+        if (Interaction) {
+            Model.ab <- ASCAfun2(Xoff, Designa, Designb, Facab)
+        }
+    }
+    if (Join) {
+        Model.bab <- ASCAfun12(Xoff, Designa, Designb, Facab)
+    }
+    models <- ls(pattern = "Model")
+    output <- vector(mode = "list")
+    Xres <- Xoff
+    for (i in 1:length(models)) {
+        mymodel <- get(models[i], envir = environment())
+        output <- c(output, list(mymodel))
+        Xres <- Xres - mymodel$X
+        rm(mymodel)
+        gc()
+    }
+    names(output) <- models
+    Model.res <- ASCAfun.res(Xres, Facres)
+    Model.res <- list(Model.res)
+    names(Model.res) <- c("Model.res")
+    output <- c(output, Model.res)
+    Input <- list(X, Designa, Designb, Designc, Fac, Join, Interaction, 
+        Xoff)
+    names(Input) <- c("X", "Designa", "Designb", "Designc", "Fac", 
+        "Join", "Interaction", "Xoff")
+    Input <- list(Input)
+    names(Input) <- "Input"
+    output <- c(output, Input)
+    output
+}
+
+ASCA.3f (closure) = function (X = X, Designa = Designa, Designb = Designb, Designc = Designc, 
+    Fac = c(1, 2, 2, 2, 2, 2, 2, 2), Join = c(TRUE, TRUE), Interaction = c(TRUE, 
+        TRUE, TRUE, TRUE)) 
+{
+    n <- ncol(X)
+    p <- nrow(X)
+    I <- ncol(Designa)
+    J <- ncol(Designb)
+    K <- ncol(Designc)
+    Faca = Fac[1]
+    Facb = Fac[2]
+    Facc = Fac[3]
+    Facab = Fac[4]
+    Facac = Fac[5]
+    Facbc = Fac[6]
+    Facabc = Fac[7]
+    Facres = Fac[8]
+    offset <- apply(X, 2, mean)
+    Xoff <- X - (cbind(matrix(1, nrow = p, ncol = 1)) %*% rbind(offset))
+    Model.a <- ASCAfun1(Xoff, Designa, Faca)
+    Xres <- Xoff - Model.a$X
+    if (!Join[1]) {
+        Model.b <- ASCAfun1(Xoff, Designb, Facb)
+        if (Interaction[1]) {
+            Model.ab <- ASCAfun2(Xoff, Designa, Designb, Facab)
+        }
+    }
+    if (Join[1]) {
+        Model.bab <- ASCAfun12(Xoff, Designa, Designb, Facab)
+    }
+    if (!Join[2]) {
+        Model.c <- ASCAfun1(Xoff, Designc, Facc)
+        if (Interaction[2]) {
+            Model.ac <- ASCAfun2(Xoff, Designa, Designc, Facac)
+        }
+    }
+    if (Join[2]) {
+        Model.cac <- ASCAfun12(Xoff, Designa, Designc, Facac)
+    }
+    if (Interaction[3]) {
+        Model.bc <- ASCAfun2(Xoff, Designb, Designc, Facbc)
+    }
+    if (Interaction[4]) {
+        Model.abc <- ASCAfun.triple(Xoff, Designa, Designb, Designc, 
+            Facabc)
+    }
+    models <- ls(pattern = "Model")
+    output <- vector(mode = "list")
+    Xres <- Xoff
+    for (i in 1:length(models)) {
+        mymodel <- get(models[i], envir = environment())
+        output <- c(output, list(mymodel))
+        Xres <- Xres - mymodel$X
+        rm(mymodel)
+        gc()
+    }
+    names(output) <- models
+    Model.res <- ASCAfun.res(Xres, Facres)
+    Model.res <- list(Model.res)
+    names(Model.res) <- c("Model.res")
+    output <- c(output, Model.res)
+    Input <- list(X, Designa, Designb, Designc, Fac, Join, Interaction, 
+        Xoff)
+    names(Input) <- c("X", "Designa", "Designb", "Designc", "Fac", 
+        "Join", "Interaction", "Xoff")
+    Input <- list(Input)
+    names(Input) <- "Input"
+    output <- c(output, Input)
+    output
+}
+
+ASCAfun.res (closure) = function (X, Fac) 
+{
+    PCA <- PCA.GENES(X)
+    sc <- PCA$scores[, 1:Fac]
+    ld <- PCA$loadings[, 1:Fac]
+    ssq <- PCA$var.exp
+    if (Fac == 1) {
+        sc <- as.matrix(sc)
+        ld <- as.matrix(ld)
+    }
+    TPres <- sc %*% t(ld)
+    if (Fac == 0) {
+        sc = 0
+        ld = 0
+        TPres <- matrix(0, nrow(X), ncol(X))
+    }
+    Eres <- X - TPres
+    output <- list(sc, ld, ssq, X, TPres, Eres)
+    names(output) <- c("scores", "loadings", "var.exp", "X", 
+        "TP", "E")
+    output
+}
+
+ASCAfun.triple (closure) = function (X, Desa, Desb, Desc, Fac) 
+{
+    n <- ncol(X)
+    I <- ncol(Desa)
+    J <- ncol(Desb)
+    H <- ncol(Desc)
+    XK1 <- matrix(NA, nrow = I, ncol = n)
+    for (i in 1:I) {
+        sub <- X[Desa[, i] == 1, ]
+        XK1[i, ] <- apply(sub, 2, mean)
+    }
+    XK2 <- matrix(NA, nrow = J, ncol = n)
+    for (j in 1:J) {
+        sub <- X[Desb[, j] == 1, ]
+        XK2[j, ] <- apply(sub, 2, mean)
+    }
+    XK3 <- matrix(NA, nrow = H, ncol = n)
+    for (h in 1:H) {
+        sub <- X[Desc[, h] == 1, ]
+        XK3[h, ] <- apply(sub, 2, mean)
+    }
+    XK12 <- matrix(NA, nrow = I * J, ncol = n)
+    k = 1
+    for (j in 1:J) {
+        for (i in 1:I) {
+            sub <- X[(Desa[, i] + Desb[, j]) == 2, ]
+            XK12[k, ] <- apply(sub, 2, mean)
+            k = k + 1
+        }
+    }
+    XK13 <- matrix(NA, nrow = I * H, ncol = n)
+    k = 1
+    for (h in 1:H) {
+        for (i in 1:I) {
+            sub <- X[(Desa[, i] + Desc[, h]) == 2, ]
+            XK13[k, ] <- apply(sub, 2, mean)
+            k = k + 1
+        }
+    }
+    XK23 <- matrix(NA, nrow = J * H, ncol = n)
+    k = 1
+    for (h in 1:H) {
+        for (j in 1:J) {
+            sub <- X[(Desb[, j] + Desc[, h]) == 2, ]
+            XK23[k, ] <- apply(sub, 2, mean)
+            k = k + 1
+        }
+    }
+    NK <- matrix(NA, nrow = I, ncol = J * H)
+    XK <- matrix(NA, nrow = I * J * H, ncol = n)
+    k = 1
+    for (h in 1:H) {
+        for (j in 1:J) {
+            for (i in 1:I) {
+                sub <- as.matrix(rbind(X[(Desa[, i] + Desb[, 
+                  j] + Desc[, h]) == 3, ]))
+                NK[i, (h - 1) * J + j] <- sqrt(nrow(sub))
+                XK[k, ] <- apply(sub, 2, mean) + XK1[i, ] + XK2[j, 
+                  ] + XK3[h, ] - XK12[(j - 1) * I + i, ] - XK13[(h - 
+                  1) * I + i, ] - XK23[(h - 1) * J + j, ]
+                k = k + 1
+            }
+        }
+    }
+    XKw <- XK * (as.numeric(NK))
+    PCA <- PCA.GENES(XKw)
+    scw <- PCA$scores[, 1:Fac]
+    ld <- PCA$loadings[, 1:Fac]
+    ssq <- PCA$var.exp
+    if (Fac == 1) {
+        scw <- as.matrix(scw)
+        ld <- as.matrix(ld)
+    }
+    if (Fac == 0) {
+        scw <- as.matrix(rep(0, I * J * H))
+        ld <- as.matrix(rep(0, n))
+    }
+    sc <- scw/(as.numeric(NK))
+    XKrec <- sc %*% t(ld)
+    Xabc <- NULL
+    TPabc <- NULL
+    for (i in 1:nrow(X)) {
+        position1 <- which(Desa[i, ] == 1)
+        position2 <- which(Desb[i, ] == 1)
+        position3 <- which(Desc[i, ] == 1)
+        Xabc <- rbind(Xabc, XK[I * (position2 - 1) + I * J * 
+            (position3 - 1) + position1, ])
+        TPabc <- rbind(TPabc, XKrec[I * (position2 - 1) + I * 
+            J * (position3 - 1) + position1, ])
+    }
+    Eabc <- Xabc - TPabc
+    leverage <- apply(ld^2, 1, sum)
+    SPE <- apply(Eabc^2, 2, sum)
+    output <- list(XK, sc, ld, ssq, Xabc, TPabc, Eabc, leverage, 
+        SPE)
+    names(output) <- c("data", "scores", "loadings", "var.exp", 
+        "X", "TP", "E", "leverage", "SPE")
+    output
+}
+
+ASCAfun1 (closure) = function (X, Design, Fac) 
+{
+    n <- ncol(X)
+    I <- ncol(Design)
+    NK <- NULL
+    XK <- matrix(NA, nrow = I, ncol = n)
+    for (i in 1:I) {
+        sub <- X[Design[, i] == 1, ]
+        if (is.null(nrow(sub))) {
+            NK[i] <- 1
+            XK[i, ] <- sub
+        }
+        else {
+            NK[i] <- nrow(sub)
+            XK[i, ] <- apply(sub, 2, mean)
+        }
+    }
+    NK <- sqrt(NK)
+    XKw <- NK * XK
+    PCA <- PCA.GENES(XKw)
+    scw <- PCA$scores[, 1:Fac]
+    ld <- PCA$loadings[, 1:Fac]
+    ssq <- PCA$var.exp
+    if (Fac == 1) {
+        scw <- as.matrix(scw)
+        ld <- as.matrix(ld)
+    }
+    if (Fac == 0) {
+        scw <- as.matrix(rep(0, I))
+        ld <- as.matrix(rep(0, n))
+    }
+    sc <- scw/NK
+    XKrec <- sc %*% t(ld)
+    Xa <- NULL
+    TPa <- NULL
+    for (i in 1:nrow(X)) {
+        position <- which(Design[i, ] == 1)
+        Xa <- rbind(Xa, XK[position, ])
+        TPa <- rbind(TPa, XKrec[position, ])
+    }
+    Ea <- Xa - TPa
+    leverage <- apply(ld^2, 1, sum)
+    SPE <- apply(Ea^2, 2, sum)
+    output <- list(XK, sc, ld, ssq, Xa, TPa, Ea, leverage, SPE)
+    names(output) <- c("data", "scores", "loadings", "var.exp", 
+        "X", "TP", "E", "leverage", "SPE")
+    output
+}
+
+ASCAfun12 (closure) = function (X, Desa, Desb, Fac) 
+{
+    n <- ncol(X)
+    I <- ncol(Desa)
+    J <- ncol(Desb)
+    XK1 <- matrix(NA, nrow = I, ncol = n)
+    for (i in 1:I) {
+        sub <- X[Desa[, i] == 1, ]
+        XK1[i, ] <- apply(sub, 2, mean)
+    }
+    NK <- matrix(NA, nrow = I, ncol = J)
+    XK <- matrix(NA, nrow = I * J, ncol = n)
+    k = 1
+    for (j in 1:J) {
+        for (i in 1:I) {
+            sub <- X[(Desa[, i] + Desb[, j]) == 2, ]
+            if (is.null(nrow(sub))) {
+                NK[i, j] <- 1
+                XK[k, ] <- sub - XK1[i, ]
             }
             else {
-                snd <- switch(class(x)[1], matrix.csr = rep(1:n, 
-                  times = diff(x@ia)), matrix.csc = x@ja, matrix.ssr = c(rep(1:n, 
-                  times = diff(x@ia)), x@ja), matrix.ssc = c(x@ja, 
-                  rep(1:n, times = diff(x@ia))))
-                rec <- switch(class(x)[1], matrix.csr = x@ja, 
-                  matrix.csc = rep(1:n, times = diff(x@ia)), 
-                  matrix.ssr = c(x@ja, rep(1:n, times = diff(x@ia))), 
-                  matrix.ssc = c(rep(1:n, times = diff(x@ia)), 
-                    x@ja))
-                out <- cbind(snd, rec, val)
-                if (suppress.diag) 
-                  out <- out[!(out[, 1] == out[, 2]), ]
-            }
-            attr(out, "n") <- n
-            attr(out, "vnames") <- NULL
-        }
-        if (force.bipartite && (is.null(attr(out, "bipartite")))) 
-            out <- as.edgelist.sna(out, attrname = attrname, 
-                as.digraph = as.digraph, suppress.diag = suppress.diag, 
-                force.bipartite = force.bipartite)
-    }
-    else if (is.matrix(x) || is.data.frame(x)) {
-        if ((NCOL(x) == 3) && (!is.null(attr(x, "n")))) {
-            out <- x
-            if (force.bipartite && (is.null(attr(out, "bipartite")))) {
-                out[, 2] <- out[, 2] + attr(x, "n")
-                out <- rbind(out, out[, c(2, 1, 3)])
-                attr(out, "n") <- attr(x, "n") * 2
-                attr(out, "bipartite") <- attr(x, "n")
-                if (!is.null(attr(x, "vnames"))) 
-                  attr(out, "vnames") <- c(attr(x, "vnames"), 
-                    attr(x, "vnames"))
-                else attr(out, "vnames") <- NULL
-            }
-        }
-        else if ((NCOL(x) == 2) && (!is.null(attr(x, "n")))) {
-            out <- cbind(x, rep(1, NROW(x)))
-            attr(out, "n") <- attr(x, "n")
-            attr(out, "bipartite") <- attr(x, "bipartite")
-            attr(out, "vnames") <- attr(x, "vnames")
-            if (force.bipartite && (is.null(attr(out, "bipartite")))) {
-                out[, 2] <- out[, 2] + attr(x, "n")
-                out <- rbind(out, out[, c(2, 1, 3)])
-                attr(out, "n") <- attr(x, "n") * 2
-                attr(out, "bipartite") <- attr(x, "n")
-                if (!is.null(attr(x, "vnames"))) 
-                  attr(out, "vnames") <- c(attr(x, "vnames"), 
-                    attr(x, "vnames"))
-                else attr(out, "vnames") <- NULL
-            }
-        }
-        else if (force.bipartite || (!is.null(attr(x, "bipartite"))) || 
-            (NROW(x) != NCOL(x))) {
-            mask <- is.na(x) | (x != 0)
-            if (sum(mask) > 0) {
-                snd <- row(x)[mask]
-                rec <- NROW(x) + col(x)[mask]
-                val <- x[mask]
+                NK[i, j] <- sqrt(nrow(sub))
+                XK[k, ] <- apply(sub, 2, mean) - XK1[i, ]
             }
-            else {
-                snd <- vector()
-                rec <- vector()
-                val <- vector()
-            }
-            out <- cbind(snd, rec, val)
-            out <- rbind(out, out[, c(2, 1, 3)])
-            attr(out, "n") <- NROW(x) + NCOL(x)
-            attr(out, "vnames") <- c(rownames(x), colnames(x))
-            attr(out, "bipartite") <- NROW(x)
+            k = k + 1
         }
-        else {
-            mask <- is.na(x) | (x != 0)
-            snd <- row(x)[mask]
-            rec <- col(x)[mask]
-            val <- x[mask]
-            out <- cbind(snd, rec, val)
-            attr(out, "n") <- NROW(x)
-            attr(out, "vnames") <- rownames(x)
-        }
-    }
-    else if (is.array(x)) {
-        dx <- dim(x)
-        ldx <- length(dx)
-        if (ldx == 2) {
-            if ((dx[2] == 3) && (!is.null(attr(x, "n")))) {
-                out <- as.matrix(x)
-                attr(out, "n") <- attr(x, "n")
-                attr(out, "bipartite") <- attr(x, "bipartite")
-                attr(out, "vnames") <- attr(x, "vnames")
-            }
-            if ((NCOL(x) == 2) && (!is.null(attr(x, "n")))) {
-                out <- cbind(as.matrix(x), rep(1, NROW(x)))
-                attr(out, "n") <- attr(x, "n")
-                attr(out, "bipartite") <- attr(x, "bipartite")
-                attr(out, "vnames") <- attr(x, "vnames")
-            }
-            else if (force.bipartite || (!is.null(attr(x, "bipartite"))) || 
-                (NROW(x) != NCOL(x))) {
-                mask <- is.na(x) | (x != 0)
-                if (sum(mask) > 0) {
-                  snd <- row(x)[mask]
-                  rec <- NROW(x) + col(x)[mask]
-                  val <- x[mask]
-                }
-                else {
-                  sna <- vector()
-                  rec <- vector()
-                  val <- vector()
-                }
-                out <- cbind(snd, rec, val)
-                out <- rbind(out, out[, c(2, 1, 3)])
-                attr(out, "n") <- NROW(x) + NCOL(x)
-                attr(out, "vnames") <- c(dimnames(x)[[1]], dimnames(x)[[2]])
-                attr(out, "bipartite") <- NROW(x)
+    }
+    XKw <- XK * (as.numeric(NK))
+    PCA <- PCA.GENES(XKw)
+    scw <- PCA$scores[, 1:Fac]
+    ld <- PCA$loadings[, 1:Fac]
+    ssq <- PCA$var.exp
+    if (Fac == 1) {
+        scw <- as.matrix(scw)
+        ld <- as.matrix(ld)
+    }
+    if (Fac == 0) {
+        scw <- as.matrix(rep(0, I * J))
+        ld <- as.matrix(rep(0, n))
+    }
+    sc <- scw/(as.numeric(NK))
+    XKrec <- sc %*% t(ld)
+    Xab <- NULL
+    TPab <- NULL
+    for (i in 1:nrow(X)) {
+        position1 <- which(Desa[i, ] == 1)
+        position2 <- which(Desb[i, ] == 1)
+        Xab <- rbind(Xab, XK[I * (position2 - 1) + position1, 
+            ])
+        TPab <- rbind(TPab, XKrec[I * (position2 - 1) + position1, 
+            ])
+    }
+    Eab <- Xab - TPab
+    leverage <- apply(ld^2, 1, sum)
+    SPE <- apply(Eab^2, 2, sum)
+    output <- list(XK, sc, ld, ssq, Xab, TPab, Eab, leverage, 
+        SPE)
+    names(output) <- c("data", "scores", "loadings", "var.exp", 
+        "X", "TP", "E", "leverage", "SPE")
+    output
+}
+
+ASCAfun2 (closure) = function (X, Desa, Desb, Fac) 
+{
+    n <- ncol(X)
+    I <- ncol(Desa)
+    J <- ncol(Desb)
+    XK1 <- matrix(NA, nrow = I, ncol = n)
+    for (i in 1:I) {
+        sub <- X[Desa[, i] == 1, ]
+        if (is.null(nrow(sub))) {
+            XK1[i, ] <- sub
+        }
+        else {
+            XK1[i, ] <- apply(sub, 2, mean)
+        }
+    }
+    XK2 <- matrix(NA, nrow = J, ncol = n)
+    for (j in 1:J) {
+        sub <- X[Desb[, j] == 1, ]
+        if (is.null(nrow(sub))) {
+            XK2[j, ] <- sub
+        }
+        else {
+            XK2[j, ] <- apply(sub, 2, mean)
+        }
+    }
+    NK <- matrix(NA, nrow = I, ncol = J)
+    XK <- matrix(NA, nrow = I * J, ncol = n)
+    k = 1
+    for (j in 1:J) {
+        for (i in 1:I) {
+            sub <- X[(Desa[, i] + Desb[, j]) == 2, ]
+            if (is.null(nrow(sub))) {
+                NK[i, j] <- 1
+                XK[k, ] <- sub - XK1[i, ] - XK2[j, ]
             }
             else {
-                mask <- is.na(x) | (x != 0)
-                snd <- row(x)[mask]
-                rec <- col(x)[mask]
-                val <- x[mask]
-                out <- cbind(snd, rec, val)
-                attr(out, "n") <- NROW(x)
-                attr(out, "vnames") <- dimnames(x)[[1]]
-            }
-            if (force.bipartite && (is.null(attr(out, "bipartite")))) {
-                out[, 2] <- out[, 2] + attr(x, "n")
-                out <- rbind(out, out[, c(2, 1, 3)])
-                attr(out, "n") <- attr(x, "n") * 2
-                attr(out, "bipartite") <- attr(x, "n")
-                if (!is.null(attr(x, "vnames"))) 
-                  attr(out, "vnames") <- c(attr(x, "vnames"), 
-                    attr(x, "vnames"))
-                else attr(out, "vnames") <- NULL
-            }
-        }
-        else if (ldx == 3) {
-            out <- unlist(apply(x, 1, function(z) {
-                list(as.edgelist.sna(z, attrname = attrname, 
-                  as.digraph = as.digraph, suppress.diag = suppress.diag, 
-                  force.bipartite = force.bipartite))
-            }), recursive = FALSE)
-        }
-        else stop("Array input to as.edgelist.sna must either be a proper edgelist, an adjacency matrix, or an adjacency array.\n")
-    }
-    else {
-        stop("as.edgelist.sna input must be an adjacency matrix/array, edgelist matrix, network, or sparse matrix, or list thereof.\n")
-    }
-    out
-}
-
-as.sociomatrix.sna (closure) = function (x, attrname = NULL, simplify = TRUE, force.bipartite = FALSE) 
-{
-    if ((is.list(x) && !inherits(x, "network")) && (!inherits(x, 
-        c("network", "matrix.csr", "matrix.csc", "matrix.ssr", 
-            "matrix.ssc", "matrix.hb", "data.frame")))) {
-        g <- lapply(x, as.sociomatrix.sna, attrname = attrname, 
-            simplify = simplify, force.bipartite = force.bipartite)
-    }
-    else if (inherits(x, "network")) {
-        g <- as.sociomatrix(x, attrname = attrname, simplify = simplify)
-    }
-    else if (inherits(x, c("matrix.csr", "matrix.csc", "matrix.ssr", 
-        "matrix.ssc", "matrix.hb"))) {
-        requireNamespace("SparseM")
-        bip <- attr(x, "bipartite")
-        g <- as.matrix(x)
-        attr(g, "bipartite") <- bip
-    }
-    else {
-        n <- attr(x, "n")
-        bip <- attr(x, "bipartite")
-        vnam <- attr(x, "vnames")
-        if (is.array(x) && (length(dim(x)) == 2)) 
-            x <- as.matrix(x)
-        if (is.data.frame(x)) 
-            x <- as.matrix(x)
-        if (is.matrix(x)) {
-            if ((NCOL(x) %in% c(2, 3)) && (!is.null(n))) {
-                if (NCOL(x) == 2) 
-                  x <- cbind(x, rep(1, NROW(x)))
-                g <- matrix(0, n, n)
-                if (NROW(x) > 0) 
-                  g[x[, 1:2, drop = FALSE]] <- x[, 3]
-                rownames(g) <- vnam
-                colnames(g) <- vnam
-            }
-            else if (force.bipartite || (!is.null(bip)) || (NROW(x) != 
-                NCOL(x))) {
-                nr <- NROW(x)
-                nc <- NCOL(x)
-                g <- matrix(0, nr + nc, nr + nc)
-                g[1:nr, (nr + 1):(nr + nc)] <- x
-                g[(nr + 1):(nr + nc), 1:nr] <- t(x)
-                rownames(g) <- vnam
-                colnames(g) <- vnam
+                NK[i, j] <- sqrt(nrow(sub))
+                XK[k, ] <- apply(sub, 2, mean) - XK1[i, ] - XK2[j, 
+                  ]
+            }
+            k = k + 1
+        }
+    }
+    XKw <- XK * (as.numeric(NK))
+    PCA <- PCA.GENES(XKw)
+    scw <- PCA$scores[, 1:Fac]
+    ld <- PCA$loadings[, 1:Fac]
+    ssq <- PCA$var.exp
+    if (Fac == 1) {
+        scw <- as.matrix(scw)
+        ld <- as.matrix(ld)
+    }
+    if (Fac == 0) {
+        scw <- as.matrix(rep(0, I * J))
+        ld <- as.matrix(rep(0, n))
+    }
+    sc <- scw/(as.numeric(NK))
+    XKrec <- sc %*% t(ld)
+    Xab <- NULL
+    TPab <- NULL
+    for (i in 1:nrow(X)) {
+        position1 <- which(Desa[i, ] == 1)
+        position2 <- which(Desb[i, ] == 1)
+        Xab <- rbind(Xab, XK[I * (position2 - 1) + position1, 
+            ])
+        TPab <- rbind(TPab, XKrec[I * (position2 - 1) + position1, 
+            ])
+    }
+    Eab <- Xab - TPab
+    leverage <- apply(ld^2, 1, sum)
+    SPE <- apply(Eab^2, 2, sum)
+    output <- list(XK, sc, ld, ssq, Xab, TPab, Eab, leverage, 
+        SPE)
+    names(output) <- c("data", "scores", "loadings", "var.exp", 
+        "X", "TP", "E", "leverage", "SPE")
+    output
+}
+
+CV (closure) = function (data) 
+{
+    100 * sd(data, na.rm = TRUE)/mean(data, na.rm = TRUE)
+}
+
+DE.plot (closure) = function (output, q = NULL, graphic = c("MD", "expr", "chrom", 
+    "distr"), pch = 20, cex = 0.5, col = 1, pch.sel = 1, cex.sel = 0.6, 
+    col.sel = 2, log.scale = TRUE, chromosomes = NULL, join = FALSE, 
+    ...) 
+{
+    mypar <- par(no.readonly = TRUE)
+    if (class(output) != "Output") 
+        stop("Error. Output argument must contain an object generated by noiseq or noiseqbio functions.\n")
+    graphic <- match.arg(graphic)
+    noiseqbio = "theta" %in% colnames(output@results[[1]])[1:4]
+    if (graphic == "MD") {
+        if (noiseqbio) {
+            M = output@results[[1]][, "log2FC"]
+            D = abs(output@results[[1]][, 1] - output@results[[1]][, 
+                2]) + 1
+            names(M) = names(D) = rownames(output@results[[1]])
+            plot(M, D, pch = pch, xlab = "M", ylab = "D", cex = cex, 
+                col = col, log = "y", ...)
+            if (!is.null(q)) {
+                mySelection = rownames(degenes(output, q))
+                points(M[mySelection], D[mySelection], col = col.sel, 
+                  pch = pch.sel, cex = cex.sel)
+            }
+        }
+        else {
+            plot(output@results[[1]][, "M"], (1 + output@results[[1]][, 
+                "D"]), pch = pch, xlab = "M", ylab = "D", cex = cex, 
+                col = col, log = "y", ...)
+            if (!is.null(q)) {
+                mySelection = rownames(degenes(output, q))
+                points(output@results[[1]][mySelection, "M"], 
+                  output@results[[1]][mySelection, "D"] + 1, 
+                  col = col.sel, pch = pch.sel, cex = cex.sel)
+            }
+        }
+    }
+    else if (graphic == "expr") {
+        data <- cbind(output@results[[1]][1], output@results[[1]][2])
+        rownames(data) <- rownames(output@results[[1]])
+        colnames(data) <- colnames(output@results[[1]][c(1, 2)])
+        if (log.scale) {
+            k <- min(data, na.rm = TRUE)
+            escala = logscaling(data, base = 2, k = k)
+            plot(escala$data, pch = pch, cex = cex, col = col, 
+                yaxt = "n", xaxt = "n", ...)
+            axis(side = 1, at = escala$at, labels = escala$labels)
+            axis(side = 2, at = escala$at, labels = escala$labels)
+            if (!is.null(q)) {
+                mySelection = rownames(degenes(output, q))
+                points(escala$data[mySelection, ], col = col.sel, 
+                  pch = pch.sel, cex = cex.sel)
+            }
+        }
+        else {
+            plot(data, pch = pch, cex = cex, col = col, ...)
+            if (!is.null(q)) {
+                mySelection = rownames(degenes(output, q))
+                points(data[mySelection, ], col = col.sel, pch = pch.sel, 
+                  cex = cex.sel)
+            }
+        }
+    }
+    else if (graphic == "chrom") {
+        mydata <- data.frame(as.character(output@results[[1]][, 
+            "Chrom"]), output@results[[1]][, c("GeneStart", "GeneEnd")], 
+            output@results[[1]][, 1:2])
+        mydata <- na.omit(mydata)
+        colnames(mydata) <- c("chr", "start", "end", colnames(mydata)[-c(1:3)])
+        if (is.null(chromosomes)) {
+            chromosomes <- unique(mydata$chr)
+            chromosomes = sort(chromosomes)
+        }
+        print("REMEMBER. You are plotting these chromosomes and in this order:")
+        print(chromosomes)
+        if (log.scale) {
+            if (min(mydata[, -c(1:3)], na.rm = TRUE) < 1) {
+                kk <- -min(mydata[, -c(1:3)], na.rm = TRUE) + 
+                  1
             }
             else {
-                g <- x
+                kk <- 0
             }
+            mydata[, -c(1:3)] <- log2(mydata[, -c(1:3)] + kk)
         }
-        else if (is.array(x)) {
-            if (length(dim(x)) != 3) 
-                stop("as.sociomatrix.sna input must be an adjacency matrix/array, network, data frame, sparse matrix, or list.")
-            if (force.bipartite || (!is.null(attr(x, "bipartite"))) || 
-                (dim(x)[2] != dim(x)[3])) {
-                dx <- dim(x)
-                nr <- dx[2]
-                nc <- dx[3]
-                g <- array(0, dim = c(dx[1], nr + nc, nr + nc))
-                for (i in 1:dx[1]) {
-                  g[i, 1:nr, (nr + 1):(nr + nc)] <- x[i, , ]
-                  g[i, (nr + 1):(nr + nc), 1:nr] <- t(x[i, , 
-                    ])
+        ordenat = NULL
+        for (cromo in chromosomes) {
+            myselec = mydata[mydata[, "chr"] == cromo, ]
+            myselec = myselec[order(myselec[, "start"]), ]
+            ordenat = rbind(ordenat, myselec)
+        }
+        sel.ord <- NULL
+        if (!is.null(q)) {
+            cond1 <- rownames(degenes(output, q, M = "up"))
+            cond2 <- rownames(degenes(output, q, M = "down"))
+            cond1 <- (rownames(ordenat) %in% cond1) * 1
+            cond2 <- (rownames(ordenat) %in% cond2) * 1
+            sel.ord <- cbind(cond1, cond2)
+            rownames(sel.ord) <- rownames(ordenat)
+        }
+        chr.long <- aggregate(ordenat[, "end"], by = list(as.character(ordenat[, 
+            "chr"])), max)
+        chr.long <- chr.long[match(chromosomes, chr.long[, 1]), 
+            ]
+        if (join) {
+            total.long <- sum(as.numeric(chr.long$x))
+            chr.start <- cumsum(c(1, chr.long$x[-length(chr.long$x)]))
+            names(chr.start) <- chr.long[, 1]
+            plot(c(1, total.long), c(-max(ordenat[, 5]), max(ordenat[, 
+                4])), type = "n", xlab = "", ylab = "Expression data", 
+                xaxt = "n")
+            axis(side = 1, at = chr.start, labels = chr.long[, 
+                1], font = 2)
+            abline(h = 0, lty = 2, lwd = 0.5)
+            for (ch in chromosomes) {
+                dat.chr <- ordenat[which(ordenat[, "chr"] == 
+                  ch), ]
+                dat.chr[, c("start", "end")] <- dat.chr[, c("start", 
+                  "end")] + chr.start[ch] - 1
+                rect(xleft = dat.chr[, "start"], ybottom = 0, 
+                  xright = dat.chr[, "end"], ytop = dat.chr[, 
+                    4], col = "grey", border = NA)
+                rect(xleft = dat.chr[, "start"], ybottom = -dat.chr[, 
+                  5], xright = dat.chr[, "end"], ytop = 0, col = "grey", 
+                  border = NA)
+                if (!is.null(q)) {
+                  aux <- which(rownames(sel.ord) %in% rownames(dat.chr))
+                  sel.chr1 <- dat.chr[, 4] * sel.ord[aux, 1]
+                  sel.chr2 <- -dat.chr[, 5] * sel.ord[aux, 2]
+                  rect(xleft = dat.chr[, "start"], ybottom = 0, 
+                    xright = dat.chr[, "end"], ytop = sel.chr1, 
+                    col = 2, border = NA)
+                  rect(xleft = dat.chr[, "start"], ybottom = sel.chr2, 
+                    xright = dat.chr[, "end"], ytop = 0, col = 3, 
+                    border = NA)
                 }
+                segments(x0 = dat.chr[, "start"], y0 = 0, x1 = dat.chr[, 
+                  "end"], y1 = 0, col = 4, lwd = 0.5)
             }
-            else {
-                g <- x
+            text(c(1, 1), 0.9 * c(max(ordenat[, 4]), -max(ordenat[, 
+                5])), colnames(mydata)[4:5], font = 3, adj = 0, 
+                col = 2:3)
+        }
+        else {
+            num.chr <- length(chromosomes)
+            k <- 20
+            long.prop <- round((chr.long$x/min(chr.long$x)) * 
+                k, 0)
+            while (max(long.prop) * num.chr > 500 | max(long.prop) > 
+                50) {
+                k <- k - 1
+                long.prop <- round((chr.long$x/min(chr.long$x)) * 
+                  k, 0)
+            }
+            forlayout <- matrix(0, num.chr, max(long.prop))
+            for (i in 1:num.chr) {
+                forlayout[i, 1:long.prop[i]] <- i
+            }
+            layout(forlayout)
+            if (num.chr > 1) 
+                par(mar = c(2, 4.1, 0.1, 0.1))
+            miylim <- c(-max(ordenat[, 5], na.rm = TRUE), max(ordenat[, 
+                4], na.rm = TRUE))
+            for (i in 1:num.chr) {
+                apintar <- ordenat[which(ordenat[, "chr"] == 
+                  chromosomes[i]), 2:5]
+                plot(c(1, chr.long[i, 2]), miylim, type = "n", 
+                  xlab = "", ylab = chromosomes[i], xaxt = "n", 
+                  font.lab = 2, cex.lab = 1.3)
+                rect(xleft = apintar[, "start"], ybottom = 0, 
+                  xright = apintar[, "end"], ytop = apintar[, 
+                    3], col = "grey", border = NA)
+                rect(xleft = apintar[, "start"], ybottom = -apintar[, 
+                  4], xright = apintar[, "end"], ytop = 0, col = "grey", 
+                  border = NA)
+                if (!is.null(q)) {
+                  aux <- which(rownames(sel.ord) %in% rownames(apintar))
+                  asel <- sel.ord[aux, ] * apintar[, 3:4]
+                  rect(xleft = apintar[, "start"], ybottom = 0, 
+                    xright = apintar[, "end"], ytop = asel[, 
+                      1], col = 2, border = NA)
+                  rect(xleft = apintar[, "start"], ybottom = -asel[, 
+                    2], xright = apintar[, "end"], ytop = 0, 
+                    col = 3, border = NA)
+                }
+                abline(h = 0, lty = 2, lwd = 0.5)
+                segments(x0 = apintar[, "start"], y0 = 0, x1 = apintar[, 
+                  "end"], y1 = 0, col = 4, lwd = 0.5)
+                etiq <- mypretty(c(1, chr.long[i, 2]), n = 10)
+                axis(side = 1, at = etiq, labels = etiq)
+                text(c(1, 1), 0.9 * miylim, colnames(mydata)[5:4], 
+                  font = 3, adj = 0, col = 3:2)
             }
         }
-        else {
-            stop("as.sociomatrix.sna input must be an adjacency matrix/array, network, or list.")
-        }
     }
-    if (is.list(g)) {
-        if (length(g) == 1) {
-            g <- g[[1]]
-            if ((!simplify) && (length(dim(g)) == 3)) {
-                out <- list()
-                for (i in 1:dim(g)[1]) out[[i]] <- g[i, , ]
-            }
-            else {
-                out <- g
-            }
-        }
-        else {
-            if (simplify) {
-                dims <- sapply(g, dim)
-                if (is.list(dims)) {
-                  mats <- sapply(dims, length)
-                  mats[mats == 1] <- 0
-                  mats[mats == 2] <- 1
-                  mats[mats == 3] <- sapply(dims[mats == 3], 
-                    "[[", 1)
-                  mats <- cumsum(mats)
-                  dims <- sapply(dims, "[", 2)
+    else if (graphic == "distr") {
+        if (!is.null(q)) {
+            mySelection = rownames(degenes(output, q))
+            detect = rownames(output@results[[1]]) %in% mySelection
+        }
+        else {
+            stop("You must specify a valid value for q\n")
+        }
+        if ("Chrom" %in% colnames(output@results[[1]])) {
+            numplot = 1
+            infobio = output@results[[1]][, "Chrom"]
+            genome <- 100 * table(infobio)/sum(table(infobio))
+            ordre <- order(genome, decreasing = TRUE)
+            perdet1 <- genome * table(infobio, detect)[names(genome), 
+                2]/table(infobio)[names(genome)]
+            perdet2 <- 100 * table(infobio, detect)[names(genome), 
+                2]/sum(table(infobio, detect)[, 2])
+            ceros <- rep(0, length(genome))
+            biotable1 <- as.matrix(rbind(genome[ordre], perdet1[ordre], 
+                perdet2[ordre], ceros))
+            rownames(biotable1) <- c("genome", "degVSgenome", 
+                "deg", "ceros")
+            if (!is.null(chromosomes)) 
+                biotable1 = biotable1[, chromosomes]
+            ymaxL1 <- ceiling(max(biotable1, na.rm = TRUE))
+        }
+        else {
+            numplot = 0
+        }
+        if ("Biotype" %in% colnames(output@results[[1]])) {
+            numplot = c(numplot, 1)
+            infobio = output@results[[1]][, "Biotype"]
+            genome <- 100 * table(infobio)/sum(table(infobio))
+            ordre <- order(genome, decreasing = TRUE)
+            perdet1 <- genome * table(infobio, detect)[names(genome), 
+                2]/table(infobio)[names(genome)]
+            perdet2 <- 100 * table(infobio, detect)[names(genome), 
+                2]/sum(table(infobio, detect)[, 2])
+            ceros <- rep(0, length(genome))
+            biotable2 <- as.matrix(rbind(genome[ordre], perdet1[ordre], 
+                perdet2[ordre], ceros))
+            rownames(biotable2) <- c("genome", "degVSgenome", 
+                "deg", "ceros")
+            higher2 = which(biotable2[1, ] > 2)
+            lower2 = which(biotable2[1, ] <= 2)
+            if (length(higher2) > 0) {
+                ymaxL2 <- ceiling(max(biotable2[, higher2], na.rm = TRUE))
+                if (length(lower2) > 0) {
+                  ymaxR2 <- ceiling(max(biotable2[, lower2], 
+                    na.rm = TRUE))
+                  biotable2[, lower2] <- biotable2[, lower2] * 
+                    ymaxL2/ymaxR2
                 }
                 else {
-                  if (NROW(dims) == 3) 
-                    mats <- cumsum(dims[1, ])
-                  else mats <- 1:NCOL(dims)
-                  dims <- dims[2, ]
-                }
-                if ((!any(is.null(dims))) && (length(unique(dims)) == 
-                  1) && (all(mats > 0))) {
-                  out <- array(dim = c(mats[length(mats)], dims[1], 
-                    dims[1]))
-                  for (i in 1:length(mats)) out[(c(0, mats)[i] + 
-                    1):(mats[i]), , ] <- g[[i]]
+                  ymaxR2 = ymaxL2
                 }
-                else out <- g
             }
-            else out <- g
-        }
-    }
-    else {
-        if ((!simplify) && (length(dim(g)) == 3)) {
-            out <- list()
-            for (i in 1:dim(g)[1]) out[[i]] <- g[i, , ]
-        }
-        else out <- g
-    }
-    out
-}
-
-bbnam (closure) = function (dat, model = "actor", ...) 
-{
-    if (model == "actor") 
-        bbnam.actor(dat, ...)
-    else if (model == "pooled") 
-        bbnam.pooled(dat, ...)
-    else if (model == "fixed") 
-        bbnam.fixed(dat, ...)
-}
-
-bbnam.actor (closure) = function (dat, nprior = 0.5, emprior = c(1, 11), epprior = c(1, 
-    11), diag = FALSE, mode = "digraph", reps = 5, draws = 1500, 
-    burntime = 500, quiet = TRUE, anames = NULL, onames = NULL, 
-    compute.sqrtrhat = TRUE) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("All bbnam input graphs must be of the same order.")
-    if (length(dim(dat)) == 2) 
-        dat <- array(dat, dim = c(1, NROW(dat), NCOL(dat)))
-    if (reps == 1) 
-        compute.sqrtrhat <- FALSE
-    m <- dim(dat)[1]
-    n <- dim(dat)[2]
-    d <- dat
-    slen <- burntime + floor(draws/reps)
-    out <- list()
-    if ((!is.matrix(nprior)) || (NROW(nprior) != n) || (NCOL(nprior) != 
-        n)) 
-        nprior <- matrix(nprior, n, n)
-    if ((!is.matrix(emprior)) || (NROW(emprior) != m) || (NCOL(emprior) != 
-        2)) {
-        if (length(emprior) == 2) 
-            emprior <- sapply(emprior, rep, m)
-        else emprior <- matrix(emprior, m, 2)
-    }
-    if ((!is.matrix(epprior)) || (NROW(epprior) != m) || (NCOL(epprior) != 
-        2)) {
-        if (length(epprior) == 2) 
-            epprior <- sapply(epprior, rep, m)
-        else epprior <- matrix(epprior, m, 2)
-    }
-    if (is.null(anames)) 
-        anames <- paste("a", 1:n, sep = "")
-    if (is.null(onames)) 
-        onames <- paste("o", 1:m, sep = "")
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    if (!diag) 
-        d <- diag.remove(d)
-    if (!quiet) 
-        cat("Creating temporary variables and drawing initial conditions....\n")
-    a <- array(dim = c(reps, slen, n, n))
-    em <- array(dim = c(reps, slen, m))
-    ep <- array(dim = c(reps, slen, m))
-    for (k in 1:reps) {
-        a[k, 1, , ] <- rgraph(n, 1, diag = diag, mode = mode)
-        em[k, 1, ] <- runif(m, 0, 0.5)
-        ep[k, 1, ] <- runif(m, 0, 0.5)
-    }
-    for (i in 1:reps) {
-        for (j in 2:slen) {
-            if (!quiet) 
-                cat("Repetition", i, ", draw", j, ":\n\tDrawing adjacency matrix\n")
-            ep.a <- aperm(array(sapply(ep[i, j - 1, ], rep, n^2), 
-                dim = c(n, n, m)), c(3, 2, 1))
-            em.a <- aperm(array(sapply(em[i, j - 1, ], rep, n^2), 
-                dim = c(n, n, m)), c(3, 2, 1))
-            pygt <- apply(d * (1 - em.a) + (1 - d) * em.a, c(2, 
-                3), prod, na.rm = TRUE)
-            pygnt <- apply(d * ep.a + (1 - d) * (1 - ep.a), c(2, 
-                3), prod, na.rm = TRUE)
-            tieprob <- (nprior * pygt)/(nprior * pygt + (1 - 
-                nprior) * pygnt)
-            if (mode == "graph") 
-                tieprob[upper.tri(tieprob)] <- t(tieprob)[upper.tri(tieprob)]
-            a[i, j, , ] <- rgraph(n, 1, tprob = tieprob, mode = mode, 
-                diag = diag)
-            if (!quiet) 
-                cat("\tAggregating binomial counts\n")
-            cem <- matrix(nrow = m, ncol = 2)
-            cep <- matrix(nrow = m, ncol = 2)
-            for (x in 1:m) {
-                cem[x, 1] <- sum((1 - d[x, , ]) * a[i, j, , ], 
-                  na.rm = TRUE)
-                cem[x, 2] <- sum(d[x, , ] * a[i, j, , ], na.rm = TRUE)
-                cep[x, 1] <- sum(d[x, , ] * (1 - a[i, j, , ]), 
-                  na.rm = TRUE)
-                cep[x, 2] <- sum((1 - d[x, , ]) * (1 - a[i, j, 
-                  , ]), na.rm = TRUE)
-            }
-            if (!quiet) 
-                cat("\tDrawing error parameters\n")
-            em[i, j, ] <- rbeta(m, emprior[, 1] + cem[, 1], emprior[, 
-                2] + cem[, 2])
-            ep[i, j, ] <- rbeta(m, epprior[, 1] + cep[, 1], epprior[, 
-                2] + cep[, 2])
-        }
-    }
-    if (!quiet) 
-        cat("Finished drawing from Markov chain.  Now computing potential scale reduction statistics.\n")
-    if (compute.sqrtrhat) {
-        out$sqrtrhat <- vector()
-        for (i in 1:n) for (j in 1:n) out$sqrtrhat <- c(out$sqrtrhat, 
-            potscalered.mcmc(aperm(a, c(2, 1, 3, 4))[, , i, j]))
-        for (i in 1:m) out$sqrtrhat <- c(out$sqrtrhat, potscalered.mcmc(aperm(em, 
-            c(2, 1, 3))[, , i]), potscalered.mcmc(aperm(ep, c(2, 
-            1, 3))[, , i]))
-        if (!quiet) 
-            cat("\tMax potential scale reduction (Gelman et al.'s sqrt(Rhat)) for all scalar estimands:", 
-                max(out$sqrtrhat[!is.nan(out$sqrtrhat)], na.rm = TRUE), 
-                "\n")
-    }
-    if (!quiet) 
-        cat("Preparing output.\n")
-    out$net <- array(dim = c(reps * (slen - burntime), n, n))
-    for (i in 1:reps) for (j in burntime:slen) {
-        out$net[(i - 1) * (slen - burntime) + (j - burntime), 
-            , ] <- a[i, j, , ]
-    }
-    if (!quiet) 
-        cat("\tAggregated network variable draws\n")
-    out$em <- em[1, (burntime + 1):slen, ]
-    out$ep <- ep[1, (burntime + 1):slen, ]
-    if (reps >= 2) 
-        for (i in 2:reps) {
-            out$em <- rbind(out$em, em[i, (burntime + 1):slen, 
-                ])
-            out$ep <- rbind(out$ep, ep[i, (burntime + 1):slen, 
-                ])
-        }
-    if (!quiet) 
-        cat("\tAggregated error parameters\n")
-    out$anames <- anames
-    out$onames <- onames
-    out$nactors <- n
-    out$nobservers <- m
-    out$reps <- reps
-    out$draws <- dim(out$em)[1]
-    out$burntime <- burntime
-    out$model <- "actor"
-    class(out) <- c("bbnam.actor", "bbnam")
-    out
-}
-
-bbnam.bf (closure) = function (dat, nprior = 0.5, em.fp = 0.5, ep.fp = 0.5, emprior.pooled = c(1, 
-    11), epprior.pooled = c(1, 11), emprior.actor = c(1, 11), 
-    epprior.actor = c(1, 11), diag = FALSE, mode = "digraph", 
-    reps = 1000) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("All bbnam.bf input graphs must be of the same order.")
-    if (length(dim(dat)) == 2) 
-        dat <- array(dat, dim = c(1, NROW(dat), NCOL(dat)))
-    m <- dim(dat)[1]
-    n <- dim(dat)[2]
-    if ((!is.matrix(nprior)) || (NROW(nprior) != n) || (NCOL(nprior) != 
-        n)) 
-        nprior <- matrix(nprior, n, n)
-    if ((!is.matrix(emprior.actor)) || (NROW(emprior.actor) != 
-        m) || (NCOL(emprior.actor) != 2)) {
-        if (length(emprior.actor) == 2) 
-            emprior.actor <- sapply(emprior.actor, rep, m)
-        else emprior.actor <- matrix(emprior.actor, m, 2)
-    }
-    if ((!is.matrix(epprior.actor)) || (NROW(epprior.actor) != 
-        m) || (NCOL(epprior.actor) != 2)) {
-        if (length(epprior.actor) == 2) 
-            epprior.actor <- sapply(epprior.actor, rep, m)
-        else epprior.actor <- matrix(epprior.actor, m, 2)
-    }
-    d <- dat
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- lower.tri.remove(d)
-    pfpv <- vector()
-    ppov <- vector()
-    pacv <- vector()
-    for (i in 1:reps) {
-        a <- rgraph(n, 1, tprob = nprior)
-        em.pooled <- eval(call("rbeta", 1, emprior.pooled[1], 
-            emprior.pooled[2]))
-        ep.pooled <- eval(call("rbeta", 1, epprior.pooled[1], 
-            epprior.pooled[2]))
-        em.actor <- eval(call("rbeta", n, emprior.actor[, 1], 
-            emprior.actor[, 2]))
-        ep.actor <- eval(call("rbeta", n, epprior.actor[, 1], 
-            epprior.actor[, 2]))
-        pfpv[i] <- bbnam.jntlik(d, a = a, em = em.fp, ep = ep.fp, 
-            log = TRUE)
-        ppov[i] <- bbnam.jntlik(d, a = a, em = em.pooled, ep = ep.pooled, 
-            log = TRUE)
-        pacv[i] <- bbnam.jntlik(d, a = a, em = em.actor, ep = ep.actor, 
-            log = TRUE)
-    }
-    int.lik <- c(logMean(pfpv), logMean(ppov), logMean(pacv))
-    int.lik.std <- sqrt(c(var(pfpv), var(ppov), var(pacv)))
-    int.lik.std <- (logSub(c(logMean(2 * pfpv), logMean(2 * ppov), 
-        logMean(2 * pacv)), 2 * int.lik) - log(reps))/2
-    o <- list()
-    o$int.lik <- matrix(nrow = 3, ncol = 3)
-    for (i in 1:3) for (j in 1:3) {
-        if (i != j) 
-            o$int.lik[i, j] <- int.lik[i] - int.lik[j]
-        else o$int.lik[i, i] <- int.lik[i]
-    }
-    o$int.lik.std <- int.lik.std
-    o$reps <- reps
-    o$prior.param <- list(nprior, em.fp, ep.fp, emprior.pooled, 
-        epprior.pooled, emprior.actor, epprior.actor)
-    o$prior.param.names <- c("nprior", "em.fp", "ep.fp", "emprior.pooled", 
-        "epprior.pooled", "emprior.actor", "epprior.actor")
-    o$model.names <- c("Fixed Error Prob", "Pooled Error Prob", 
-        "Actor Error Prob")
-    class(o) <- c("bbnam.bf", "bayes.factor")
-    o
-}
-
-bbnam.fixed (closure) = function (dat, nprior = 0.5, em = 0.25, ep = 0.25, diag = FALSE, 
-    mode = "digraph", draws = 1500, outmode = "draws", anames = NULL, 
-    onames = NULL) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("All bbnam input graphs must be of the same order.")
-    if (length(dim(dat)) == 2) 
-        dat <- array(dat, dim = c(1, NROW(dat), NCOL(dat)))
-    m <- dim(dat)[1]
-    n <- dim(dat)[2]
-    if ((!is.matrix(nprior)) || (NROW(nprior) != n) || (NCOL(nprior) != 
-        n)) 
-        nprior <- matrix(nprior, n, n)
-    if (is.null(anames)) 
-        anames <- paste("a", 1:n, sep = "")
-    if (is.null(onames)) 
-        onames <- paste("o", 1:m, sep = "")
-    if (length(em) == m * n^2) 
-        em.a <- em
-    else if (length(em) == n^2) 
-        em.a <- apply(em, c(1, 2), rep, m)
-    else if (length(em) == m) 
-        em.a <- aperm(array(sapply(em, rep, n^2), dim = c(n, 
-            n, m)), c(3, 2, 1))
-    else if (length(em) == 1) 
-        em.a <- array(rep(em, m * n^2), dim = c(m, n, n))
-    if (length(ep) == m * n^2) 
-        ep.a <- ep
-    else if (length(ep) == n^2) 
-        ep.a <- apply(ep, c(1, 2), rep, m)
-    else if (length(ep) == m) 
-        ep.a <- aperm(array(sapply(ep, rep, n^2), dim = c(n, 
-            n, m)), c(3, 2, 1))
-    else if (length(ep) == 1) 
-        ep.a <- array(rep(ep, m * n^2), dim = c(m, n, n))
-    pygt <- apply(dat * (1 - em.a) + (1 - dat) * em.a, c(2, 3), 
-        prod, na.rm = TRUE)
-    pygnt <- apply(dat * ep.a + (1 - dat) * (1 - ep.a), c(2, 
-        3), prod, na.rm = TRUE)
-    npost <- (nprior * pygt)/(nprior * pygt + (1 - nprior) * 
-        pygnt)
-    if (outmode == "posterior") 
-        npost
-    else {
-        o <- list()
-        o$net <- rgraph(n, draws, tprob = npost, diag = diag, 
-            mode = mode)
-        o$anames <- anames
-        o$onames <- onames
-        o$nactors <- n
-        o$nobservers <- m
-        o$draws <- draws
-        o$model <- "fixed"
-        class(o) <- c("bbnam.fixed", "bbnam")
-        o
-    }
-}
-
-bbnam.jntlik (closure) = function (dat, log = FALSE, ...) 
-{
-    p <- sum(sapply(1:dim(dat)[1], bbnam.jntlik.slice, dat = dat, 
-        log = TRUE, ...))
-    if (!log) 
-        exp(p)
-    else p
-}
-
-bbnam.jntlik.slice (closure) = function (s, dat, a, em, ep, log = FALSE) 
-{
-    if (length(em) > 1) 
-        em.l <- em[s]
-    else em.l <- em
-    if (length(ep) > 1) 
-        ep.l <- ep[s]
-    else ep.l <- ep
-    p <- sum(log((1 - a) * (dat[s, , ] * ep.l + (1 - dat[s, , 
-        ]) * (1 - ep.l)) + a * (dat[s, , ] * (1 - em.l) + (1 - 
-        dat[s, , ]) * em.l)), na.rm = TRUE)
-    if (!log) 
-        exp(p)
-    else p
-}
-
-bbnam.pooled (closure) = function (dat, nprior = 0.5, emprior = c(1, 11), epprior = c(1, 
-    11), diag = FALSE, mode = "digraph", reps = 5, draws = 1500, 
-    burntime = 500, quiet = TRUE, anames = NULL, onames = NULL, 
-    compute.sqrtrhat = TRUE) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("All bbnam input graphs must be of the same order.")
-    if (length(dim(dat)) == 2) 
-        dat <- array(dat, dim = c(1, NROW(dat), NCOL(dat)))
-    if (reps == 1) 
-        compute.sqrtrhat <- FALSE
-    m <- dim(dat)[1]
-    n <- dim(dat)[2]
-    d <- dat
-    slen <- burntime + floor(draws/reps)
-    out <- list()
-    if ((!is.matrix(nprior)) || (NROW(nprior) != n) || (NCOL(nprior) != 
-        n)) 
-        nprior <- matrix(nprior, n, n)
-    if (is.null(anames)) 
-        anames <- paste("a", 1:n, sep = "")
-    if (is.null(onames)) 
-        onames <- paste("o", 1:m, sep = "")
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    if (!diag) 
-        d <- diag.remove(d)
-    if (!quiet) 
-        cat("Creating temporary variables and drawing initial conditions....\n")
-    a <- array(dim = c(reps, slen, n, n))
-    em <- array(dim = c(reps, slen))
-    ep <- array(dim = c(reps, slen))
-    for (k in 1:reps) {
-        a[k, 1, , ] <- rgraph(n, 1, diag = diag, mode = mode)
-        em[k, 1] <- runif(1, 0, 0.5)
-        ep[k, 1] <- runif(1, 0, 0.5)
-    }
-    for (i in 1:reps) {
-        for (j in 2:slen) {
-            if (!quiet) 
-                cat("Repetition", i, ", draw", j, ":\n\tDrawing adjacency matrix\n")
-            ep.a <- array(rep(ep[i, j - 1], m * n^2), dim = c(m, 
-                n, n))
-            em.a <- array(rep(em[i, j - 1], m * n^2), dim = c(m, 
-                n, n))
-            pygt <- apply(d * (1 - em.a) + (1 - d) * em.a, c(2, 
-                3), prod, na.rm = TRUE)
-            pygnt <- apply(d * ep.a + (1 - d) * (1 - ep.a), c(2, 
-                3), prod, na.rm = TRUE)
-            tieprob <- (nprior * pygt)/(nprior * pygt + (1 - 
-                nprior) * pygnt)
-            if (mode == "graph") 
-                tieprob[upper.tri(tieprob)] <- t(tieprob)[upper.tri(tieprob)]
-            a[i, j, , ] <- rgraph(n, 1, tprob = tieprob, mode = mode, 
-                diag = diag)
-            if (!quiet) 
-                cat("\tAggregating binomial counts\n")
-            cem <- vector(length = 2)
-            cep <- vector(length = 2)
-            a.a <- apply(a[i, j, , ], c(1, 2), rep, m)
-            cem[1] <- sum((1 - d) * a.a, na.rm = TRUE)
-            cem[2] <- sum(d * a.a, na.rm = TRUE)
-            cep[1] <- sum(d * (1 - a.a), na.rm = TRUE)
-            cep[2] <- sum((1 - d) * (1 - a.a), na.rm = TRUE)
-            if (!quiet) 
-                cat("\tDrawing error parameters\n")
-            em[i, j] <- rbeta(1, emprior[1] + cem[1], emprior[2] + 
-                cem[2])
-            ep[i, j] <- rbeta(1, epprior[1] + cep[1], epprior[2] + 
-                cep[2])
-        }
-    }
-    if (!quiet) 
-        cat("Finished drawing from Markov chain.  Now computing potential scale reduction statistics.\n")
-    if (compute.sqrtrhat) {
-        out$sqrtrhat <- vector()
-        for (i in 1:n) for (j in 1:n) out$sqrtrhat <- c(out$sqrtrhat, 
-            potscalered.mcmc(aperm(a, c(2, 1, 3, 4))[, , i, j]))
-        out$sqrtrhat <- c(out$sqrtrhat, potscalered.mcmc(em), 
-            potscalered.mcmc(ep))
-        if (!quiet) 
-            cat("\tMax potential scale reduction (Gelman et al.'s sqrt(Rhat)) for all scalar estimands:", 
-                max(out$sqrtrhat[!is.nan(out$sqrtrhat)], na.rm = TRUE), 
-                "\n")
-    }
-    if (!quiet) 
-        cat("Preparing output.\n")
-    out$net <- array(dim = c(reps * (slen - burntime), n, n))
-    for (i in 1:reps) for (j in burntime:slen) {
-        out$net[(i - 1) * (slen - burntime) + (j - burntime), 
-            , ] <- a[i, j, , ]
-    }
-    if (!quiet) 
-        cat("\tAggregated network variable draws\n")
-    out$em <- em[1, (burntime + 1):slen]
-    out$ep <- ep[1, (burntime + 1):slen]
-    if (reps >= 2) 
-        for (i in 2:reps) {
-            out$em <- c(out$em, em[i, (burntime + 1):slen])
-            out$ep <- c(out$ep, ep[i, (burntime + 1):slen])
-        }
-    if (!quiet) 
-        cat("\tAggregated error parameters\n")
-    out$anames <- anames
-    out$onames <- onames
-    out$nactors <- n
-    out$nobservers <- m
-    out$reps <- reps
-    out$draws <- length(out$em)
-    out$burntime <- burntime
-    out$model <- "pooled"
-    class(out) <- c("bbnam.pooled", "bbnam")
-    out
-}
-
-bbnam.probtie (closure) = function (dat, i, j, npriorij, em, ep) 
-{
-    num <- npriorij
-    denom <- 1 - npriorij
-    num <- num * prod(dat[, i, j] * (1 - em) + (1 - dat[, i, 
-        j]) * em, na.rm = TRUE)
-    denom <- denom * prod(dat[, i, j] * ep + (1 - dat[, i, j]) * 
-        (1 - ep), na.rm = TRUE)
-    p <- num/(denom + num)
-    p
-}
-
-betweenness (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "directed", geodist.precomp = NULL, 
-    rescale = FALSE, ignore.eval = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], betweenness, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            geodist.precomp = geodist.precomp, rescale = rescale, 
-            ignore.eval = ignore.eval))
-    n <- attr(dat, "n")
-    if (tmaxdev) {
-        if (!(cmode %in% c("directed", "undirected"))) {
-            star <- rbind(rep(1, n - 1), 2:n, rep(1, n - 1))
-            if (gmode == "graph") 
-                star <- cbind(star, star[, c(2, 1, 3)])
-            attr(star, "n") <- n
-            bet <- betweenness(star, g = 1, nodes = 1:n, gmode = gmode, 
-                diag = diag, tmaxdev = FALSE, cmode = cmode, 
-                geodist.precomp = NULL, rescale = FALSE, ignore.eval = ignore.eval)
-            bet <- sum(max(bet) - bet)
-        }
-        if (gmode == "graph") 
-            cmode <- "undirected"
-        bet <- switch(cmode, directed = (n - 1)^2 * (n - 2), 
-            undirected = (n - 1)^2 * (n - 2)/2, bet)
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode == "undirected") 
-            dat <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-        meas <- switch(cmode, undirected = 0, directed = 0, endpoints = 1, 
-            proximalsrc = 2, proximaltar = 3, proximalsum = 4, 
-            lengthscaled = 5, linearscaled = 6)
-        if (!is.null(geodist.precomp)) {
-            if (is.null(geodist.precomp$gdist) || is.null(geodist.precomp$counts) || 
-                is.null(geodist.precomp$predecessors)) {
-                warning("Precomputed geodist output must include distance, count, and predecessor information (at least one of which was missing in geodist.precomp).  Re-computing on the fly.\n")
-                precomp <- FALSE
+            else {
+                ymaxR2 <- ceiling(max(biotable2[, lower2], na.rm = TRUE))
+                ymaxL2 = ymaxR2
             }
-            else precomp <- TRUE
         }
         else {
-            precomp <- FALSE
-        }
-        bet <- .Call("betweenness_R", dat, n, NROW(dat), meas, 
-            precomp, ignore.eval, geodist.precomp$gdist, geodist.precomp$counts, 
-            geodist.precomp$predecessors, PACKAGE = "sna")
-        if ((cmode == "undirected") || (gmode == "graph")) 
-            bet <- bet/2
-        if (rescale) 
-            bet <- bet/sum(bet)
-        bet <- bet[nodes]
-    }
-    bet
-}
-
-bicomponent.dist (closure) = function (dat, symmetrize = c("strong", "weak")) 
-{
-    dat <- as.edgelist.sna(dat, suppress.diag = TRUE)
-    if (is.list(dat)) 
-        return(lapply(dat, bicomponent.dist, symmetrize = symmetrize))
-    n <- attr(dat, "n")
-    dat <- symmetrize(dat, rule = match.arg(symmetrize), return.as.edgelist = TRUE)
-    bc <- .Call("bicomponents_R", dat, n, NROW(dat), PACKAGE = "sna")
-    if (length(bc[[1]]) > 1) {
-        ord <- order(sapply(bc[[1]], length), decreasing = TRUE)
-        bc[[1]] <- bc[[1]][ord]
-        bc[[2]][bc[[2]] > 0] <- match(bc[[2]][bc[[2]] > 0], ord)
-    }
-    bc[[2]][bc[[2]] < 0] <- NA
-    bc[[1]] <- bc[[1]][sapply(bc[[1]], length) > 0]
-    o <- list()
-    if (length(bc[[1]]) > 0) {
-        o$members <- bc[[1]]
-        names(o$members) <- 1:length(o$members)
-        o$membership <- bc[[2]]
-        o$csize <- sapply(o$members, length)
-        names(o$csize) <- 1:length(o$csize)
-        o$cdist <- tabulate(o$csize, nbins = n)
-        names(o$cdist) <- 1:n
-    }
-    else {
-        o$members <- list()
-        o$membership <- bc[[2]]
-        o$csize <- vector(mode = "numeric")
-        o$cdist <- rep(0, n)
-        names(o$cdist) <- 1:n
-    }
-    o
-}
-
-blockmodel (closure) = function (dat, ec, k = NULL, h = NULL, block.content = "density", 
-    plabels = NULL, glabels = NULL, rlabels = NULL, mode = "digraph", 
-    diag = FALSE) 
-{
-    if (inherits(ec, "equiv.clust")) 
-        b <- cutree(ec$cluster, k, h)
-    else if (inherits(ec, "hclust")) 
-        b <- cutree(ec, k, h)
-    else b <- ec
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("Blockmodel requires input graphs to be of identical order.")
-    n <- dim(dat)[2]
-    if (length(dim(dat)) > 2) 
-        d <- dat
-    else {
-        d <- array(dim = c(1, n, n))
-        d[1, , ] <- dat
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (is.null(plabels)) {
-        if (inherits(ec, "equiv.clust")) 
-            plabels <- ec$plabels
-        else plabels <- 1:length(b)
-    }
-    if (is.null(glabels)) {
-        if (inherits(ec, "equiv.clust")) 
-            glabels <- ec$glabels
-        else glabels <- 1:length(b)
-    }
-    rn <- max(b)
-    rm <- dim(d)[1]
-    if (is.null(rlabels)) 
-        rlabels <- paste("Block", 1:rn)
-    bm <- array(dim = c(rm, rn, rn))
-    for (i in 1:rm) for (j in 1:rn) for (k in 1:rn) {
-        if (block.content == "density") 
-            bm[i, j, k] <- mean(d[i, b == j, b == k, drop = FALSE], 
-                na.rm = TRUE)
-        else if (block.content == "meanrowsum") {
-            bm[i, j, k] <- mean(apply(d[i, b == j, b == k, drop = FALSE], 
-                2, sum, na.rm = TRUE))
-        }
-        else if (block.content == "meancolsum") {
-            bm[i, j, k] <- mean(apply(d[i, b == j, b == k, drop = FALSE], 
-                3, sum, na.rm = TRUE))
-        }
-        else if (block.content == "sum") {
-            bm[i, j, k] <- sum(d[i, b == j, b == k, drop = FALSE], 
-                na.rm = TRUE)
-        }
-        else if (block.content == "median") {
-            bm[i, j, k] <- median(d[i, b == j, b == k, drop = FALSE], 
-                na.rm = TRUE)
+            numplot = c(numplot, 0)
         }
-        else if (block.content == "min") {
-            bm[i, j, k] <- min(d[i, b == j, b == k, drop = FALSE], 
-                na.rm = TRUE)
+        if (sum(numplot) == 0) 
+            stop("Biotype or chromosome information is needed for this plot\n")
+        if (sum(numplot) == 1) {
+            par(mar = c(10, 4, 2, 2))
+            if (numplot[1] == 1) {
+                barplot(biotable1[c(1, 3), ], main = "DEG distribution across chromosomes", 
+                  xlab = NULL, ylab = "%features", axis.lty = 1, 
+                  legend = FALSE, beside = TRUE, col = c("grey", 
+                    2), las = 2, ylim = c(0, ymaxL1), border = c("grey", 
+                    2))
+                barplot(biotable1[c(2, 4), ], main = "DEG distribution across chromosomes", 
+                  xlab = NULL, ylab = "%features", axis.lty = 1, 
+                  legend = FALSE, beside = TRUE, col = c(2, 1), 
+                  las = 2, density = 30, ylim = c(0, ymaxL1), 
+                  border = 2, add = TRUE)
+                legend(x = "topright", bty = "n", horiz = FALSE, 
+                  fill = c("grey", 2, 2), density = c(NA, 30, 
+                    NA), border = c("grey", 2, 2), legend = c("%Chrom in genome", 
+                    "%DEG in Chrom", "%Chrom in DEG"))
+            }
+            if (numplot[2] == 1) {
+                barplot(biotable2[c(1, 3), ], main = "DEG distribution across biotypes", 
+                  xlab = NULL, ylab = "%features", axis.lty = 1, 
+                  legend = FALSE, beside = TRUE, col = c("grey", 
+                    4), las = 2, ylim = c(0, ymaxL2), border = c("grey", 
+                    4))
+                barplot(biotable2[c(2, 4), ], main = "DEG distribution across biotypes", 
+                  xlab = NULL, ylab = "%features", axis.lty = 1, 
+                  legend = FALSE, beside = TRUE, col = c(4, 1), 
+                  las = 2, density = 30, ylim = c(0, ymaxL2), 
+                  border = 4, add = TRUE)
+                axis(side = 4, at = pretty(c(0, ymaxL2), n = 5), 
+                  labels = round(pretty(c(0, ymaxL2), n = 5) * 
+                    ymaxR2/ymaxL2, 1))
+                if (ymaxR2 != ymaxL2) {
+                  abline(v = 3 * length(higher2) + 0.5, col = 3, 
+                    lwd = 2, lty = 2)
+                }
+                legend(x = "topright", bty = "n", horiz = FALSE, 
+                  fill = c("grey", 4, 4), density = c(NA, 30, 
+                    NA), border = c("grey", 4, 4), legend = c("%Biotype in genome", 
+                    "%DEG in Biotype", "%Biotype in DEG"))
+            }
+        }
+        if (sum(numplot) == 2) {
+            par(mar = c(10, 4, 2, 2), mfrow = c(1, 2))
+            barplot(biotable1[c(1, 3), ], main = "DEG distribution across chromosomes", 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c("grey", 
+                  2), las = 2, ylim = c(0, ymaxL1), border = c("grey", 
+                  2))
+            barplot(biotable1[c(2, 4), ], main = "DEG distribution across chromosomes", 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c(2, 1), 
+                las = 2, density = 30, ylim = c(0, ymaxL1), border = 2, 
+                add = TRUE)
+            legend(x = "topright", bty = "n", horiz = FALSE, 
+                fill = c("grey", 2, 2), density = c(NA, 30, NA), 
+                border = c("grey", 2, 2), legend = c("%Chrom in genome", 
+                  "%DEG in Chrom", "%Chrom in DEG"))
+            barplot(biotable2[c(1, 3), ], main = "DEG distribution across biotypes", 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c("grey", 
+                  4), las = 2, ylim = c(0, ymaxL2), border = c("grey", 
+                  4))
+            barplot(biotable2[c(2, 4), ], main = "DEG distribution across biotypes", 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c(4, 1), 
+                las = 2, density = 30, ylim = c(0, ymaxL2), border = 4, 
+                add = TRUE)
+            axis(side = 4, at = pretty(c(0, ymaxL2), n = 5), 
+                labels = round(pretty(c(0, ymaxL2), n = 5) * 
+                  ymaxR2/ymaxL2, 1))
+            if (ymaxR2 != ymaxL2) {
+                abline(v = 3 * length(higher2) + 0.5, col = 3, 
+                  lwd = 2, lty = 2)
+            }
+            legend(x = "topright", bty = "n", horiz = FALSE, 
+                fill = c("grey", 4, 4), density = c(NA, 30, NA), 
+                border = c("grey", 4, 4), legend = c("%Biotype in genome", 
+                  "%DEG in Biotype", "%Biotype in DEG"))
+        }
+    }
+    par(mypar)
+}
+
+GC.dat (closure) = function (input, factor = NULL, norm = FALSE) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object\n")
+    if (!is.null(assayData(input)$exprs)) 
+        datos <- assayData(input)$exprs
+    else datos <- assayData(input)$counts
+    ceros = which(rowSums(datos) == 0)
+    if (length(ceros) > 0) {
+        print(paste("Warning:", length(ceros), "features with 0 counts in all samples are to be removed for this analysis."))
+        datos = datos[-ceros, ]
+    }
+    nsam <- NCOL(datos)
+    if (nsam == 1) 
+        datos <- as.matrix(datos)
+    if (is.null(factor)) {
+        print("GC content bias detection is to be computed for:")
+        print(colnames(datos))
+    }
+    else {
+        mifactor = as.factor(pData(input)[, factor])
+        niveles = levels(mifactor)
+        print("GC content bias detection is to be computed for:")
+        print(niveles)
+        if (norm) {
+            datos = sapply(niveles, function(k) {
+                rowMeans(as.matrix(datos[, mifactor == k]))
+            })
         }
-        else if (block.content == "max") {
-            bm[i, j, k] <- max(d[i, b == j, b == k, drop = FALSE], 
-                na.rm = TRUE)
+        else {
+            datos = sapply(niveles, function(k) {
+                rowMeans(t(10^6 * t(datos[, mifactor == k])/colSums(as.matrix(datos[, 
+                  mifactor == k]))))
+            })
         }
-        else if (block.content == "types") {
-            temp <- mean(d[i, b == j, b == k, drop = FALSE], 
+        colnames(datos) = niveles
+    }
+    if (any(!is.na(featureData(input)$GC)) == FALSE) 
+        stop("GC content was not provided.\nPlease run addData() function to add \n          this information\n")
+    GC <- as.numeric(as.character(featureData(input)$GC))
+    if (length(ceros) > 0) 
+        GC = GC[-ceros]
+    if (!is.null(featureData(input)$Biotype)) {
+        infobio <- as.character(featureData(input)$Biotype)
+        if (length(ceros) > 0) 
+            infobio = infobio[-ceros]
+        biotypes <- unique(infobio)
+        names(biotypes) <- biotypes
+        biog <- lapply(biotypes, function(x) {
+            which(is.element(infobio, x))
+        })
+        names(biog) = biotypes
+        bionum <- c(NROW(datos), sapply(biog, length))
+        names(bionum) <- c("global", names(biotypes))
+    }
+    else {
+        infobio = NULL
+        biotypes = NULL
+        bionum = NULL
+    }
+    GCexpr = vector("list", length = 1 + length(biotypes))
+    names(GCexpr) = c("global", names(biotypes))
+    numXbin = 200
+    for (i in 1:length(GCexpr)) {
+        if (i == 1) {
+            numdatos = length(GC)
+            numbins = floor(numdatos/numXbin)
+            misbins = quantile(GC, probs = seq(0, 1, 1/numbins), 
                 na.rm = TRUE)
-            if (is.nan(temp)) 
-                bm[i, j, k] <- "NA"
-            else if (temp == 0) 
-                bm[i, j, k] <- "null"
-            else if (temp == 1) 
-                bm[i, j, k] <- "complete"
-            else if (all(apply(d[i, b == j, b == k, drop = FALSE], 
-                2, sum, na.rm = TRUE) > 0, apply(d[i, b == j, 
-                b == k, drop = FALSE], 3, sum, na.rm = TRUE) > 
-                0)) 
-                bm[i, j, k] <- "1 covered"
-            else if (all(apply(d[i, b == j, b == k, drop = FALSE], 
-                2, sum, na.rm = TRUE) > 0)) 
-                bm[i, j, k] <- "1 row-covered"
-            else if (all(apply(d[i, b == j, b == k, drop = FALSE], 
-                3, sum, na.rm = TRUE) > 0)) 
-                bm[i, j, k] <- "1 col-covered"
-            else bm[i, j, k] <- "other"
-        }
-    }
-    if (inherits(ec, "equiv.clust")) 
-        pord <- ec$cluster$order
-    else if (inherits(ec, "hclust")) 
-        pord <- ec$order
-    else pord <- order(ec)
-    o <- list()
-    o$block.membership <- b[pord]
-    o$order.vector <- pord
-    o$block.content <- block.content
-    if (length(dim(dat)) > 2) {
-        o$blocked.data <- dat[, pord, pord]
-        dimnames(o$blocked.data) <- list(glabels, plabels[pord], 
-            plabels[pord])
-    }
-    else {
-        o$blocked.data <- dat[pord, pord]
-        dimnames(o$blocked.data) <- list(plabels[pord], plabels[pord])
-    }
-    if (dim(bm)[1] == 1) {
-        o$block.model <- bm[1, , ]
-        rownames(o$block.model) <- rlabels
-        colnames(o$block.model) <- rlabels
-    }
-    else {
-        o$block.model <- bm
-        dimnames(o$block.model) <- list(glabels, rlabels, rlabels)
-    }
-    o$plabels <- plabels[pord]
-    o$glabels <- glabels
-    o$rlabels <- rlabels
-    o$cluster.method <- switch(class(ec)[1], equiv.clust = ec$cluster.method, 
-        hclust = ec$method, "Prespecified")
-    o$equiv.fun <- switch(class(ec)[1], equiv.clust = ec$equiv.fun, 
-        "None")
-    o$equiv.metric <- switch(class(ec)[1], equiv.clust = ec$metric, 
-        "None")
-    class(o) <- "blockmodel"
-    o
-}
-
-blockmodel.expand (closure) = function (b, ev, mode = "digraph", diag = FALSE) 
-{
-    en <- sum(ev)
-    el <- length(ev)
-    bn <- max(b$block.membership)
-    bm <- stackcount(b$block.model)
-    if (bm > 1) 
-        block.model <- b$block.model
-    else {
-        block.model <- array(dim = c(1, bn, bn))
-        block.model[1, , ] <- b$block.model
-    }
-    expanded <- array(dim = c(bm, en, en))
-    for (i in 1:bm) {
-        if (b$block.content == "density") {
-            tp <- matrix(nrow = en, ncol = en)
-            for (j in 1:el) for (k in 1:el) tp[(cumsum(ev)[j] - 
-                ev[j] + 1):(cumsum(ev)[j]), (cumsum(ev)[k] - 
-                ev[k] + 1):(cumsum(ev)[k])] <- block.model[i, 
-                j, k]
-            tp[is.na(tp) | is.nan(tp)] <- 0
-            expanded[i, , ] <- rgraph(en, 1, tprob = tp, mode = mode, 
-                diag = diag)
-        }
-        else stop(paste("\nContent type", b$block.content, "not supported yet.\n"))
-    }
-    if (dim(expanded)[1] > 1) 
-        expanded
-    else expanded[1, , ]
-}
-
-bn (closure) = function (dat, method = c("mple.triad", "mple.dyad", "mple.edge", 
-    "mtle"), param.seed = NULL, param.fixed = NULL, optim.method = "BFGS", 
-    optim.control = list(), epsilon = 1e-05) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = FALSE)
-    if (is.list(dat)) 
-        return(lapply(dat, bn, method = method, param.seed = param.seed, 
-            param.fixed = param.fixed, optim.method = optim.method, 
-            optim.contol = optim.control, epsilon = epsilon))
-    else if (length(dim(dat)) > 2) 
-        return(apply(dat, 1, bn, method = method, param.seed = param.seed, 
-            param.fixed = param.fixed, optim.method = optim.method, 
-            optim.contol = optim.control, epsilon = epsilon))
-    n <- NROW(dat)
-    if (!is.matrix(dat)) 
-        stop("Adjacency matrix required in bn.")
-    dat <- dat > 0
-    nll <- switch(match.arg(method), mple.edge = match.fun("bn.nlpl.edge"), 
-        mple.dyad = match.fun("bn.nlpl.dyad"), mple.triad = match.fun("bn.nlpl.triad"), 
-        mtle = match.fun("bn.nltl"))
-    if (match.arg(method) %in% c("mple.edge", "mple.dyad")) {
-        stats <- matrix(0, nrow = n - 1, ncol = 4)
-        stats <- matrix(.C("bn_dyadstats_R", as.integer(dat), 
-            as.double(n), stats = as.double(stats), PACKAGE = "sna")$stats, 
-            ncol = 4)
-        stats <- stats[apply(stats[, 2:4], 1, sum) > 0, ]
-    }
-    else if (match.arg(method) == "mple.triad") {
-        stats <- matrix(0, nrow = n, ncol = n)
-        stats <- matrix(.C("bn_triadstats_R", as.integer(dat), 
-            as.double(n), stats = as.double(stats), PACKAGE = "sna")$stats, 
-            nrow = n, ncol = n)
-    }
-    else if (match.arg(method) == "mtle") {
-        stats <- as.vector(triad.census(dat))
-    }
-    if (is.null(param.seed)) 
-        param <- c(gden(dat), grecip(dat, measure = "edgewise"), 
-            gtrans(dat), gtrans(dat))
-    else {
-        param <- c(gden(dat), grecip(dat, measure = "edgewise"), 
-            gtrans(dat), gtrans(dat))
-        if (!is.null(param.seed$pi)) 
-            param[1] <- param.seed$pi
-        if (!is.null(param.seed$sigma)) 
-            param[2] <- param.seed$sigma
-        if (!is.null(param.seed$rho)) 
-            param[3] <- param.seed$rho
-        if (!is.null(param.seed$d)) 
-            param[4] <- param.seed$d
-    }
-    if (is.null(param.fixed)) 
-        fixed <- rep(NA, 4)
-    else {
-        fixed <- rep(NA, 4)
-        if (!is.null(param.fixed$pi)) 
-            fixed[1] <- param.fixed$pi
-        if (!is.null(param.fixed$sigma)) 
-            fixed[2] <- param.fixed$sigma
-        if (!is.null(param.fixed$rho)) 
-            fixed[3] <- param.fixed$rho
-        if (!is.null(param.fixed$d)) 
-            fixed[4] <- param.fixed$d
-    }
-    param <- pmax(pmin(param, 1 - epsilon), epsilon)
-    param <- log(param/(1 - param))
-    fit <- optim(param, nll, method = optim.method, control = optim.control, 
-        stats = stats, fixed = fixed, dat = dat)
-    fit$par <- 1/(1 + exp(-fit$par))
-    fit$par[!is.na(fixed)] <- fixed[!is.na(fixed)]
-    out <- list(d = fit$par[4], pi = fit$par[1], sigma = fit$par[2], 
-        rho = fit$par[3], method = match.arg(method), G.square = 2 * 
-            fit$value, epsilon = epsilon)
-    if (match.arg(method) == "mtle") 
-        out$triads <- stats
-    else out$triads <- as.vector(triad.census(dat))
-    out$triads.pred <- .C("bn_ptriad_R", as.double(out$pi), as.double(out$sigma), 
-        as.double(out$rho), as.double(out$d), pt = as.double(rep(0, 
-            16)), PACKAGE = "sna")$pt
-    names(out$triads.pred) <- c("003", "012", "102", "021D", 
-        "021U", "021C", "111D", "111U", "030T", "030C", "201", 
-        "120D", "120U", "120C", "210", "300")
-    names(out$triads) <- names(out$triads.pred)
-    if (match.arg(method) %in% c("mple.edge", "mple.dyad")) 
-        out$dyads <- apply(stats[, -1], 2, sum)
-    else out$dyads <- as.vector(dyad.census(dat))
-    out$dyads.pred <- c(sum(out$triads.pred * c(0, 0, 1, 0, 0, 
-        0, 1, 1, 0, 0, 2, 1, 1, 1, 2, 3)), sum(out$triads.pred * 
-        c(0, 1, 0, 2, 2, 2, 1, 1, 3, 3, 0, 2, 2, 2, 1, 0)), sum(out$triads.pred * 
-        c(3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0))) * 
-        choose(n, 3)/choose(n, 2)/(n - 2)
-    names(out$dyads.pred) <- c("Mut", "Asym", "Null")
-    names(out$dyads) <- names(out$dyads.pred)
-    out$edges <- c(2 * out$dyads[1] + out$dyads[2], 2 * out$dyads[3] + 
-        out$dyads[2])
-    out$edges.pred <- c(2 * out$dyads.pred[1] + out$dyads.pred[2], 
-        2 * out$dyads.pred[3] + out$dyads.pred[2])/2
-    names(out$edges.pred) <- c("Present", "Absent")
-    names(out$edges) <- names(out$edges.pred)
-    a <- out$d * (n - 1)
-    out$ss.pred <- c(1/n, (1 - 1/n) * (1 - exp(-a/n)))
-    for (i in 2:(n - 1)) out$ss.pred <- c(out$ss.pred, (1 - sum(out$ss.pred[1:i])) * 
-        (1 - exp(-(a - out$pi - out$sigma * (a - 1)) * out$ss.pred[i])))
-    out$ss.pred <- cumsum(out$ss.pred)
-    names(out$ss.pred) <- 0:(n - 1)
-    out$ss <- structure.statistics(dat)
-    class(out) <- "bn"
-    out
-}
-
-bn.nlpl.dyad (closure) = function (p, stats, fixed = rep(NA, 4), ...) 
-{
-    p <- 1/(1 + exp(-p))
-    p[!is.na(fixed)] <- fixed[!is.na(fixed)]
-    lpl <- 0
-    lpl <- .C("bn_lpl_dyad_R", as.double(stats), as.double(NROW(stats)), 
-        as.double(p[1]), as.double(p[2]), as.double(p[3]), as.double(p[4]), 
-        lpl = as.double(lpl), PACKAGE = "sna")$lpl
-    -lpl
-}
-
-bn.nlpl.edge (closure) = function (p, stats, fixed = rep(NA, 4), ...) 
-{
-    p <- 1/(1 + exp(-p))
-    p[!is.na(fixed)] <- fixed[!is.na(fixed)]
-    lp <- cbind(1 - (1 - p[1]) * ((1 - p[3])^stats[, 1]) * ((1 - 
-        p[2])^stats[, 1]) * (1 - p[4]), 1 - ((1 - p[2])^stats[, 
-        1]) * (1 - p[4]))
-    lp <- log(cbind(lp, 1 - lp))
-    lpl <- cbind(2 * stats[, 2] * lp[, 1], stats[, 3] * lp[, 
-        2], stats[, 3] * lp[, 3], 2 * stats[, 4] * lp[, 4])
-    lpl[is.nan(lpl)] <- 0
-    -sum(lpl)
-}
-
-bn.nlpl.triad (closure) = function (p, dat, stats, fixed = rep(NA, 4), ...) 
-{
-    p <- 1/(1 + exp(-p))
-    p[!is.na(fixed)] <- fixed[!is.na(fixed)]
-    lpl <- 0
-    lpl <- .C("bn_lpl_triad_R", as.integer(dat), as.double(stats), 
-        as.double(NROW(stats)), as.double(p[1]), as.double(p[2]), 
-        as.double(p[3]), as.double(p[4]), lpl = as.double(lpl), 
-        PACKAGE = "sna")$lpl
-    -lpl
-}
-
-bn.nltl (closure) = function (p, stats, fixed = rep(NA, 4), ...) 
-{
-    p <- 1/(1 + exp(-p))
-    p[!is.na(fixed)] <- fixed[!is.na(fixed)]
-    pt <- rep(0, 16)
-    triprob <- .C("bn_ptriad_R", as.double(p[1]), as.double(p[2]), 
-        as.double(p[3]), as.double(p[4]), pt = as.double(pt), 
-        PACKAGE = "sna")$pt
-    -sum(stats * log(triprob))
-}
-
-bonpow (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, exponent = 1, rescale = FALSE, tol = 1e-07) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], bonpow, g = 1, nodes = nodes, gmode = gmode, 
-            diag = diag, tmaxdev = tmaxdev, exponent = exponent, 
-            rescale = rescale, tol = tol))
-    else if ((length(g) > 1) && (length(dim(dat)) > 2)) 
-        return(apply(dat[g, , ], 1, bonpow, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, exponent = exponent, 
-            rescale = rescale, tol = tol))
-    if (tmaxdev) {
-        if (gmode == "graph") 
-            ev <- (dim(dat)[2] - 2) * sqrt(dim(dat)[2]/2)
-        else ev <- sqrt(dim(dat)[2]) * (dim(dat)[2] - 1)
-    }
-    else {
-        if (length(dim(dat)) > 2) 
-            d <- dat[g, , ]
-        else d <- dat
-        n <- dim(d)[1]
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (!diag) 
-            diag(d) <- 0
-        id <- matrix(rep(0, n * n), nrow = n)
-        diag(id) <- 1
-        ev <- apply(solve(id - exponent * d, tol = tol) %*% d, 
-            1, sum)
-        ev <- ev * sqrt(n/sum((ev)^2))
-        if (rescale) 
-            ev <- ev/sum(ev)
-        ev[nodes]
-    }
-    ev
-}
-
-brokerage (closure) = function (g, cl) 
-{
-    g <- as.edgelist.sna(g)
-    if (is.list(g)) 
-        return(lapply(g, brokerage, cl))
-    N <- attr(g, "n")
-    m <- NROW(g)
-    classes <- unique(cl)
-    icl <- match(cl, classes)
-    br <- matrix(0, N, 5)
-    br <- matrix(.C("brokerage_R", as.double(g), as.integer(N), 
-        as.integer(m), as.integer(icl), brok = as.double(br), 
-        PACKAGE = "sna", NAOK = TRUE)$brok, N, 5)
-    br <- cbind(br, apply(br, 1, sum))
-    gbr <- apply(br, 2, sum)
-    d <- m/(N * (N - 1))
-    clid <- unique(cl)
-    n <- vector()
-    for (i in clid) n <- c(n, sum(cl == i))
-    n <- as.double(n)
-    N <- as.double(N)
-    ebr <- matrix(0, length(clid), 6)
-    vbr <- matrix(0, length(clid), 6)
-    for (i in 1:length(clid)) {
-        ebr[i, 1] <- d^2 * (1 - d) * (n[i] - 1) * (n[i] - 2)
-        vbr[i, 1] <- ebr[i, 1] * (1 - d^2 * (1 - d)) + 2 * (n[i] - 
-            1) * (n[i] - 2) * (n[i] - 3) * d^3 * (1 - d)^3
-        ebr[i, 2] <- d^2 * (1 - d) * sum(n[-i] * (n[-i] - 1))
-        vbr[i, 2] <- ebr[i, 2] * (1 - d^2 * (1 - d)) + 2 * sum(n[-i] * 
-            (n[-i] - 1) * (n[-i] - 2)) * d^3 * (1 - d)^3
-        ebr[i, 3] <- d^2 * (1 - d) * (N - n[i]) * (n[i] - 1)
-        vbr[i, 3] <- ebr[i, 3] * (1 - d^2 * (1 - d)) + 2 * ((n[i] - 
-            1) * choose(N - n[i], 2) + (N - n[i]) * choose(n[i] - 
-            1, 2)) * d^3 * (1 - d)^3
-        ebr[i, 4] <- ebr[i, 3]
-        vbr[i, 4] <- vbr[i, 3]
-        ebr[i, 5] <- d^2 * (1 - d) * (sum((n[-i]) %o% (n[-i])) - 
-            sum(n[-i]^2))
-        vbr[i, 5] <- ebr[i, 5] * (1 - d^2 * (1 - d)) + 4 * sum(n[-i] * 
-            choose(N - n[-i] - n[i], 2) * d^3 * (1 - d)^3)
-        ebr[i, 6] <- d^2 * (1 - d) * (N - 1) * (N - 2)
-        vbr[i, 6] <- ebr[i, 6] * (1 - d^2 * (1 - d)) + 2 * (N - 
-            1) * (N - 2) * (N - 3) * d^3 * (1 - d)^3
-    }
-    br.exp <- vector()
-    br.sd <- vector()
-    for (i in 1:N) {
-        temp <- match(cl[i], clid)
-        br.exp <- rbind(br.exp, ebr[temp, ])
-        br.sd <- rbind(br.sd, sqrt(vbr[temp, ]))
-    }
-    br.z <- (br - br.exp)/br.sd
-    egbr <- vector()
-    vgbr <- vector()
-    egbr[1] <- d^2 * (1 - d) * sum(n * (n - 1) * (n - 2))
-    vgbr[1] <- egbr[1] * (1 - d^2 * (1 - d)) + sum(n * (n - 1) * 
-        (n - 2) * (((4 * n - 10) * d^3 * (1 - d)^3) - (4 * (n - 
-        3) * d^4 * (1 - d)^2) + ((n - 3) * d^5 * (1 - d))))
-    egbr[2] <- d^2 * (1 - d) * sum(n * (N - n) * (n - 1))
-    vgbr[2] <- egbr[2] * (1 - d^2 * (1 - d)) + (sum(outer(n, 
-        n, function(x, y) {
-            x * y * (x - 1) * (((2 * x + 2 * y - 6) * d^3 * (1 - 
-                d)^3) + ((N - x - 1) * d^5 * (1 - d)))
-        })) - sum(n * n * (n - 1) * (((4 * n - 6) * d^3 * (1 - 
-        d)^3) + ((N - n - 1) * d^5 * (1 - d)))))
-    egbr[3] <- d^2 * (1 - d) * sum(n * (N - n) * (n - 1))
-    vgbr[3] <- egbr[3] * (1 - d^2 * (1 - d)) + sum(n * (N - n) * 
-        (n - 1) * (((N - 3) * d^3 * (1 - d)^3) + ((n - 2) * d^5 * 
-        (1 - d))))
-    egbr[4] <- egbr[3]
-    vgbr[4] <- vgbr[3]
-    egbr[5] <- d^2 * (1 - d) * (sum(outer(n, n, function(x, y) {
-        x * y * (N - x - y)
-    })) - sum(n * n * (N - 2 * n)))
-    vgbr[5] <- egbr[5] * (1 - d^2 * (1 - d))
-    for (i in 1:length(n)) for (j in 1:length(n)) for (k in 1:length(n)) if ((i != 
-        j) && (j != k) && (i != k)) 
-        vgbr[5] <- vgbr[5] + n[i] * n[j] * n[k] * ((4 * (N - 
-            n[j]) - 2 * (n[i] + n[k] + 1)) * d^3 * (1 - d)^3 - 
-            (4 * (N - n[k]) - 2 * (n[i] + n[j] + 1)) * d^4 * 
-                (1 - d)^2 + (N - (n[i] + n[k] + 1)) * d^5 * (1 - 
-            d))
-    egbr[6] <- d^2 * (1 - d) * N * (N - 1) * (N - 2)
-    vgbr[6] <- egbr[6] * (1 - d^2 * (1 - d)) + N * (N - 1) * 
-        (N - 2) * (((4 * N - 10) * d^3 * (1 - d)^3) - (4 * (N - 
-        3) * d^4 * (1 - d)^2) + ((N - 3) * d^5 * (1 - d)))
-    br.nam <- c("w_I", "w_O", "b_IO", "b_OI", "b_O", "t")
-    colnames(br) <- br.nam
-    rownames(br) <- attr(g, "vnames")
-    colnames(br.exp) <- br.nam
-    rownames(br.exp) <- attr(g, "vnames")
-    colnames(br.sd) <- br.nam
-    rownames(br.sd) <- attr(g, "vnames")
-    colnames(br.z) <- br.nam
-    rownames(br.z) <- attr(g, "vnames")
-    names(gbr) <- br.nam
-    names(egbr) <- br.nam
-    names(vgbr) <- br.nam
-    colnames(ebr) <- br.nam
-    rownames(ebr) <- clid
-    colnames(vbr) <- br.nam
-    rownames(vbr) <- clid
-    out <- list(raw.nli = br, exp.nli = br.exp, sd.nli = br.sd, 
-        z.nli = br.z, raw.gli = gbr, exp.gli = egbr, sd.gli = sqrt(vgbr), 
-        z.gli = (gbr - egbr)/sqrt(vgbr), exp.grp = ebr, sd.grp = sqrt(vbr), 
-        cl = cl, clid = clid, n = n, N = N)
-    class(out) <- "brokerage"
-    out
-}
-
-centralgraph (closure) = function (dat, normalize = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in centralgraph.")
-    if (length(dim(dat)) == 2) 
-        out <- dat
-    else {
-        if (normalize) 
-            out <- apply(dat, c(2, 3), mean, na.rm = TRUE)
-        else out <- matrix(data = as.numeric(apply(dat, c(2, 
-            3), mean, na.rm = TRUE) >= 0.5), nrow = dim(dat)[2], 
-            ncol = dim(dat)[2])
-    }
-    out
-}
-
-centralization (closure) = function (dat, FUN, g = NULL, mode = "digraph", diag = FALSE, 
-    normalize = TRUE, ...) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(mapply(centralization, dat[g], MoreArgs = list(FUN = FUN, 
-            g = 1, mode = mode, diag = diag, normalize = normalize, 
-            ...)))
-    }
-    fun <- match.fun(FUN)
-    cv <- fun(dat, g = g, gmode = mode, diag = diag, ...)
-    cmax <- max(cv)
-    cent <- sum(cmax - cv)
-    if (normalize) 
-        cent <- cent/fun(dat, g = g, gmode = mode, diag = diag, 
-            tmaxdev = TRUE, ...)
-    cent
-}
-
-clique.census (closure) = function (dat, mode = "digraph", tabulate.by.vertex = TRUE, clique.comembership = c("none", 
-    "sum", "bysize"), enumerate = TRUE, na.omit = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, clique.census, mode = mode, tabulate.by.vertex = tabulate.by.vertex, 
-            clique.comembership = clique.comembership, enumerate = enumerate, 
-            na.omit = na.omit))
-    n <- attr(dat, "n")
-    if (is.null(attr(dat, "vnames"))) 
-        vnam <- paste("v", 1:n, sep = "")
-    else vnam <- attr(dat, "vnames")
-    if (na.omit) 
-        dat <- dat[!is.na(dat[, 3]), , drop = FALSE]
-    else dat[is.na(dat[, 3]), 3] <- 1
-    dat <- dat[dat[, 1] != dat[, 2], ]
-    attr(dat, "n") <- n
-    if (mode == "digraph") 
-        dat <- symmetrize(dat, rule = "strong", return.as.edgelist = TRUE)
-    clique.comembership <- switch(match.arg(clique.comembership), 
-        none = 0, sum = 1, bysize = 2)
-    census <- .Call("cliques_R", dat, n, NROW(dat), tabulate.by.vertex, 
-        clique.comembership, enumerate, PACKAGE = "sna")
-    maxsize <- census[[1]]
-    census <- census[-1]
-    names(census) <- c("clique.count", "clique.comemb", "cliques")
-    if (tabulate.by.vertex) {
-        census[[1]] <- matrix(census[[1]], maxsize, n + 1)
-        census[[1]] <- census[[1]][, c(n + 1, 1:n), drop = FALSE]
-        rownames(census[[1]]) <- 1:maxsize
-        colnames(census[[1]]) <- c("Agg", vnam)
-    }
-    else {
-        names(census[[1]]) <- 1:length(census[[1]])
-    }
-    if (clique.comembership == 1) {
-        census[[2]] <- matrix(census[[2]], n, n)
-        rownames(census[[2]]) <- vnam
-        colnames(census[[2]]) <- vnam
-    }
-    else if (clique.comembership == 2) {
-        census[[2]] <- array(census[[2]], dim = c(maxsize, n, 
-            n))
-        dimnames(census[[2]]) <- list(1:maxsize, vnam, vnam)
-    }
-    pres <- c(TRUE, clique.comembership > 0, enumerate > 0)
-    census[pres]
-}
-
-closeness (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "directed", geodist.precomp = NULL, 
-    rescale = FALSE, ignore.eval = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], closeness, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            geodist.precomp = geodist.precomp, rescale = rescale, 
-            ignore.eval = ignore.eval))
-    n <- attr(dat, "n")
-    if (gmode == "graph") {
-        cmode <- switch(cmode, directed = "undirected", undirected = "undirected", 
-            suminvdir = "siminvundir", suminvundir = "suminvundir", 
-            `gil-schmidt` = "gil-schmidt")
-    }
-    if (tmaxdev) {
-        clo <- switch(cmode, directed = (n - 1) * (1 - 1/n), 
-            undirected = (n - 2) * (n - 1)/(2 * n - 3), suminvdir = (n - 
-                1) * (n - 1), suminvundir = n - 1 - n/2, `gil-schmidt` = (n - 
-                1) * (gmode == "digraph") + (n - 2)/2 * (gmode == 
-                "graph"))
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode %in% c("undirected", "suminvundir")) 
-            dat <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-        if (is.null(geodist.precomp)) 
-            gd <- geodist(dat, count.paths = FALSE, predecessors = FALSE, 
-                ignore.eval = ignore.eval)
-        else gd <- geodist.precomp
-        diag(gd$gdist) <- NA
-        clo <- switch(cmode, directed = (n - 1)/rowSums(gd$gdist, 
-            na.rm = TRUE), undirected = (n - 1)/rowSums(gd$gdist, 
-            na.rm = TRUE), suminvdir = rowSums(1/gd$gdist, na.rm = TRUE)/(n - 
-            1), suminvundir = rowSums(1/gd$gdist, na.rm = TRUE)/(n - 
-            1), `gil-schmidt` = apply(gd$gdist, 1, function(z) {
-            ids <- sum(1/z, na.rm = TRUE)
-            r <- sum(z < Inf, na.rm = TRUE)
-            gs <- ids/r
-            gs[r == 0] <- 0
-            gs
-        }))
-        if (rescale) 
-            clo <- clo/sum(clo)
-        clo <- clo[nodes]
-    }
-    clo
-}
-
-coef.bn (closure) = function (object, ...) 
-{
-    coef <- c(object$d, object$pi, object$sigma, object$rho)
-    names(coef) <- c("d", "pi", "sigma", "rho")
-    coef
-}
-
-coef.lnam (closure) = function (object, ...) 
-{
-    coefs <- vector()
-    if (!is.null(object$beta)) {
-        coefs <- c(coefs, object$beta)
-    }
-    if (!is.null(object$rho1)) {
-        coefs <- c(coefs, object$rho1)
-    }
-    if (!is.null(object$rho2)) {
-        coefs <- c(coefs, object$rho2)
-    }
-    coefs
-}
-
-component.dist (closure) = function (dat, connected = c("strong", "weak", "unilateral", 
-    "recursive")) 
-{
-    if (match.arg(connected) %in% c("strong", "weak", "recursive")) 
-        dat <- as.edgelist.sna(dat)
-    else dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, component.dist, connected = connected))
-    else if (length(dim(dat)) > 2) 
-        return(apply(dat, 1, component.dist, connected = connected))
-    if (match.arg(connected) %in% c("strong", "weak", "recursive")) {
-        n <- attr(dat, "n")
-        dat <- switch(match.arg(connected), weak = symmetrize(dat, 
-            rule = "weak", return.as.edgelist = TRUE), strong = symmetrize(reachability(dat, 
-            return.as.edgelist = TRUE), rule = "strong", return.as.edgelist = TRUE), 
-            recursive = symmetrize(dat, rule = "strong", return.as.edgelist = TRUE))
-        memb <- .C("undirComponents_R", as.double(dat), as.integer(n), 
-            as.integer(NROW(dat)), memb = integer(n + 1), PACKAGE = "sna", 
-            NAOK = TRUE)$memb
-        csize <- tabulate(memb[-1], memb[1])
-        cdist <- rep(0, n)
-        cdist[1:max(csize)] <- tabulate(csize, max(csize))
-        memb <- memb[-1]
-    }
-    else {
-        n <- dim(dat)[2]
-        dat <- reachability(dat)
-        if (any(dat != t(dat))) 
-            warning("Nonunique unilateral component partition detected in component.dist.  Problem vertices will be arbitrarily assigned to one of their components.\n")
-        memb <- .C("component_dist_R", as.double(dat), as.double(n), 
-            memb = as.double(rep(0, n)), PACKAGE = "sna", NAOK = TRUE)$memb
-        csize <- tabulate(memb, max(memb))
-        cdist <- rep(0, n)
-        cdist[1:max(csize)] <- tabulate(csize, max(csize))
-    }
-    o <- list(membership = memb, csize = csize, cdist = cdist)
-    o
-}
-
-component.largest (closure) = function (dat, connected = c("strong", "weak", "unilateral", 
-    "recursive"), result = c("membership", "graph"), return.as.edgelist = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, component.largest, connected = connected, 
-            result = result))
-    if (attr(dat, "n") == 1) {
-        if (match.arg(result) == "membership") {
-            return(TRUE)
-        }
-        else {
-            if (return.as.edgelist) 
-                return(dat)
-            else return(as.sociomatrix.sna(dat))
-        }
-    }
-    cd <- component.dist(dat, connected = connected)
-    lgcmp <- which(cd$csize == max(cd$csize))
-    if (match.arg(result) == "membership") {
-        cd$membership %in% lgcmp
-    }
-    else {
-        tokeep <- which(cd$membership %in% lgcmp)
-        ovn <- attr(dat, "vnames")
-        if (is.null(ovn)) 
-            ovn <- 1:attr(dat, "n")
-        if (return.as.edgelist) {
-            sel <- rowSums(apply(dat, 1:2, function(z) {
-                z %in% tokeep
-            })) == 2
-            dat <- dat[sel, , drop = FALSE]
-            if (NROW(dat) > 0) {
-                dat[, 1:2] <- apply(dat, 1:2, function(z) {
-                  match(z, tokeep)
-                })
+            if (length(misbins) != length(unique(misbins))) {
+                repes = names(table(misbins))[which(table(misbins) > 
+                  1)]
+                for (rr in repes) {
+                  cuantos = length(which(misbins == rr))
+                  cuales = which(misbins == rr)
+                  sumo = (misbins[cuales[1] + cuantos] - misbins[cuales[1]])/cuantos
+                  for (j in cuales[-1]) misbins[j] = misbins[j - 
+                    1] + sumo
+                }
             }
-            attr(dat, "n") <- length(tokeep)
-            attr(dat, "vnames") <- ovn[tokeep]
-            dat
+            miclasi = cut(GC, breaks = misbins, labels = FALSE)
+            misbins = sapply(1:numbins, function(i) mean(misbins[i:(i + 
+                1)]))
+            miclasi = misbins[miclasi]
+            GCexpr[[i]] = aggregate(datos, by = list(GCbin = miclasi), 
+                mean, trim = 0.025)
         }
         else {
-            as.sociomatrix.sna(dat)[tokeep, tokeep, drop = FALSE]
+            datos2 = datos[biog[[i - 1]], ]
+            GC2 = GC[biog[[i - 1]]]
+            if (bionum[i] >= numXbin * 10) {
+                numdatos = length(GC2)
+                numbins = floor(numdatos/numXbin)
+                misbins = quantile(GC2, probs = seq(0, 1, 1/numbins), 
+                  na.rm = TRUE)
+                if (length(misbins) != length(unique(misbins))) {
+                  repes = names(table(misbins))[which(table(misbins) > 
+                    1)]
+                  for (rr in repes) {
+                    cuantos = length(which(misbins == rr))
+                    cuales = which(misbins == rr)
+                    sumo = (misbins[cuales[1] + cuantos] - misbins[cuales[1]])/cuantos
+                    for (j in cuales[-1]) misbins[j] = misbins[j - 
+                      1] + sumo
+                  }
+                }
+                miclasi = cut(GC2, breaks = misbins, labels = FALSE)
+                misbins = sapply(1:numbins, function(i) mean(misbins[i:(i + 
+                  1)]))
+                miclasi = misbins[miclasi]
+                GCexpr[[i]] = aggregate(datos2, by = list(GCbin = miclasi), 
+                  mean, trim = 0.025, na.rm = TRUE)
+            }
+            else {
+                GCexpr[[i]] = cbind(GC2, datos2)
+            }
         }
     }
+    datos = GCexpr[[1]]
+    GCcont = datos[, 1]
+    knots = c(rep(GCcont[1], 3), seq(GCcont[1], GCcont[length(GCcont) - 
+        1], length.out = round(length(GCcont)/10, 0)), rep(GCcont[length(GCcont)], 
+        4))
+    bx = splineDesign(knots, GCcont, outer.ok = TRUE)
+    mismodelos = vector("list", length = ncol(datos) - 1)
+    names(mismodelos) = colnames(datos)[-1]
+    for (i in 2:ncol(datos)) {
+        print(colnames(datos)[i])
+        mismodelos[[i - 1]] = lm(datos[, i] ~ bx)
+        print(summary(mismodelos[[i - 1]]))
+    }
+    list(data2plot = GCexpr, RegressionModels = mismodelos)
 }
 
-component.size.byvertex (closure) = function (dat, connected = c("strong", "weak", "unilateral", 
-    "recursive")) 
+GC.plot (closure) = function (dat, samples = NULL, toplot = "global", toreport = FALSE, 
+    ...) 
 {
-    g <- as.edgelist.sna(dat)
-    if (is.list(g)) {
-        return(lapply(g, component.size.byvertex, connected = connected))
-    }
-    if (match.arg(connected) %in% c("weak", "recursive")) {
-        if (match.arg(connected) == "weak") 
-            rule <- "weak"
-        else rule <- "strong"
-        g <- symmetrize(g, rule = rule, return.as.edgelist = TRUE)
-        cs <- .C("compsizes_R", as.double(g), as.integer(attr(g, 
-            "n")), as.integer(NROW(g)), csizes = integer(attr(g, 
-            "n")), PACKAGE = "sna", NAOK = TRUE)$csizes
-    }
-    else {
-        cd <- component.dist(dat, connected = match.arg(connected))
-        cs <- cd$csize[cd$membership]
-    }
-    cs
-}
-
-components (closure) = function (dat, connected = "strong", comp.dist.precomp = NULL) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, components, connected = connected, 
-            comp.dist.precomp = comp.dist.precomp))
-    if (!is.null(comp.dist.precomp)) 
-        cd <- comp.dist.precomp
-    else cd <- component.dist(dat, connected = connected)
-    length(unique(cd$membership))
-}
-
-connectedness (closure) = function (dat, g = NULL) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(sapply(dat[g], connectedness))
-    }
-    g <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-    n <- attr(g, "n")
-    m <- NROW(g)
-    if (n <= 1) 
-        con <- 1
-    else con <- .C("connectedness_R", as.double(g), as.integer(n), 
-        as.integer(m), con = as.double(0), PACKAGE = "sna", NAOK = TRUE)$con
-    con
-}
-
-consensus (closure) = function (dat, mode = "digraph", diag = FALSE, method = "central.graph", 
-    tol = 1e-06, maxiter = 1000, verbose = TRUE, no.bias = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("consensus requires graphs of identical order.")
-    if (is.matrix(dat)) 
-        m <- 1
-    else m <- dim(dat)[1]
-    n <- dim(dat)[2]
-    if (m == 1) 
-        dat <- array(dat, dim = c(1, n, n))
-    if (mode == "graph") 
-        d <- upper.tri.remove(dat)
-    else d <- dat
-    if (!diag) 
-        d <- diag.remove(d)
-    if (method == "central.graph") {
-        cong <- centralgraph(d)
-    }
-    else if (method == "iterative.reweight") {
-        cong <- centralgraph(d)
-        ans <- sweep(d, c(2, 3), cong, "==")
-        comp <- pmax(apply(ans, 1, mean, na.rm = TRUE), 0.5)
-        if (no.bias) 
-            bias <- rep(0.5, length(comp))
-        else bias <- apply(sweep(d, c(2, 3), !ans, "*"), 1, mean, 
-            na.rm = TRUE)
-        cdiff <- 1 + tol
-        iter <- 1
-        while ((cdiff > tol) && (iter < maxiter)) {
-            ll1 <- apply(sweep(d, 1, log(comp + (1 - comp) * 
-                bias), "*") + sweep(1 - d, 1, log((1 - comp) * 
-                (1 - bias)), "*"), c(2, 3), sum, na.rm = TRUE)
-            ll0 <- apply(sweep(1 - d, 1, log(comp + (1 - comp) * 
-                (1 - bias)), "*") + sweep(d, 1, log((1 - comp) * 
-                bias), "*"), c(2, 3), sum, na.rm = TRUE)
-            cong <- ll1 > ll0
-            ans <- sweep(d, c(2, 3), cong, "==")
-            ocomp <- comp
-            comp <- pmax(apply(ans, 1, mean, na.rm = TRUE), 0.5)
-            bias <- apply(sweep(d, c(2, 3), !ans, "*"), 1, mean, 
-                na.rm = TRUE)
-            cdiff <- sum(abs(ocomp - comp))
-            iter <- iter + 1
-        }
-        if (verbose) {
-            cat("Estimated competency scores:\n")
-            print(comp)
-            cat("Estimated bias parameters:\n")
-            print(bias)
-        }
-    }
-    else if (method == "single.reweight") {
-        gc <- gcor(d)
-        gc[is.na(gc)] <- 0
-        diag(gc) <- 1
-        rwv <- apply(gc, 1, sum)
-        rwv <- rwv/sum(rwv)
-        cong <- apply(d * aperm(array(sapply(rwv, rep, n^2), 
-            dim = c(n, n, m)), c(3, 2, 1)), c(2, 3), sum)
-    }
-    else if (method == "PCA.reweight") {
-        gc <- gcor(d)
-        gc[is.na(gc)] <- 0
-        diag(gc) <- 1
-        rwv <- abs(eigen(gc)$vector[, 1])
-        cong <- apply(d * aperm(array(sapply(rwv, rep, n^2), 
-            dim = c(n, n, m)), c(3, 2, 1)), c(2, 3), sum)
-    }
-    else if (method == "romney.batchelder") {
-        d <- d[!apply(is.na(d), 1, all), , ]
-        if (length(dim(d)) < 3) 
-            stop("Insufficient informant information.")
-        drate <- apply(d, 1, mean, na.rm = TRUE)
-        cong <- apply(d, c(2, 3), mean, na.rm = TRUE) > 0.5
-        s1 <- mean(cong, na.rm = TRUE)
-        s0 <- mean(1 - cong, na.rm = TRUE)
-        correct <- sweep(d, c(2, 3), cong, "==")
-        correct <- apply(correct, 1, mean, na.rm = TRUE)
-        comp <- pmax(2 * correct - 1, 0)
-        if (no.bias) 
-            bias <- rep(0.5, length(comp))
-        else {
-            bias <- pmin(pmax((drate - s1 * comp)/(1 - comp), 
-                0), 1)
-            bias[comp == 1] <- 0.5
-        }
-        ocomp <- comp + tol + 1
-        iter <- 1
-        while ((max(abs(ocomp - comp), na.rm = TRUE) > tol) && 
-            (iter < maxiter)) {
-            ocomp <- comp
-            ll1 <- apply(sweep(d, 1, log(comp + (1 - comp) * 
-                bias), "*") + sweep(1 - d, 1, log((1 - comp) * 
-                (1 - bias)), "*"), c(2, 3), sum, na.rm = TRUE)
-            ll0 <- apply(sweep(1 - d, 1, log(comp + (1 - comp) * 
-                (1 - bias)), "*") + sweep(d, 1, log((1 - comp) * 
-                bias), "*"), c(2, 3), sum, na.rm = TRUE)
-            cong <- ll1 > ll0
-            s1 <- mean(cong, na.rm = TRUE)
-            s0 <- mean(1 - cong, na.rm = TRUE)
-            correct <- sweep(d, c(2, 3), cong, "==")
-            correct <- apply(correct, 1, mean, na.rm = TRUE)
-            comp <- pmax((correct - s1 * bias - s0 * (1 - bias))/(1 - 
-                s1 * bias - s0 * (1 - bias)), 0)
-            if (!no.bias) 
-                bias <- pmin(pmax((drate - s1 * comp)/(1 - comp), 
-                  0), 1)
-        }
-        if (verbose) {
-            cat("Estimated competency scores:\n")
-            print(comp)
-            cat("Estimated bias parameters:\n")
-            print(bias)
-        }
-    }
-    else if (method == "LAS.intersection") {
-        cong <- matrix(0, n, n)
-        for (i in 1:n) for (j in 1:n) cong[i, j] <- as.numeric(d[i, 
-            i, j] && d[j, i, j])
-    }
-    else if (method == "LAS.union") {
-        cong <- matrix(0, n, n)
-        for (i in 1:n) for (j in 1:n) cong[i, j] <- as.numeric(d[i, 
-            i, j] || d[j, i, j])
-    }
-    else if (method == "OR.row") {
-        cong <- matrix(0, n, n)
-        for (i in 1:n) cong[i, ] <- d[i, i, ]
-    }
-    else if (method == "OR.col") {
-        cong <- matrix(0, n, n)
-        for (i in 1:n) cong[, i] <- d[i, , i]
-    }
-    if (mode == "graph") 
-        cong[upper.tri(cong)] <- t(cong)[upper.tri(cong)]
-    if (!diag) 
-        diag(cong) <- 0
-    cong
-}
-
-cug.test (closure) = function (dat, FUN, mode = c("digraph", "graph"), cmode = c("size", 
-    "edges", "dyad.census"), diag = FALSE, reps = 1000, ignore.eval = TRUE, 
-    FUN.args = list()) 
-{
-    if (ignore.eval) {
-        dat <- as.edgelist.sna(dat)
-        if (is.list(dat)) 
-            return(sapply(dat, cug.test, FUN = FUN, mode = mode, 
-                cmode = cmode, diag = diag, reps = reps, ignore.eval = ignore.eval, 
-                FUN.args = FUN.args))
-        n <- attr(dat, "n")
-        if (!diag) {
-            dat <- dat[dat[, 1] != dat[, 2], , drop = FALSE]
-            attr(dat, "n") <- n
-            ndiag <- 0
-        }
-        else ndiag <- sum(dat[, 1] == dat[, 2])
-        mode <- match.arg(mode)
-        cmode <- match.arg(cmode)
-        if (cmode == "size") {
-            m <- NULL
-            dc <- NULL
-        }
-        else if (cmode == "edges") {
-            m <- switch(match.arg(mode), graph = (NROW(dat) - 
-                ndiag)/2 + ndiag, digraph = NROW(dat))
-            dc <- NULL
-        }
-        else if (cmode == "dyad.census") {
-            m <- NULL
-            dc <- dyad.census(dat)
-        }
-        getstat <- function(d) {
-            do.call(fun, c(list(d), FUN.args))
-        }
-        drawrep <- switch(cmode, size = function(n, ...) {
-            rgraph(n, 1, mode = mode, diag = diag, tprob = 0.5, 
-                return.as.edgelist = TRUE)
-        }, edges = function(n, m, ...) {
-            rgnm(n = 1, nv = n, m = m, mode = mode, diag = diag, 
-                return.as.edgelist = TRUE)
-        }, dyad.census = function(n, dc, ...) {
-            rguman(n = 1, nv = n, mut = dc[1], asym = dc[2], 
-                null = dc[3], method = "exact", return.as.edgelist = TRUE)
-        }, )
-    }
-    else {
-        dat <- as.sociomatrix.sna(dat)
-        if (is.list(dat)) 
-            return(sapply(dat, cug.test, FUN = FUN, mode = mode, 
-                cmode = cmode, diag = diag, reps = reps, ignore.eval = ignore.eval, 
-                FUN.args = FUN.args))
-        else if (length(dim(dat)) > 2) 
-            return(apply(dat, 1, cug.test, FUN = FUN, mode = mode, 
-                cmode = cmode, diag = diag, reps = reps, ignore.eval = ignore.eval, 
-                FUN.args = FUN.args))
-        n <- NROW(dat)
-        m <- NULL
-        dc <- NULL
-        mode <- match.arg(mode)
-        cmode <- match.arg(cmode)
-        getstat <- function(d) {
-            do.call(fun, c(list(d), FUN.args))
-        }
-        drawrep <- switch(cmode, size = function(n, ...) {
-            rgraph(n, 1, mode = mode, diag = diag, tprob = 0.5)
-        }, edges = switch(mode, digraph = function(n, ...) {
-            g <- dat
-            g[upper.tri(g, diag = diag) | lower.tri(g)] <- sample(g[upper.tri(g, 
-                diag = diag) | lower.tri(g)])
-            g
-        }, graph = function(n, ...) {
-            g <- dat
-            g[upper.tri(g, diag = diag)] <- sample(g[upper.tri(g, 
-                diag = diag)])
-            g[lower.tri(g)] <- t(g)[lower.tri(g)]
-            g
-        }), dyad.census = function(n, ...) {
-            g <- rewire.ud(dat, 1)[1, , ]
-            if (diag) diag(g) <- sample(diag(g))
-            g
-        }, )
-    }
-    fun <- match.fun(FUN)
-    if ("mode" %in% names(formals(fun))) 
-        callmode <- TRUE
-    else callmode <- FALSE
-    if ("diag" %in% names(formals(fun))) 
-        calldiag <- TRUE
-    else calldiag <- FALSE
-    if (callmode) 
-        FUN.args$mode <- mode
-    if (calldiag) 
-        FUN.args$diag <- diag
-    obs <- getstat(dat)
-    repstats <- vector()
-    for (i in 1:reps) {
-        repstats[i] <- getstat(drawrep(n = n, m = m, dc = dc))
-    }
-    out <- list(obs.stat = obs, rep.stat = repstats, mode = mode, 
-        diag = diag, cmode = cmode, plteobs = mean(repstats <= 
-            obs), pgteobs = mean(repstats >= obs), reps = reps)
-    class(out) <- "cug.test"
-    out
-}
-
-cugtest (closure) = function (dat, FUN, reps = 1000, gmode = "digraph", cmode = "density", 
-    diag = FALSE, g1 = 1, g2 = 2, ...) 
-{
-    out <- list()
-    dat <- as.sociomatrix.sna(dat)
-    fun <- match.fun(FUN)
-    out$testval <- fun(dat, g1 = g1, g2 = g2, ...)
-    if (cmode == "density") {
-        d <- c(gden(dat, g = g1, mode = gmode, diag = diag), 
-            gden(dat, g = g2, mode = gmode, diag = diag))
-    }
-    else if (cmode == "ties") {
-        if (is.list(dat)) {
-            tie1 <- dat[[g1]]
-            tie2 <- dat[[g2]]
-        }
-        else {
-            tie1 <- dat[g1, , ]
-            tie2 <- dat[g2, , ]
+    datos = dat[["data2plot"]]
+    mismodelos = dat[["RegressionModels"]]
+    if (is.null(samples)) 
+        samples <- 1:(ncol(datos[[1]]) - 1)
+    if (length(samples) > 12) 
+        stop("Please select 12 samples or less to be plotted.")
+    if (is.numeric(samples)) {
+        samples = colnames(datos[[1]])[samples + 1]
+    }
+    if (is.numeric(toplot)) {
+        if (toplot == 1) {
+            toplot = "global"
+        }
+        else {
+            toplot = names(toplot)[toplot + 1]
+        }
+    }
+    if ((toplot == "global") && (length(samples) <= 2)) {
+        if ((!toreport) && (length(samples) == 2)) 
+            par(mfrow = c(1, 2))
+        for (i in 1:length(samples)) {
+            matplot(datos[[1]][, 1], cbind(datos[[1]][, samples[i]], 
+                mismodelos[[samples[i]]]$fit), type = "pl", main = samples[i], 
+                pch = 20, lty = 1, lwd = 2, col = c(1, 4), ylab = "Mean expression", 
+                xlab = "GC content bins", ylim = c(0, max(datos[[1]][, 
+                  samples[i]])), ...)
+            text(max(datos[[1]][, 1]), 0.2 * max(datos[[1]][, 
+                samples[i]]), col = 4, adj = 1, paste("R2 = ", 
+                100 * round(summary(mismodelos[[samples[i]]])$r.squared, 
+                  4), "%", sep = ""))
+            laF = summary(mismodelos[[samples[i]]])$fstatistic
+            text(max(datos[[1]][, 1]), 0.1 * max(datos[[1]][, 
+                samples[i]]), col = 4, adj = 1, paste("p-value:", 
+                signif(pf(laF[1], df1 = laF[2], df2 = laF[3], 
+                  lower.tail = FALSE), 2)))
         }
     }
     else {
-        d <- c(0.5, 0.5)
-    }
-    if (is.list(dat)) {
-        n1 <- dim(dat[[g1]])[2]
-        n2 <- dim(dat[[g2]])[2]
-    }
-    else {
-        n1 <- dim(dat)[2]
-        n2 <- dim(dat)[2]
-    }
-    out$dist <- vector(mode = "numeric", length = reps)
-    for (i in 1:reps) {
-        if (cmode == "ties") {
-            dat1 <- rgraph(n1, diag = diag, mode = gmode, tielist = tie1)
-            dat2 <- rgraph(n2, diag = diag, mode = gmode, tielist = tie2)
-        }
-        else {
-            dat1 <- rgraph(n1, tprob = d[1], diag = diag, mode = gmode)
-            dat2 <- rgraph(n2, tprob = d[2], diag = diag, mode = gmode)
-        }
-        if (n1 == n2) {
-            datc <- array(dim = c(2, n1, n1))
-            datc[1, , ] <- dat1
-            datc[2, , ] <- dat2
-        }
-        else datc <- list(dat1, dat2)
-        out$dist[i] <- fun(datc, g1 = 1, g2 = 2, ...)
-    }
-    out$pgreq <- mean(as.numeric(out$dist >= out$testval))
-    out$pleeq <- mean(as.numeric(out$dist <= out$testval))
-    class(out) <- c("cugtest", "cug")
-    out
-}
-
-cutpoints (closure) = function (dat, mode = "digraph", connected = c("strong", "weak", 
-    "recursive"), return.indicator = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, cutpoints, mode = mode, connected = connected, 
-            return.indicator = return.indicator))
-    n <- attr(dat, "n")
-    dat <- dat[dat[, 1] != dat[, 2], ]
-    attr(dat, "n") <- n
-    cp <- rep(0, n)
-    if (mode == "graph") 
-        cp <- .C("cutpointsUndir_R", as.double(dat), as.integer(n), 
-            as.integer(NROW(dat)), cp = as.integer(cp), NAOK = TRUE, 
-            PACKAGE = "sna")$cp
-    else {
-        dat <- switch(match.arg(connected), strong = dat, weak = symmetrize(dat, 
-            rule = "weak", return.as.edgelist = TRUE), recursive = symmetrize(dat, 
-            rule = "strong", return.as.edgelist = TRUE))
-        if (match.arg(connected) == "strong") 
-            cp <- .C("cutpointsDir_R", as.double(dat), as.integer(n), 
-                as.integer(NROW(dat)), cp = as.integer(cp), NAOK = TRUE, 
-                PACKAGE = "sna")$cp
-        else cp <- .C("cutpointsUndir_R", as.double(dat), as.integer(n), 
-            as.integer(NROW(dat)), cp = as.integer(cp), NAOK = TRUE, 
-            PACKAGE = "sna")$cp
-    }
-    if (!return.indicator) 
-        return(which(cp > 0))
-    else {
-        if (is.null(attr(dat, "vnames"))) 
-            names(cp) <- 1:n
-        else names(cp) <- attr(dat, "vnames")
-        return(cp > 0)
-    }
-}
-
-degree (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "freeman", rescale = FALSE, ignore.eval = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], degree, g = 1, nodes = nodes, gmode = gmode, 
-            diag = diag, tmaxdev = tmaxdev, cmode = cmode, rescale = rescale))
-    n <- attr(dat, "n")
-    if (gmode == "graph") 
-        cmode <- "indegree"
-    if (tmaxdev) {
-        if (gmode == "digraph") 
-            deg <- switch(cmode, indegree = (n - 1) * (n - 1 + 
-                diag), outdegree = (n - 1) * (n - 1 + diag), 
-                freeman = (n - 1) * (2 * (n - 1) - 2 + diag))
-        else deg <- switch(cmode, indegree = (n - 1) * (n - 2 + 
-            diag), outdegree = (n - 1) * (n - 2 + diag), freeman = (n - 
-            1) * (2 * (n - 1) - 2 + diag))
-    }
-    else {
-        m <- NROW(dat)
-        cm <- switch(cmode, indegree = 0, outdegree = 1, freeman = 2)
-        if (!(cmode %in% c("indegree", "outdegree", "freeman"))) 
-            stop("Unknown cmode in degree.\n")
-        deg <- .C("degree_R", as.double(dat), as.integer(m), 
-            as.integer(cm), as.integer(diag), as.integer(ignore.eval), 
-            deg = as.double(rep(0, n)), PACKAGE = "sna", NAOK = TRUE)$deg
-        if (rescale) 
-            deg <- deg/sum(deg)
-        if (!is.null(nodes)) 
-            deg <- deg[nodes]
-    }
-    deg
-}
-
-diag.remove (closure) = function (dat, remove.val = NA) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, diag.remove, remove.val = remove.val))
-    if (length(dim(dat)) > 2) {
-        d <- dat
-        for (i in 1:dim(dat)[1]) diag(d[i, , ]) <- remove.val
-    }
-    else {
-        d <- dat
-        diag(d) <- remove.val
-    }
-    d
-}
-
-dyad.census (closure) = function (dat, g = NULL) 
-{
-    intcalc <- function(m) {
-        n <- attr(m, "n")
-        m <- m[m[, 1] != m[, 2], , drop = FALSE]
-        if (NROW(m) > 0) {
-            dc <- .C("dyadcode_R", as.double(m), as.integer(n), 
-                as.integer(NROW(m)), dc = as.double(rep(0, NROW(m))), 
-                PACKAGE = "sna", NAOK = TRUE)$dc
-            mis <- is.na(m[, 3])
-            if (any(mis)) {
-                mis[dc %in% c(dc[mis])] <- TRUE
-                dcm <- dc[mis]
-                dmut <- sum(duplicated(dcm))
-                dasym <- length(dcm) - 2 * dmut
-                mc <- dmut + dasym
-                dc <- dc[!mis]
-            }
-            else mc <- 0
-            mut <- sum(duplicated(dc))
-            asym <- length(dc) - 2 * mut
-            c(mut, asym, choose(n, 2) - mut - asym - mc)
-        }
-        else c(0, 0, choose(n, 2))
-    }
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        man <- t(sapply(dat[g], intcalc))
-    }
-    else {
-        man <- intcalc(dat)
-    }
-    if (length(man) == 3) 
-        man <- matrix(man, nrow = 1)
-    colnames(man) <- c("Mut", "Asym", "Null")
-    man
-}
-
-efficiency (closure) = function (dat, g = NULL, diag = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(sapply(dat[g], efficiency, diag = diag))
-    }
-    inteff <- function(g, diag) {
-        comsz <- component.dist(g, connected = "weak")$csize
-        reqedge <- sum(comsz - 1)
-        maxv <- sum(comsz * (comsz - (!diag)) - (comsz - 1))
-        if (!diag) 
-            g <- diag.remove(g)
-        edgec <- sum(g, na.rm = TRUE)
-        1 - (edgec - reqedge)/maxv
-    }
-    if (length(dim(dat)) > 2) {
-        if (is.null(g)) 
-            g <- 1:dim(dat)[1]
-        eff <- apply(dat[g, , , drop = FALSE], 1, inteff, diag = diag)
-    }
-    else eff <- inteff(dat, diag = diag)
-    eff
-}
-
-ego.extract (closure) = function (dat, ego = NULL, neighborhood = c("combined", "in", 
-    "out")) 
-{
-    d <- as.sociomatrix.sna(dat)
-    if (is.list(d)) 
-        return(lapply(d, ego.extract, ego = ego, neighborhood = neighborhood))
-    else if (length(dim(dat)) == 3) 
-        return(apply(d, 1, ego.extract, ego = ego, neighborhood = neighborhood))
-    if (is.null(ego)) 
-        ego <- 1:NROW(d)
-    neighborhood <- match.arg(neighborhood)
-    enet <- list()
-    for (i in 1:length(ego)) {
-        sel <- switch(neighborhood, `in` = (1:NROW(d))[d[, ego[i]] > 
-            0], out = (1:NROW(d))[d[ego[i], ] > 0], combined = (1:NROW(d))[(d[ego[i], 
-            ] > 0) | (d[, ego[i]] > 0)])
-        if (length(sel) > 0) 
-            sel <- c(ego[i], sel[sel != ego[i]])
-        else sel <- ego[i]
-        enet[[i]] <- d[sel, sel, drop = FALSE]
-    }
-    if (!is.null(rownames(d))) 
-        names(enet) <- rownames(d)[ego]
-    else if (!is.null(colnames(d))) 
-        names(enet) <- colnames(d)[ego]
-    else names(enet) <- ego
-    enet
-}
-
-equiv.clust (closure) = function (dat, g = NULL, equiv.dist = NULL, equiv.fun = "sedist", 
-    method = "hamming", mode = "digraph", diag = FALSE, cluster.method = "complete", 
-    glabels = NULL, plabels = NULL, ...) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.null(g)) {
-        if (is.list(dat)) 
-            g <- 1:length(dat)
-        else if (is.array(dat)) 
-            g <- 1:dim(dat)[1]
-        else g <- 1
-    }
-    if (is.null(equiv.dist)) {
-        equiv.dist.fun <- match.fun(equiv.fun)
-        equiv.dist <- equiv.dist.fun(dat, g = g, method = method, 
-            joint.analysis = TRUE, mode = mode, diag = diag, 
-            code.diss = TRUE, ...)
-    }
-    o <- list()
-    o$cluster <- hclust(as.dist(equiv.dist), method = cluster.method)
-    if (is.null(glabels)) {
-        if (is.list(dat)) 
-            glabels <- names(dat)[g]
-        else glabels <- dimnames(dat)[[1]][g]
-    }
-    if (is.null(plabels)) {
-        if (is.list(dat)) 
-            plabels <- dimnames(dat[[g]])[[2]]
-        else plabels <- dimnames(dat)[[2]]
-    }
-    o$metric <- method
-    o$equiv.fun <- equiv.fun
-    o$cluster.method <- cluster.method
-    if ((length(dim(dat)) == 1) & (length(glabels) > 1)) 
-        o$glabels <- glabels[1]
-    else o$glabels <- glabels
-    o$plabels <- plabels
-    class(o) <- "equiv.clust"
-    o
-}
-
-eval.edgeperturbation (closure) = function (dat, i, j, FUN, ...) 
-{
-    fun <- match.fun(FUN)
-    present <- dat
-    present[i, j] <- 1
-    absent <- dat
-    absent[i, j] <- 0
-    fun(present, ...) - fun(absent, ...)
-}
-
-evcent (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, rescale = FALSE, ignore.eval = FALSE, tol = 1e-10, 
-    maxiter = 1e+05, use.eigen = FALSE) 
-{
-    if (!use.eigen) {
-        dat <- as.edgelist.sna(dat)
-        if (is.list(dat)) 
-            return(sapply(dat[g], evcent, g = 1, nodes = nodes, 
-                gmode = gmode, diag = diag, tmaxdev = tmaxdev, 
-                rescale = rescale, maxiter = maxiter, use.eigen = use.eigen))
-    }
-    else {
-        dat <- as.sociomatrix.sna(dat, simplify = FALSE)
-        if (is.list(dat)) 
-            return(sapply(dat[g], evcent, g = 1, nodes = nodes, 
-                gmode = gmode, diag = diag, tmaxdev = tmaxdev, 
-                rescale = rescale, maxiter = maxiter, use.eigen = use.eigen))
-    }
-    if (use.eigen) 
-        n <- NROW(dat)
-    else n <- attr(dat, "n")
-    if (tmaxdev) {
-        if (gmode == "graph") {
-            ev <- sqrt(2)/2 * (n - 2)
-        }
-        else ev <- n - 1
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (!diag) {
-            if (use.eigen) 
-                diag(dat) <- 0
-            else dat[dat[, 1] == dat[, 2], 3] <- 0
-        }
-        if (use.eigen) {
-            ev <- eigen(dat)$vectors[, 1]
-        }
-        else {
-            ev <- .C("evcent_R", as.double(dat), as.integer(n), 
-                as.integer(NROW(dat)), ev = as.double(rep(1, 
-                  n)), as.double(tol), as.integer(maxiter), as.integer(1), 
-                as.integer(ignore.eval), NAOK = TRUE, PACKAGE = "sna")$ev
-        }
-        if (rescale) 
-            ev <- ev/sum(ev)
-        ev <- ev[nodes]
-    }
-    ev
-}
-
-event2dichot (closure) = function (m, method = "quantile", thresh = 0.5, leq = FALSE) 
-{
-    m <- as.sociomatrix.sna(m)
-    if (is.list(m)) 
-        return(lapply(m, event2dichot, method = method, thresh = thresh, 
-            leq = leq))
-    rnam <- rownames(m)
-    cnam <- colnames(m)
-    if (method == "quantile") {
-        q <- quantile(m, thresh, na.rm = TRUE, names = FALSE)
-        out <- as.numeric(m > q)
-    }
-    else if (method == "rquantile") {
-        q <- quantile(m[1, ], thresh, na.rm = TRUE, names = FALSE)
-        out <- as.numeric(m[1, ] > q)
-        for (i in 2:dim(m)[1]) {
-            q <- quantile(m[i, ], thresh, na.rm = TRUE, names = FALSE)
-            out <- rbind(out, as.numeric(m[i, ] > q))
-        }
-    }
-    else if (method == "cquantile") {
-        q <- quantile(m[, 1], thresh, na.rm = TRUE, names = FALSE)
-        out <- as.numeric(m[, 1] > q)
-        for (i in 2:dim(m)[2]) {
-            q <- quantile(m[, i], thresh, na.rm = TRUE, names = FALSE)
-            out <- cbind(out, as.numeric(m[, i] > q))
-        }
-    }
-    else if (method == "mean") {
-        q <- mean(m)
-        out <- as.numeric(m > q)
-    }
-    else if (method == "rmean") {
-        q <- mean(m[1, ])
-        out <- as.numeric(m[1, ] > q)
-        for (i in 2:dim(m)[1]) {
-            q <- mean(m[i, ])
-            out <- rbind(out, as.numeric(m[i, ] > q))
-        }
-    }
-    else if (method == "cmean") {
-        q <- mean(m[, 1])
-        out <- as.numeric(m[, 1] > q)
-        for (i in 2:dim(m)[2]) {
-            q <- mean(m[, i])
-            out <- rbind(out, as.numeric(m[, i] > q))
-        }
-    }
-    else if (method == "absolute") {
-        out <- as.numeric(m > thresh)
-    }
-    else if (method == "rank") {
-        o <- order(m)
-        out <- as.numeric((max(o) - o + 1) < thresh)
-    }
-    else if (method == "rrank") {
-        o <- order(m[1, ])
-        out <- as.numeric((max(o) - o + 1) < thresh)
-        for (i in 2:dim(m)[1]) {
-            o <- order(m[i, ])
-            out <- rbind(out, as.numeric((max(o) - o + 1) < thresh))
-        }
-    }
-    else if (method == "crank") {
-        o <- order(m[, 1])
-        out <- as.numeric((max(o) - o + 1) < thresh)
-        for (i in 2:dim(m)[2]) {
-            o <- order(m[, i])
-            out <- cbind(out, as.numeric((max(o) - o + 1) < thresh))
-        }
-    }
-    if (leq == TRUE) 
-        out <- 1 - out
-    if (is.null(dim(out)) != is.null(dim(m))) 
-        out <- array(out, dim = dim(m))
-    else if (dim(out) != dim(m)) 
-        out <- array(out, dim = dim(m))
-    rownames(out) <- rnam
-    colnames(out) <- cnam
-    out
-}
-
-flowbet (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "rawflow", rescale = FALSE, ignore.eval = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], flowbet, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            rescale = rescale, ignore.eval = ignore.eval))
-    else if ((length(g) > 1) && (length(dim(dat)) > 2)) 
-        return(apply(dat[g, , ], 1, flowbet, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            rescale = rescale, ignore.eval = ignore.eval))
-    n <- NROW(dat)
-    if (ignore.eval) 
-        dat <- dat > 0
-    if (tmaxdev) {
-        flo <- switch(cmode, rawflow = (n - 1)^2 * (n - 2)/(1 + 
-            (gmode == "graph")), normflow = n - 1, fracflow = (n - 
-            1)^2 * (n - 2)/(1 + (gmode == "graph")))
-    }
-    else {
-        mflow <- function(x, src, snk) {
-            .C("maxflow_EK_R", as.double(x), as.integer(NROW(x)), 
-                as.integer(src - 1), as.integer(snk - 1), flow = as.double(0), 
-                NAOK = TRUE, PACKAGE = "sna")$flow
-        }
-        maxflo <- matrix(Inf, n, n)
-        if (gmode == "digraph") {
-            for (i in 1:n) for (j in 1:n) if (i != j) 
-                maxflo[i, j] <- mflow(dat, i, j)
-        }
-        else {
-            for (i in 1:n) for (j in (i:n)[-1]) maxflo[i, j] <- mflow(dat, 
-                i, j)
-            maxflo[lower.tri(maxflo)] <- t(maxflo)[lower.tri(maxflo)]
-        }
-        if (cmode == "normflow") {
-            flo <- maxflo
-            diag(flo) <- 0
-            maxoflo <- rep(0, n)
-            for (i in 1:n) maxoflo[i] <- sum(flo[-i, -i])
-        }
-        flo <- rep(0, n)
-        for (i in 1:n) {
-            for (j in 1:n) for (k in 1:n) if ((i != j) && (i != 
-                k) && (j != k) && ((gmode == "digraph") || j < 
-                k) && (maxflo[j, k] > 0)) {
-                redflow <- mflow(dat[-i, -i], j - (j > i), k - 
-                  (k > i))
-                flo[i] <- switch(cmode, rawflow = flo[i] + maxflo[j, 
-                  k] - redflow, normflow = flo[i] + maxflo[j, 
-                  k] - redflow, fracflow = flo[i] + (maxflo[j, 
-                  k] - redflow)/maxflo[j, k])
-            }
-        }
-        if (cmode == "normflow") 
-            flo <- flo/maxoflo * (1 + (gmode == "graph"))
-        if (rescale) 
-            flo <- flo/sum(flo)
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        flo <- flo[nodes]
-    }
-    flo
-}
-
-gapply (closure) = function (X, MARGIN, STATS, FUN, ..., mode = "digraph", diag = FALSE, 
-    distance = 1, thresh = 0, simplify = TRUE) 
-{
-    X <- as.sociomatrix.sna(X)
-    if (is.list(X)) 
-        return(lapply(X, gapply, MARGIN, STATS, FUN, ..., mode = mode, 
-            diag = diag, distance = distance, thresh = thresh, 
-            simplify = simplify))
-    else if (length(dim(X)) > 2) {
-        return(apply(X, 1, gapply, MARGIN, STATS, FUN, ..., mode = mode, 
-            diag = diag, distance = distance, thresh = thresh, 
-            simplify = simplify))
-    }
-    fun <- match.fun(FUN)
-    X <- X > thresh
-    if (distance > 1) 
-        X <- geodist(X, inf.replace = Inf)$gdist <= distance
-    if (!diag) 
-        diag(X) <- FALSE
-    if (mode == "graph") 
-        X[lower.tri(X)] <- FALSE
-    if (!is.matrix(STATS)) 
-        STATS <- matrix(STATS, ncol = 1)
-    if (length(MARGIN) == 1) {
-        if (MARGIN == 1) 
-            stats <- apply(X, 1, function(x) {
-                STATS[x, ]
-            })
-        else if (MARGIN == 2) 
-            stats <- apply(X, 2, function(x) {
-                STATS[x, ]
-            })
-    }
-    else if (all(c(1, 2) %in% MARGIN)) 
-        stats <- apply(symmetrize(X, rule = "weak") > 0, 1, function(x) {
-            STATS[x, ]
-        })
-    else stop("MARGIN must be one of 1, 2, or c(1,2) in gapply.  Exiting.\n")
-    if (is.matrix(stats)) 
-        apply(stats, 2, fun, ...)
-    else sapply(stats, fun, ..., simplify = simplify)
-}
-
-gclust.boxstats (closure) = function (h, k, meas, ...) 
-{
-    out <- matrix(nrow = length(meas), ncol = k)
-    gmat <- matrix(nrow = length(meas), ncol = 2)
-    gmat[, 1] <- c(1:length(meas))
-    gmat[, 2] <- cutree(h, k = k)
-    for (i in 1:k) {
-        out[1:length(meas[gmat[gmat[, 2] == i, 1]]), i] <- meas[gmat[gmat[, 
-            2] == i, 1]]
-    }
-    boxplot(data.frame(out), ...)
-}
-
-gclust.centralgraph (closure) = function (h, k, dat, ...) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in gclust.centralgraph.")
-    out <- array(dim = c(k, dim(dat)[2], dim(dat)[2]))
-    gmat <- matrix(nrow = dim(dat)[1], ncol = 2)
-    gmat[, 1] <- c(1:dim(dat)[1])
-    gmat[, 2] <- cutree(h, k = k)
-    for (i in 1:k) out[i, , ] <- centralgraph(dat[gmat[gmat[, 
-        2] == i, 1], , ], ...)
-    out
-}
-
-gcor (closure) = function (dat, dat2 = NULL, g1 = NULL, g2 = NULL, diag = FALSE, 
-    mode = "digraph") 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in gcor.")
-    if (!is.null(dat2)) {
-        dat2 <- as.sociomatrix.sna(dat2)
-        if (is.list(dat2)) 
-            stop("Identical graph orders required in gcor.")
-    }
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (!is.null(dat2)) {
-        if (length(dim(dat)) > 2) 
-            temp1 <- dat
-        else {
-            temp1 <- array(dim = c(1, dim(dat)[2], dim(dat)[2]))
-            temp1[1, , ] <- dat
-        }
-        if (length(dim(dat2)) > 2) 
-            temp2 <- dat2
-        else {
-            temp2 <- array(dim = c(1, dim(dat2)[2], dim(dat2)[2]))
-            temp2[1, , ] <- dat2
-        }
-        if (dim(temp1)[2] > dim(temp2)[2]) 
-            temp2 <- add.isolates(temp2, dim(temp1)[2] - dim(temp2)[2])
-        if (dim(temp2)[2] > dim(temp1)[2]) 
-            temp1 <- add.isolates(temp1, dim(temp2)[2] - dim(temp1)[2])
-        n <- dim(temp1)[2]
-        gn <- dim(temp1)[1] + dim(temp2)[1]
-        gn1 <- dim(temp1)[1]
-        gn2 <- dim(temp2)[1]
-        d <- array(dim = c(gn, n, n))
-        d[1:gn1, , ] <- temp1
-        d[(gn1 + 1):(gn2 + gn1), , ] <- temp2
-        g1 <- 1:gn1
-        g2 <- (gn1 + 1):(gn1 + gn2)
-    }
-    else {
-        d <- dat
-        n <- dim(dat)[2]
-        gn <- dim(dat)[1]
-        gn1 <- length(g1)
-        gn2 <- length(g2)
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    gd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(gd) <- g1
-    colnames(gd) <- g2
-    for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- cor(as.vector(d[g1[i], 
-        , ]), as.vector(d[g2[j], , ]), use = "complete.obs")
-    if ((gn1 == 1) & (gn2 == 1)) 
-        gd[1, 1]
-    else gd
-}
-
-gcov (closure) = function (dat, dat2 = NULL, g1 = NULL, g2 = NULL, diag = FALSE, 
-    mode = "digraph") 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in gcov.")
-    if (!is.null(dat2)) {
-        dat2 <- as.sociomatrix.sna(dat2)
-        if (is.list(dat2)) 
-            stop("Identical graph orders required in gcov.")
-    }
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (!is.null(dat2)) {
-        if (length(dim(dat)) > 2) 
-            temp1 <- dat
-        else {
-            temp1 <- array(dim = c(1, dim(dat)[2], dim(dat)[2]))
-            temp1[1, , ] <- dat
-        }
-        if (length(dim(dat2)) > 2) 
-            temp2 <- dat2
-        else {
-            temp2 <- array(dim = c(1, dim(dat2)[2], dim(dat2)[2]))
-            temp2[1, , ] <- dat2
-        }
-        if (dim(temp1)[2] > dim(temp2)[2]) 
-            temp2 <- add.isolates(temp2, dim(temp1)[2] - dim(temp2)[2])
-        if (dim(temp2)[2] > dim(temp1)[2]) 
-            temp1 <- add.isolates(temp1, dim(temp2)[2] - dim(temp1)[2])
-        n <- dim(temp1)[2]
-        gn <- dim(temp1)[1] + dim(temp2)[1]
-        gn1 <- dim(temp1)[1]
-        gn2 <- dim(temp2)[1]
-        d <- array(dim = c(gn, n, n))
-        d[1:gn1, , ] <- temp1
-        d[(gn1 + 1):(gn2 + gn1), , ] <- temp2
-        g1 <- 1:gn1
-        g2 <- (gn1 + 1):(gn1 + gn2)
-    }
-    else {
-        d <- dat
-        n <- dim(dat)[2]
-        gn <- dim(dat)[1]
-        gn1 <- length(g1)
-        gn2 <- length(g2)
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    gd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(gd) <- g1
-    colnames(gd) <- g2
-    for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- cov(as.vector(d[g1[i], 
-        , ]), as.vector(d[g2[j], , ]), use = "complete.obs")
-    if ((gn1 == 1) & (gn2 == 1)) 
-        gd[1, 1]
-    else gd
-}
-
-gden (closure) = function (dat, g = NULL, diag = FALSE, mode = "digraph", ignore.eval = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(sapply(dat[g], gden, diag = diag, mode = mode, 
-            ignore.eval = ignore.eval))
-    }
-    n <- attr(dat, "n")
-    bip <- attr(dat, "bipartite")
-    if ((!diag) && (!(mode %in% c("hgraph", "twomode")))) 
-        dat <- dat[dat[, 1] != dat[, 2], , drop = FALSE]
-    nmis <- sum(is.na(dat[, 3]))
-    dat <- dat[!is.na(dat[, 3]), , drop = FALSE]
-    if (n == 0) {
-        den <- NaN
-    }
-    else if (n == 1) {
-        if (!diag) 
-            den <- NaN
-        else {
-            if (ignore.eval) 
-                den <- (NROW(dat) > 0)/(1 - nmis)
-            else den <- sum(dat[, 3], na.rm = TRUE)/(1 - nmis)
-        }
-    }
-    else {
-        if (ignore.eval) 
-            count <- NROW(dat)
-        else count <- sum(dat[, 3])
-        nt <- switch(mode, digraph = n * (n - 1) - nmis + diag * 
-            n, graph = n * (n - 1) - nmis + diag * n, hgraph = bip * 
-            (n - bip) - nmis, twomode = bip * (n - bip) - nmis)
-        den <- count/nt
-    }
-    den
-}
-
-gdist.plotdiff (closure) = function (d, meas, method = "manhattan", jitter = TRUE, xlab = "Inter-Graph Distance", 
-    ylab = "Measure Distance", lm.line = FALSE, ...) 
-{
-    md <- dist(meas, method = method)
-    dv <- as.vector(as.dist(d))
-    mdv <- as.vector(md)
-    if (jitter) {
-        dv <- jitter(dv)
-        mdv <- jitter(mdv)
-    }
-    plot(dv, mdv, xlab = xlab, ylab = ylab, ...)
-    abline(lm(mdv ~ dv), col = "red")
-}
-
-gdist.plotstats (closure) = function (d, meas, siz.lim = c(0, 0.15), rescale = "quantile", 
-    display.scale = "radius", display.type = "circleray", cex = 0.5, 
-    pch = 1, labels = NULL, pos = 1, labels.cex = 1, legend = NULL, 
-    legend.xy = NULL, legend.cex = 1, ...) 
-{
-    xy <- cmdscale(as.dist(d))
-    n <- dim(xy)[1]
-    if (is.null(dim(meas))) 
-        m <- matrix(meas, ncol = 1)
-    else m <- meas
-    nm <- dim(m)[2]
-    if (rescale == "quantile") {
-        m <- apply(m, 2, order)
-        m <- sweep(m, 2, apply(m, 2, min))
-        m <- sweep(m, 2, apply(m, 2, max), "/")
-    }
-    else if (rescale == "affine") {
-        m <- sweep(m, 2, apply(m, 2, min))
-        m <- sweep(m, 2, apply(m, 2, max), "/")
-    }
-    else if (rescale == "normalize") {
-        m <- sweep(m, 2, apply(m, 2, max), "/")
-    }
-    if (display.scale == "area") 
-        m <- sqrt(m)
-    msize <- m * siz.lim[2] + siz.lim[1]
-    pwid <- max(xy) - min(xy)
-    msize <- msize * pwid
-    plot(xy, xlab = expression(lambda[1]), ylab = expression(lambda[2]), 
-        cex = cex, pch = pch, xlim = c(min(xy), max(xy)), ylim = c(min(xy), 
-            max(xy)), ...)
-    if (display.type == "poly") {
-        for (i in 1:nm) {
-            for (j in 1:n) {
-                x <- xy[j, 1] + sin(2 * pi * ((0:nm)/nm)) * msize[j, 
-                  i]
-                y <- xy[j, 2] + cos(2 * pi * ((0:nm)/nm)) * msize[j, 
-                  i]
-                lines(x, y, col = i)
-            }
-        }
-    }
-    else if (display.type == "circle") {
-        for (i in 1:nm) {
-            for (j in 1:n) {
-                x <- xy[j, 1] + sin(2 * pi * ((0:500)/500)) * 
-                  msize[j, i]
-                y <- xy[j, 2] + cos(2 * pi * ((0:500)/500)) * 
-                  msize[j, i]
-                lines(x, y, col = i)
-            }
-        }
-    }
-    else if (display.type == "ray") {
-        for (i in 1:nm) {
-            for (j in 1:n) {
-                lines(c(xy[j, 1], xy[j, 1] + sin(2 * pi * ((i - 
-                  1)/nm)) * msize[j, i]), c(xy[j, 2], xy[j, 2] + 
-                  cos(2 * pi * ((i - 1)/nm)) * msize[j, i]), 
-                  col = i)
-            }
-        }
-    }
-    else if (display.type == "polyray") {
-        for (i in 1:nm) {
-            for (j in 1:n) {
-                x <- xy[j, 1] + sin(2 * pi * ((0:nm)/nm)) * msize[j, 
-                  i]
-                y <- xy[j, 2] + cos(2 * pi * ((0:nm)/nm)) * msize[j, 
-                  i]
-                lines(x, y, col = i)
-                lines(c(xy[j, 1], xy[j, 1] + sin(2 * pi * ((i - 
-                  1)/nm)) * msize[j, i]), c(xy[j, 2], xy[j, 2] + 
-                  cos(2 * pi * ((i - 1)/nm)) * msize[j, i]), 
-                  col = i)
-            }
-        }
-    }
-    else if (display.type == "circleray") {
-        for (i in 1:nm) {
-            for (j in 1:n) {
-                x <- xy[j, 1] + sin(2 * pi * ((0:500)/500)) * 
-                  msize[j, i]
-                y <- xy[j, 2] + cos(2 * pi * ((0:500)/500)) * 
-                  msize[j, i]
-                lines(x, y, col = i)
-                lines(c(xy[j, 1], xy[j, 1] + sin(2 * pi * ((i - 
-                  1)/nm)) * msize[j, i]), c(xy[j, 2], xy[j, 2] + 
-                  cos(2 * pi * ((i - 1)/nm)) * msize[j, i]), 
-                  col = i)
-            }
-        }
-    }
-    if (!is.null(labels)) 
-        text(xy[, 1], xy[, 2], labels, pos = pos, cex = labels.cex)
-    if (!is.null(legend)) {
-        if (is.null(legend.xy)) 
-            legend.xy <- c(min(xy), max(xy))
-        legend(legend.xy[1], legend.xy[2], legend = legend, fill = 1:nm, 
-            cex = legend.cex)
-    }
-}
-
-geodist (closure) = function (dat, inf.replace = Inf, count.paths = TRUE, predecessors = FALSE, 
-    ignore.eval = TRUE, na.omit = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, geodist, inf.replace = inf.replace, 
-            ignore.eval = ignore.eval))
-    n <- attr(dat, "n")
-    if (na.omit) 
-        sel <- !is.na(dat[, 3])
-    else sel <- rep(TRUE, NROW(dat))
-    dat <- dat[(dat[, 1] != dat[, 2]) & sel, , drop = FALSE]
-    m <- NROW(dat)
-    if (ignore.eval) 
-        geo <- .Call("geodist_R", dat, n, m, as.integer(1), count.paths, 
-            predecessors, PACKAGE = "sna")
-    else {
-        if (any(dat[!is.na(dat[, 3]), 3] < 0)) 
-            stop("Negative edge values not currently supported in geodist; transform or otherwise alter them to ensure that they are nonnegative.")
-        geo <- .Call("geodist_val_R", dat, n, m, as.integer(1), 
-            count.paths, predecessors, PACKAGE = "sna")
-    }
-    o <- list()
-    if (count.paths) 
-        o$counts <- matrix(geo[[2]], n, n)
-    o$gdist <- matrix(geo[[1]], n, n)
-    o$gdist[o$gdist == Inf] <- inf.replace
-    if (predecessors) 
-        o$predecessors <- geo[[2 + count.paths]]
-    o
-}
-
-gilschmidt (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, normalize = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        return(sapply(dat[g], gilschmidt, normalize = normalize))
-    }
-    g <- dat
-    n <- attr(g, "n")
-    if (tmaxdev) {
-        if (gmode == "digraph") 
-            return(n - 1)
-        else return((n - 2)/2)
-    }
-    gs <- .C("gilschmidt_R", as.double(g), as.integer(n), as.integer(NROW(g)), 
-        scores = double(n), as.integer(normalize), PACKAGE = "sna", 
-        NAOK = TRUE)$scores
-    gs[is.nan(gs)] <- 0
-    if (is.null(nodes)) 
-        nodes <- 1:n
-    gs[nodes]
-}
-
-gliop (closure) = function (dat, GFUN, OP = "-", g1 = 1, g2 = 2, ...) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if ((!is.list(dat)) && (length(dim(dat)) == 2)) 
-        dat <- array(dat, dim = c(1, dim(dat)))
-    fun <- match.fun(GFUN)
-    op <- match.fun(OP)
-    if (is.list(dat)) 
-        op(fun(dat[[g1]], ...), fun(dat[[g2]], ...))
-    else op(fun(dat[g1, , ], ...), fun(dat[g2, , ], ...))
-}
-
-gplot (closure) = function (dat, g = 1, gmode = "digraph", diag = FALSE, label = NULL, 
-    coord = NULL, jitter = TRUE, thresh = 0, thresh.absval = TRUE, 
-    usearrows = TRUE, mode = "fruchtermanreingold", displayisolates = TRUE, 
-    interactive = FALSE, interact.bycomp = FALSE, xlab = NULL, 
-    ylab = NULL, xlim = NULL, ylim = NULL, pad = 0.2, label.pad = 0.5, 
-    displaylabels = !is.null(label), boxed.labels = FALSE, label.pos = 0, 
-    label.bg = "white", vertex.enclose = FALSE, vertex.sides = NULL, 
-    vertex.rot = 0, arrowhead.cex = 1, label.cex = 1, loop.cex = 1, 
-    vertex.cex = 1, edge.col = 1, label.col = 1, vertex.col = NULL, 
-    label.border = 1, vertex.border = 1, edge.lty = NULL, edge.lty.neg = 2, 
-    label.lty = NULL, vertex.lty = 1, edge.lwd = 0, label.lwd = par("lwd"), 
-    edge.len = 0.5, edge.curve = 0.1, edge.steps = 50, loop.steps = 20, 
-    object.scale = 0.01, uselen = FALSE, usecurve = FALSE, suppress.axes = TRUE, 
-    vertices.last = TRUE, new = TRUE, layout.par = NULL, ...) 
-{
-    bellstate <- options()$locatorBell
-    expstate <- options()$expression
-    on.exit(options(locatorBell = bellstate, expression = expstate))
-    options(locatorBell = FALSE, expression = Inf)
-    "%iin%" <- function(x, int) (x >= int[1]) & (x <= int[2])
-    d <- as.edgelist.sna(dat, force.bipartite = (gmode == "twomode"))
-    if (is.list(d)) 
-        d <- d[[g]]
-    n <- attr(d, "n")
-    if (is.null(label)) {
-        if (displaylabels != TRUE) 
-            displaylabels <- FALSE
-        if (!is.null(attr(d, "vnames"))) 
-            label <- attr(d, "vnames")
-        else if ((gmode == "twomode") && (!is.null(attr(d, "bipartite")))) 
-            label <- c(paste("R", 1:attr(d, "bipartite"), sep = ""), 
-                paste("C", (attr(d, "bipartite") + 1):n, sep = ""))
-        else {
-            label <- 1:n
-        }
-    }
-    if (gmode == "graph") {
-        usearrows <- FALSE
+        matplot(datos[[toplot]][, 1], datos[[toplot]][, samples], 
+            xlab = "GC content bins", ylab = "Mean expression", 
+            type = "l", main = toupper(toplot), col = miscolores, 
+            lwd = 2, ylim = range(datos[[toplot]][, -1]), lty = 1, 
+            ...)
+        legend("bottomright", samples, col = miscolores[1:length(samples)], 
+            lwd = 2, bty = "n")
     }
-    else if ((gmode == "twomode") && (!is.null(attr(d, "bipartite")))) {
-        Rn <- attr(d, "bipartite")
-        if (is.null(vertex.col)) 
-            vertex.col <- c(rep(2, Rn), rep(4, n - Rn))
-        if (is.null(vertex.sides)) 
-            vertex.sides <- c(rep(50, Rn), rep(4, n - Rn))
-    }
-    if (is.null(vertex.col)) 
-        vertex.col <- 2
-    if (is.null(vertex.sides)) 
-        vertex.sides <- 50
-    d <- d[!is.na(d[, 3]), , drop = FALSE]
-    if (is.null(edge.lty)) {
-        edge.lty <- rep(1, NROW(d))
-        if (!is.null(edge.lty.neg)) 
-            edge.lty[d[, 3] < 0] <- edge.lty.neg
-    }
-    else {
-        if (length(edge.lty) != NROW(d)) {
-            edge.lty <- rep(edge.lty, NROW(d))
-            if (!is.null(edge.lty.neg)) 
-                edge.lty[d[, 3] < 0] <- edge.lty.neg
+    if ((!toreport) && (length(samples) == 2)) 
+        layout(1)
+}
+
+MD (closure) = function (dat = dat, selec = c(1:nrow(dat))) 
+{
+    pares <- as.matrix(combn(ncol(dat), 2))
+    if (NCOL(pares) > 30) {
+        sub30 <- sample(1:NCOL(pares), size = 30, replace = FALSE)
+        pares <- pares[, sub30]
+    }
+    mm <- NULL
+    dd <- NULL
+    for (i in 1:ncol(pares)) {
+        a <- dat[selec, pares[1, i]]
+        b <- dat[selec, pares[2, i]]
+        mm <- cbind(mm, log(a/b, 2))
+        dd <- cbind(dd, abs(a - b))
+    }
+    list(M = mm, D = dd)
+}
+
+MD.plot (closure) = function (Ms = Ms, Ds = Ds, Mn = Mn, Dn = Dn, xlim = range(Ms, 
+    na.rm = TRUE), ylim = c(0, quantile(Ds, 0.8, na.rm = TRUE)), 
+    tit = "") 
+{
+    plot(Mn, Dn, pch = ".", main = tit, xlab = "M", ylab = "D", 
+        xlim = xlim, ylim = ylim)
+    points(Ms, Ds, col = 2, pch = ".")
+    legend("topright", c("noise", "signal"), col = 1:2, pch = 15, 
+        bg = "lightgrey")
+}
+
+MDbio (closure) = function (dat = dat, selec = c(1:nrow(dat)), param = NULL, a0per = 0.9) 
+{
+    pares <- as.matrix(combn(ncol(dat), 2))
+    mm <- NULL
+    dd <- NULL
+    for (i in 1:ncol(pares)) {
+        a <- dat[selec, pares[1, i]]
+        b <- dat[selec, pares[2, i]]
+        mm <- cbind(mm, log(a/b, 2))
+        dd <- cbind(dd, (a - b))
+    }
+    sd.M = sqrt(param$sd[, 1]^2/(dat[, 1]^2 * log(2)^2 * param$n[1]) + 
+        param$sd[, 2]^2/(dat[, 2]^2 * log(2)^2 * param$n[2]))
+    sd.D = sqrt(param$sd[, 1]^2/param$n[1] + param$sd[, 2]^2/param$n[2])
+    if (is.null(a0per)) {
+        a0.M = a0.D = 0
+    }
+    else {
+        if (a0per == "B") {
+            B = 100
+            a0.M <- B * max(sd.M, na.rm = TRUE)
+            a0.D <- B * max(sd.D, na.rm = TRUE)
+        }
+        else {
+            a0per = as.numeric(a0per)
+            a0.M <- quantile(sd.M, probs = a0per, na.rm = TRUE)
+            a0.D <- quantile(sd.D, probs = a0per, na.rm = TRUE)
+        }
+    }
+    mm <- mm/(a0.M + sd.M)
+    dd <- dd/(a0.D + sd.D)
+    list(M = mm, D = dd)
+}
+
+Output (closure) = function (data, method, k, lc, factor, v, nss, pnr, comparison, 
+    replicates) 
+{
+    new("Output", results = data, method = method, k = k, lc = lc, 
+        factor = factor, v = v, nss = nss, pnr = pnr, comparison = comparison, 
+        replicates = replicates)
+}
+
+PCA.GENES (closure) = function (X) 
+{
+    n <- ncol(X)
+    p <- nrow(X)
+    offset <- apply(X, 2, mean)
+    Xoff <- X - (cbind(matrix(1, p, 1)) %*% rbind(offset))
+    eigen <- eigen(Xoff %*% t(Xoff)/(p - 1))
+    var <- cbind(eigen$values/sum(eigen$values), cumsum(eigen$values/sum(eigen$values)))
+    loadings2 <- eigen$vectors
+    scores2 <- t(Xoff) %*% loadings2
+    normas2 <- sqrt(apply(scores2^2, 2, sum))
+    scores1 <- loadings2 %*% diag(normas2)
+    loadings1 <- scores2 %*% diag(1/normas2)
+    output <- list(eigen, var, scores1, loadings1)
+    names(output) <- c("eigen", "var.exp", "scores", "loadings")
+    output
+}
+
+PCA.dat (closure) = function (input, norm = FALSE, logtransf = FALSE) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object\n")
+    if (!is.null(assayData(input)$exprs)) 
+        datos <- assayData(input)$exprs
+    else datos <- assayData(input)$counts
+    myfactors = pData(input)
+    if (!norm) 
+        datos = rpkm(datos)
+    if (!logtransf) 
+        datos = log2(datos + 1)
+    resultat = PCA.GENES(t(datos))
+    resultat <- list(result = resultat, factors = myfactors, 
+        norm = norm, logtransf = logtransf)
+    resultat
+}
+
+PCA.plot (closure) = function (dat, samples = c(1, 2), plottype = "scores", factor = NULL) 
+{
+    if (is.null(samples)) 
+        samples = 1:2
+    if (plottype == "loadings") {
+        data2plot = dat$result
+        rango = diff(range(data2plot$loadings[, samples]))
+        plot(data2plot$loadings[, samples], col = 1, pch = ".", 
+            xlab = paste("PC", samples[1], round(data2plot$var.exp[samples[1], 
+                1] * 100, 0), "%"), ylab = paste("PC", samples[2], 
+                round(data2plot$var.exp[samples[2], 1] * 100, 
+                  0), "%"), main = "Loadings", xlim = range(data2plot$loadings[, 
+                samples]) + 0.02 * rango * c(-1, 1), ylim = range(data2plot$loadings[, 
+                samples]) + 0.02 * rango * c(-1, 1))
+    }
+    else if (plottype == "scores") {
+        data2plot = dat$result
+        if (is.null(factor)) 
+            factor = 1
+        myfactor = as.character(dat$factors[, factor])
+        condis = unique(myfactor)
+        mypch = c(17:15, 18, 8, 1, 2)
+        mycolors = colors()[c(554, 89, 111, 512, 17, 586, 132, 
+            428, 601, 568, 86, 390)]
+        parapintar = data.frame(col = rep(mycolors, 7), pch = rep(mypch, 
+            12), stringsAsFactors = FALSE)
+        parapintar = parapintar[1:length(condis), ]
+        rownames(parapintar) = condis
+        pch = parapintar[myfactor, "pch"]
+        col = parapintar[myfactor, "col"]
+        rango = diff(range(data2plot$scores[, samples]))
+        plot(data2plot$scores[, samples], col = "white", xlab = paste("PC", 
+            samples[1], round(data2plot$var.exp[samples[1], 1] * 
+                100, 0), "%"), ylab = paste("PC", samples[2], 
+            round(data2plot$var.exp[samples[2], 1] * 100, 0), 
+            "%"), main = "Scores", xlim = range(data2plot$scores[, 
+            samples]) + 0.02 * rango * c(-1, 1), ylim = range(data2plot$scores[, 
+            samples]) + 0.02 * rango * c(-1, 1))
+        points(data2plot$scores[, samples[1]], data2plot$scores[, 
+            samples[2]], pch = pch, col = col, cex = 2.3)
+        legend("topleft", condis, pch = parapintar[, "pch"], 
+            col = parapintar[, "col"], bty = "n")
+    }
+}
+
+QCreport (closure) = function (input, file = NULL, samples = NULL, factor = NULL, 
+    norm = FALSE) 
+{
+    if (is.null(file)) 
+        file <- paste("QCreport", format(Sys.time(), "_%Y%b%d_%H_%M_%S"), 
+            ".pdf", sep = "")
+    QCinfo = data2report(input = input, factor = factor, norm = norm)
+    samples2 = colnames(QCinfo$data$countdist$data2plot)
+    if (is.null(factor)) {
+        if (length(samples) != 2) {
+            stop("ERROR: Factor was not specified and the number of samples to be plotted is not equal to 2.\n\n           Please, either indicate the factor or the two samples to be plotted.\n")
+        }
+        else {
+            niveles = NULL
+            if (is.numeric(samples)) {
+                samples = colnames(QCinfo$data$countdist$data2plot)[samples]
+            }
+        }
+    }
+    else {
+        myfactor = as.factor(pData(input)[, factor])
+        niveles = as.character(unique(myfactor))
+        if (length(niveles) > 2) {
+            if (length(samples) != 2) {
+                stop("ERROR: The factor has more than two levels (conditions).\n\n           Please, specify which two conditions are to be plotted.\n")
+            }
+            else {
+                if (is.numeric(samples)) {
+                  samples = colnames(QCinfo$data$countsampl$result)[samples]
+                }
+                niveles = samples
+            }
         }
-        else {
-            if (!is.null(edge.lty.neg)) 
-                edge.lty[d[, 3] < 0] <- edge.lty.neg
+        if (length(niveles) == 2) {
+            samples = niveles
         }
     }
-    d.raw <- d
-    if (thresh.absval) 
-        d <- d[abs(d[, 3]) > thresh, , drop = FALSE]
-    else d <- d[d[, 3] > thresh, , drop = FALSE]
-    attr(d, "n") <- n
-    if (!is.null(coord)) {
-        x <- coord[, 1]
-        y <- coord[, 2]
-    }
-    else {
-        layout.fun <- try(match.fun(paste("gplot.layout.", mode, 
-            sep = "")), silent = TRUE)
-        if (inherits(layout.fun, "try-error")) 
-            stop("Error in gplot: no layout function for mode ", 
-                mode)
-        temp <- layout.fun(d, layout.par)
-        x <- temp[, 1]
-        y <- temp[, 2]
-    }
-    if (jitter) {
-        x <- jitter(x)
-        y <- jitter(y)
-    }
-    use <- displayisolates | (!is.isolate(d, ego = 1:n))
-    if (is.null(xlab)) 
-        xlab = ""
-    if (is.null(ylab)) 
-        ylab = ""
-    if (is.null(xlim)) 
-        xlim <- c(min(x[use]) - pad, max(x[use]) + pad)
-    if (is.null(ylim)) 
-        ylim <- c(min(y[use]) - pad, max(y[use]) + pad)
-    xrng <- diff(xlim)
-    yrng <- diff(ylim)
-    xctr <- (xlim[2] + xlim[1])/2
-    yctr <- (ylim[2] + ylim[1])/2
-    if (xrng < yrng) 
-        xlim <- c(xctr - yrng/2, xctr + yrng/2)
-    else ylim <- c(yctr - xrng/2, yctr + xrng/2)
-    baserad <- min(diff(xlim), diff(ylim)) * object.scale * 16/(4 + 
-        n^(1/2))
-    if (new) {
-        plot(0, 0, xlim = xlim, ylim = ylim, type = "n", xlab = xlab, 
-            ylab = ylab, asp = 1, axes = !suppress.axes, ...)
-    }
-    vertex.cex <- rep(vertex.cex, length = n)
-    vertex.radius <- rep(baserad * vertex.cex, length = n)
-    vertex.sides <- rep(vertex.sides, length = n)
-    vertex.border <- rep(vertex.border, length = n)
-    vertex.col <- rep(vertex.col, length = n)
-    vertex.lty <- rep(vertex.lty, length = n)
-    vertex.rot <- rep(vertex.rot, length = n)
-    loop.cex <- rep(loop.cex, length = n)
-    label.bg <- rep(label.bg, length = n)
-    label.border <- rep(label.border, length = n)
-    if (!is.null(label.lty)) {
-        label.lty <- rep(label.lty, length = n)
-    }
-    label.lwd <- rep(label.lwd, length = n)
-    label.col <- rep(label.col, length = n)
-    label.cex <- rep(label.cex, length = n)
-    if (!vertices.last) {
-        if (vertex.enclose) 
-            gplot.vertex(x[use], y[use], radius = vertex.radius[use], 
-                sides = 50, col = "#FFFFFFFF", border = vertex.border[use], 
-                lty = vertex.lty[use])
-        gplot.vertex(x[use], y[use], radius = vertex.radius[use], 
-            sides = vertex.sides[use], col = vertex.col[use], 
-            border = vertex.border[use], lty = vertex.lty[use], 
-            rot = vertex.rot[use])
-    }
-    px0 <- vector()
-    py0 <- vector()
-    px1 <- vector()
-    py1 <- vector()
-    e.lwd <- vector()
-    e.curv <- vector()
-    e.type <- vector()
-    e.col <- vector()
-    e.hoff <- vector()
-    e.toff <- vector()
-    e.diag <- vector()
-    e.rad <- vector()
-    if (NROW(d) > 0) {
-        if (length(dim(edge.col)) == 2) 
-            edge.col <- edge.col[d[, 1:2]]
-        else edge.col <- rep(edge.col, length = NROW(d))
-        if (length(dim(edge.lty)) == 2) 
-            edge.lty <- edge.lty[d[, 1:2]]
-        else edge.lty <- rep(edge.lty, length = NROW(d))
-        if (length(dim(edge.lwd)) == 2) {
-            edge.lwd <- edge.lwd[d[, 1:2]]
-            e.lwd.as.mult <- FALSE
-        }
-        else {
-            if (length(edge.lwd) == 1) 
-                e.lwd.as.mult <- TRUE
-            else e.lwd.as.mult <- FALSE
-            edge.lwd <- rep(edge.lwd, length = NROW(d))
-        }
-        if (!is.null(edge.curve)) {
-            if (length(dim(edge.curve)) == 2) {
-                edge.curve <- edge.curve[d[, 1:2]]
-                e.curv.as.mult <- FALSE
-            }
-            else {
-                if (length(edge.curve) == 1) 
-                  e.curv.as.mult <- TRUE
-                else e.curv.as.mult <- FALSE
-                edge.curve <- rep(edge.curve, length = NROW(d))
-            }
-        }
-        else edge.curve <- rep(0, length = NROW(d))
-        dist <- ((x[d[, 1]] - x[d[, 2]])^2 + (y[d[, 1]] - y[d[, 
-            2]])^2)^0.5
-        tl <- d * dist
-        tl.max <- max(tl)
-        for (i in 1:NROW(d)) if (use[d[i, 1]] && use[d[i, 2]]) {
-            px0 <- c(px0, as.double(x[d[i, 1]]))
-            py0 <- c(py0, as.double(y[d[i, 1]]))
-            px1 <- c(px1, as.double(x[d[i, 2]]))
-            py1 <- c(py1, as.double(y[d[i, 2]]))
-            e.toff <- c(e.toff, vertex.radius[d[i, 1]])
-            e.hoff <- c(e.hoff, vertex.radius[d[i, 2]])
-            e.col <- c(e.col, edge.col[i])
-            e.type <- c(e.type, edge.lty[i])
-            if (edge.lwd[i] > 0) {
-                if (e.lwd.as.mult) 
-                  e.lwd <- c(e.lwd, edge.lwd[i] * d.raw[i, 3])
-                else e.lwd <- c(e.lwd, edge.lwd[i])
-            }
-            else e.lwd <- c(e.lwd, 1)
-            e.diag <- c(e.diag, d[i, 1] == d[i, 2])
-            e.rad <- c(e.rad, vertex.radius[d[i, 1]] * loop.cex[d[i, 
-                1]])
-            if (uselen) {
-                if (tl[i] > 0) {
-                  e.len <- dist[i] * tl.max/tl[i]
-                  e.curv <- c(e.curv, edge.len * sqrt((e.len/2)^2 - 
-                    (dist[i]/2)^2))
+    pdf(file, paper = "a4", width = 8.27, height = 11.69)
+    layout(matrix(c(1, 2, 3), nrow = 3, ncol = 1, byrow = TRUE), 
+        heights = c(25, 15, 60))
+    par(mar = c(0, 0, 0, 0))
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(5, 4, "Quality Control of Expression Data", adj = 0.5, 
+        cex = 3, col = "brown3", font = 2)
+    text(5, 1, paste("Generated by NOISeq on", format(Sys.time(), 
+        "%d %b %Y, %H:%M:%S")), adj = 0.5, font = 3, cex = 1.5)
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(2, 3, "Content", adj = 0.5, font = 2, cex = 2, col = "dodgerblue4")
+    par(mar = c(0, 3, 0, 3))
+    lugares = c(1, 3)
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(lugares[1], 10, "Plot", adj = 0, font = 3, cex = 1)
+    text(lugares[2], 10, "Description", adj = 0, font = 3, cex = 1)
+    abline(h = 9.8, lty = 2, col = "grey")
+    empiezo = 9.3
+    bajo = 0.5
+    text(lugares[1], empiezo, "Biotype detection", adj = 0, font = 2, 
+        cex = 1)
+    if (QCinfo$parameters$biotypes) {
+        text(lugares[2], empiezo, "Biotype abundance in the genome with %genes detected (counts > 0) in the sample/condition.", 
+            adj = 0, font = 1, cex = 1)
+        text(lugares[2], empiezo - bajo/2, "Biotype abundance within the sample/condition.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    else {
+        text(lugares[2], empiezo, "Plot not available. Biotypes information was not provided.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    empiezo = empiezo - bajo - 0.3
+    text(lugares[1], empiezo, "Biotype expression", adj = 0, 
+        font = 2, cex = 1)
+    if (QCinfo$parameters$biotypes) {
+        text(lugares[2], empiezo, "Distribution of gene counts per million per biotype in sample/condition (only genes with counts > 0).", 
+            adj = 0, font = 1, cex = 1)
+    }
+    else {
+        text(lugares[2], empiezo, "Plot not available. Biotypes information was not provided.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "Saturation", adj = 0, font = 2, 
+        cex = 1)
+    text(lugares[2], empiezo, "Number of detected genes (counts > 0) per sample across different sequencing depths", 
+        adj = 0, font = 1, cex = 1)
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "Expression boxplot", adj = 0, 
+        font = 2, cex = 1)
+    text(lugares[2], empiezo, "Distribution of gene counts per million (all biotypes) in each sample/condition", 
+        adj = 0, font = 1, cex = 1)
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "Expression barplot", adj = 0, 
+        font = 2, cex = 1)
+    text(lugares[2], empiezo, "Percentage of genes with >0, >1, >2, >5 or >10 counts per million in each sample/condition.", 
+        adj = 0, font = 1, cex = 1)
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "Length bias", adj = 0, font = 2, 
+        cex = 1)
+    if (QCinfo$parameters$length) {
+        text(lugares[2], empiezo, "Mean gene expression per each length bin. Fitted curve and diagnostic test.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    else {
+        text(lugares[2], empiezo, "Plot not available. Gene length was not provided.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "GC content bias", adj = 0, font = 2, 
+        cex = 1)
+    if (QCinfo$parameters$GC) {
+        text(lugares[2], empiezo, "Mean gene expression per each GC content bin. Fitted curve and diagnostic test.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    else {
+        text(lugares[2], empiezo, "Plot not available. Gene GC content was not provided.", 
+            adj = 0, font = 1, cex = 1)
+    }
+    empiezo = empiezo - bajo
+    text(lugares[1], empiezo, "RNA composition bias", adj = 0, 
+        font = 2, cex = 1)
+    text(lugares[2], empiezo, "Density plots of log fold changes (M) between pairs of samples.", 
+        adj = 0, font = 1, cex = 1)
+    text(lugares[2], empiezo - bajo/2, "Confidence intervals for the median of M values.", 
+        adj = 0, font = 1, cex = 1)
+    empiezo = empiezo - bajo - 0.3
+    text(lugares[1], empiezo, "Exploratory PCA", adj = 0, font = 2, 
+        cex = 1)
+    text(lugares[2], empiezo, "Principal Component Analysis score plots for PC1 vs PC2, and PC1 vs PC3.", 
+        adj = 0, font = 1, cex = 1)
+    if (QCinfo$parameters$biotypes) {
+        layout(matrix(c(1, 1, 2, 3, 4, 5), nrow = 3, ncol = 2, 
+            byrow = TRUE), heights = c(10, 45, 45))
+        par(mar = c(0, 0, 0, 0))
+        plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+            ylab = "")
+        text(5, 6, "Biotype detection", adj = 0.5, font = 2, 
+            cex = 2, col = "dodgerblue4")
+        biodetection.plot(QCinfo$data$biodet, samples = samples, 
+            plottype = "comparison", toreport = TRUE)
+        countsbio.plot(QCinfo$data$countsbiot, toplot = "global", 
+            samples = samples[1], plottype = "boxplot", ylim = range(log2(1 + 
+                QCinfo$data$countsbiot$result)), toreport = TRUE)
+        countsbio.plot(QCinfo$data$countsbiot, toplot = "global", 
+            samples = samples[2], plottype = "boxplot", ylim = range(log2(1 + 
+                QCinfo$data$countsbiot$result)), toreport = TRUE)
+    }
+    layout(matrix(c(1, 2, 3, 8, 4, 1, 5, 6, 8, 7), nrow = 5, 
+        ncol = 2, byrow = FALSE), heights = c(10, 35, 10, 5, 
+        40))
+    par(mar = c(0, 0, 0, 0))
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(5, 5, "Sequencing depth & Expression quantification", 
+        adj = 0.5, font = 2, cex = 2, col = "dodgerblue4")
+    if (is.null(niveles)) {
+        saturation.plot(QCinfo$data$saturation, samples = samples, 
+            toplot = 1, yleftlim = c(0, unlist(QCinfo$data$saturation$bionum[1])), 
+            toreport = TRUE)
+    }
+    else {
+        par(mar = c(5.1, 4.1, 4.1, 2.1))
+        saturation.plot(QCinfo$data$saturation, samples = samples2[myfactor == 
+            niveles[1]], toplot = 1, toreport = TRUE, yleftlim = c(0, 
+            unlist(QCinfo$data$saturation$bionum[1])), )
+        if (sum(myfactor == niveles[1]) > 2) {
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+        }
+    }
+    par(mar = c(0, 0, 0, 0))
+    countsbio.plot(QCinfo$data$countsampl, toplot = "global", 
+        samples = samples, plottype = "boxplot", toreport = TRUE)
+    if (is.null(niveles)) {
+        par(mar = c(0, 0, 0, 0))
+        plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+            ylab = "")
+        plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+            ylab = "")
+    }
+    else {
+        saturation.plot(QCinfo$data$saturation, samples = samples2[myfactor == 
+            niveles[2]], toplot = 1, yleftlim = c(0, unlist(QCinfo$data$saturation$bionum[1])), 
+            toreport = TRUE)
+        if (sum(myfactor == niveles[2]) > 2) {
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+        }
+    }
+    countsbio.plot(QCinfo$data$countsampl, toplot = "global", 
+        samples = samples, plottype = "barplot", toreport = TRUE)
+    QQ = 0.05
+    layout(matrix(c(1, 1, 2, 2, 3, 4, 5, 5, 6, 7), nrow = 5, 
+        ncol = 2, byrow = TRUE), heights = c(10, 10, 35, 10, 
+        35))
+    par(mar = c(0, 0, 0, 0))
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(5, 5, "Sequencing bias detection", adj = 0.5, font = 2, 
+        cex = 2, col = "dodgerblue4")
+    if (QCinfo$parameters$length) {
+        if (QCinfo$parameters$GC) {
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for feature length bias", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            laF = lapply(QCinfo$data$length$RegressionModels[samples], 
+                function(x) summary(x)$fstatistic)
+            pvalores = sapply(laF, function(x) pf(x[1], df1 = x[2], 
+                df2 = x[3], lower.tail = FALSE))
+            misR2 = sapply(QCinfo$data$length$RegressionModels[samples], 
+                function(x) summary(x)$r.squared)
+            if (min(pvalores) < QQ) {
+                if (max(misR2) > 0.7) {
+                  text(5, 5, "FAILED. At least one of the model p-values was lower than 0.05 and R2 > 70%.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting length bias is recommended.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
                 else {
-                  e.curv <- c(e.curv, 0)
+                  text(5, 5, "WARNING. At least one of the model p-values was lower than 0.05, but R2 < 70% for at least one condition.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting length bias could be advisable.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 2, "Plese check in the plots below the strength of the relationship between length and expression.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
             }
             else {
-                if (e.curv.as.mult) 
-                  e.curv <- c(e.curv, edge.curve[i] * dist[i])
-                else e.curv <- c(e.curv, edge.curve[i])
-            }
-        }
-    }
-    if (diag && (length(px0) > 0) && sum(e.diag > 0)) {
-        gplot.loop(as.vector(px0)[e.diag], as.vector(py0)[e.diag], 
-            length = 1.5 * baserad * arrowhead.cex, angle = 25, 
-            width = e.lwd[e.diag] * baserad/10, col = e.col[e.diag], 
-            border = e.col[e.diag], lty = e.type[e.diag], offset = e.hoff[e.diag], 
-            edge.steps = loop.steps, radius = e.rad[e.diag], 
-            arrowhead = usearrows, xctr = mean(x[use]), yctr = mean(y[use]))
-    }
-    if (length(px0) > 0) {
-        px0 <- px0[!e.diag]
-        py0 <- py0[!e.diag]
-        px1 <- px1[!e.diag]
-        py1 <- py1[!e.diag]
-        e.curv <- e.curv[!e.diag]
-        e.lwd <- e.lwd[!e.diag]
-        e.type <- e.type[!e.diag]
-        e.col <- e.col[!e.diag]
-        e.hoff <- e.hoff[!e.diag]
-        e.toff <- e.toff[!e.diag]
-        e.rad <- e.rad[!e.diag]
-    }
-    if (!usecurve & !uselen) {
-        if (length(px0) > 0) 
-            gplot.arrow(as.vector(px0), as.vector(py0), as.vector(px1), 
-                as.vector(py1), length = 2 * baserad * arrowhead.cex, 
-                angle = 20, col = e.col, border = e.col, lty = e.type, 
-                width = e.lwd * baserad/10, offset.head = e.hoff, 
-                offset.tail = e.toff, arrowhead = usearrows, 
-                edge.steps = edge.steps)
-    }
-    else {
-        if (length(px0) > 0) {
-            gplot.arrow(as.vector(px0), as.vector(py0), as.vector(px1), 
-                as.vector(py1), length = 2 * baserad * arrowhead.cex, 
-                angle = 20, col = e.col, border = e.col, lty = e.type, 
-                width = e.lwd * baserad/10, offset.head = e.hoff, 
-                offset.tail = e.toff, arrowhead = usearrows, 
-                curve = e.curv, edge.steps = edge.steps)
-        }
-    }
-    if (vertices.last) {
-        if (vertex.enclose) 
-            gplot.vertex(x[use], y[use], radius = vertex.radius[use], 
-                sides = 50, col = "#FFFFFFFF", border = vertex.border[use], 
-                lty = vertex.lty[use])
-        gplot.vertex(x[use], y[use], radius = vertex.radius[use], 
-            sides = vertex.sides[use], col = vertex.col[use], 
-            border = vertex.border[use], lty = vertex.lty[use], 
-            rot = vertex.rot[use])
-    }
-    if (displaylabels & (!all(label == "")) & (!all(use == FALSE))) {
-        if (label.pos == 0) {
-            xhat <- yhat <- rhat <- rep(0, n)
-            xoff <- x[use] - mean(x[use])
-            yoff <- y[use] - mean(y[use])
-            roff <- sqrt(xoff^2 + yoff^2)
-            for (i in (1:n)[use]) {
-                ij <- unique(c(d[d[, 2] == i & d[, 1] != i, 1], 
-                  d[d[, 1] == i & d[, 2] != i, 2]))
-                ij.n <- length(ij)
-                if (ij.n > 0) {
-                  for (j in ij) {
-                    dx <- x[i] - x[j]
-                    dy <- y[i] - y[j]
-                    dr <- sqrt(dx^2 + dy^2)
-                    xhat[i] <- xhat[i] + dx/dr
-                    yhat[i] <- yhat[i] + dy/dr
-                  }
-                  xhat[i] <- xhat[i]/ij.n
-                  yhat[i] <- yhat[i]/ij.n
-                  rhat[i] <- sqrt(xhat[i]^2 + yhat[i]^2)
-                  if (rhat[i] != 0) {
-                    xhat[i] <- xhat[i]/rhat[i]
-                    yhat[i] <- yhat[i]/rhat[i]
-                  }
-                  else {
-                    xhat[i] <- xoff[i]/roff[i]
-                    yhat[i] <- yoff[i]/roff[i]
-                  }
+                text(5, 4, "PASSED. No normalization for correcting length bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            length.plot(QCinfo$data$length, toreport = TRUE, 
+                samples = samples)
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for GC content bias", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            laF = lapply(QCinfo$data$GC$RegressionModels[samples], 
+                function(x) summary(x)$fstatistic)
+            pvalores = sapply(laF, function(x) pf(x[1], df1 = x[2], 
+                df2 = x[3], lower.tail = FALSE))
+            misR2 = sapply(QCinfo$data$GC$RegressionModels[samples], 
+                function(x) summary(x)$r.squared)
+            if (min(pvalores) < QQ) {
+                if (max(misR2) > 0.7) {
+                  text(5, 5, "FAILED. At least one of the model p-values was lower than 0.05 and R2 > 70%.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting GC content bias is recommended.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
                 else {
-                  xhat[i] <- xoff[i]/roff[i]
-                  yhat[i] <- yoff[i]/roff[i]
+                  text(5, 5, "WARNING. At least one of the model p-values was lower than 0.05, but R2 < 70% for at least one condition.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting GC content bias could be advisable.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 2, "Plese check in the plots below the strength of the relationship between GC content and expression.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
-                if (xhat[i] == 0) 
-                  xhat[i] <- 0.01
-                if (yhat[i] == 0) 
-                  yhat[i] <- 0.01
-            }
-            xhat <- xhat[use]
-            yhat <- yhat[use]
-        }
-        else if (label.pos < 5) {
-            xhat <- switch(label.pos, 0, -1, 0, 1)
-            yhat <- switch(label.pos, -1, 0, 1, 0)
-        }
-        else if (label.pos == 6) {
-            xoff <- x[use] - mean(x[use])
-            yoff <- y[use] - mean(y[use])
-            roff <- sqrt(xoff^2 + yoff^2)
-            xhat <- xoff/roff
-            yhat <- yoff/roff
-        }
-        else {
-            xhat <- 0
-            yhat <- 0
-        }
-        lw <- strwidth(label[use], cex = label.cex[use])/2
-        lh <- strheight(label[use], cex = label.cex[use])/2
-        if (boxed.labels) {
-            rect(x[use] + xhat * vertex.radius[use] - (lh * label.pad + 
-                lw) * ((xhat < 0) * 2 + (xhat == 0) * 1), y[use] + 
-                yhat * vertex.radius[use] - (lh * label.pad + 
-                lh) * ((yhat < 0) * 2 + (yhat == 0) * 1), x[use] + 
-                xhat * vertex.radius[use] + (lh * label.pad + 
-                lw) * ((xhat > 0) * 2 + (xhat == 0) * 1), y[use] + 
-                yhat * vertex.radius[use] + (lh * label.pad + 
-                lh) * ((yhat > 0) * 2 + (yhat == 0) * 1), col = label.bg[use], 
-                border = label.border[use], lty = label.lty[use], 
-                lwd = label.lwd[use])
-        }
-        text(x[use] + xhat * vertex.radius[use] + (lh * label.pad + 
-            lw) * ((xhat > 0) - (xhat < 0)), y[use] + yhat * 
-            vertex.radius[use] + (lh * label.pad + lh) * ((yhat > 
-            0) - (yhat < 0)), label[use], cex = label.cex[use], 
-            col = label.col[use], offset = 0)
-    }
-    if ((interactive | interact.bycomp) && ((length(x) > 0) && 
-        (!all(use == FALSE)))) {
-        os <- c(0.2, 0.4) * par()$cxy
-        textloc <- c(min(x[use]) - pad, max(y[use]) + pad)
-        tm <- "Select a vertex to move, or click \"Finished\" to end."
-        tmh <- strheight(tm)
-        tmw <- strwidth(tm)
-        text(textloc[1], textloc[2], tm, adj = c(0, 0.5))
-        fm <- "Finished"
-        finx <- c(textloc[1], textloc[1] + strwidth(fm))
-        finy <- c(textloc[2] - 3 * tmh - strheight(fm)/2, textloc[2] - 
-            3 * tmh + strheight(fm)/2)
-        finbx <- finx + c(-os[1], os[1])
-        finby <- finy + c(-os[2], os[2])
-        rect(finbx[1], finby[1], finbx[2], finby[2], col = "white")
-        text(finx[1], mean(finy), fm, adj = c(0, 0.5))
-        clickpos <- unlist(locator(1))
-        if ((clickpos[1] %iin% finbx) && (clickpos[2] %iin% finby)) {
-            cl <- match.call()
-            cl$interactive <- FALSE
-            cl$coord <- cbind(x, y)
-            cl$dat <- dat
-            return(eval(cl))
-        }
-        else {
-            clickdis <- sqrt((clickpos[1] - x[use])^2 + (clickpos[2] - 
-                y[use])^2)
-            selvert <- match(min(clickdis), clickdis)
-            if (all(label == "")) 
-                label <- 1:n
-            rect(textloc[1], textloc[2] - tmh/2, textloc[1] + 
-                tmw, textloc[2] + tmh/2, border = "white", col = "white")
-            if (interact.bycomp) 
-                tm <- "Where should I move this component?"
-            else tm <- "Where should I move this vertex?"
-            tmh <- strheight(tm)
-            tmw <- strwidth(tm)
-            text(textloc[1], textloc[2], tm, adj = c(0, 0.5))
-            fm <- paste("Vertex", label[use][selvert], "selected")
-            finx <- c(textloc[1], textloc[1] + strwidth(fm))
-            finy <- c(textloc[2] - 3 * tmh - strheight(fm)/2, 
-                textloc[2] - 3 * tmh + strheight(fm)/2)
-            finbx <- finx + c(-os[1], os[1])
-            finby <- finy + c(-os[2], os[2])
-            rect(finbx[1], finby[1], finbx[2], finby[2], col = "white")
-            text(finx[1], mean(finy), fm, adj = c(0, 0.5))
-            clickpos <- unlist(locator(1))
-            if (interact.bycomp) {
-                dx <- clickpos[1] - x[use][selvert]
-                dy <- clickpos[2] - y[use][selvert]
-                comp.mem <- component.dist(d, connected = "weak")$membership
-                same.comp <- comp.mem[use] == comp.mem[use][selvert]
-                x[use][same.comp] <- x[use][same.comp] + dx
-                y[use][same.comp] <- y[use][same.comp] + dy
             }
             else {
-                x[use][selvert] <- clickpos[1]
-                y[use][selvert] <- clickpos[2]
+                text(5, 4, "PASSED. No normalization for correcting GC content bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
             }
-            cl <- match.call()
-            cl$coord <- cbind(x, y)
-            cl$dat <- dat
-            return(eval(cl))
-        }
-    }
-    invisible(cbind(x, y))
-}
-
-gplot.arrow (closure) = function (x0, y0, x1, y1, length = 0.1, angle = 20, width = 0.01, 
-    col = 1, border = 1, lty = 1, offset.head = 0, offset.tail = 0, 
-    arrowhead = TRUE, curve = 0, edge.steps = 50, ...) 
-{
-    if (length(x0) == 0) 
-        return()
-    make.coords <- function(x0, y0, x1, y1, ahangle, ahlen, swid, 
-        toff, hoff, ahead, curve, csteps, lty) {
-        if (lty == "blank" | lty == 0) 
-            return(c(NA, NA))
-        slen <- sqrt((x0 - x1)^2 + (y0 - y1)^2)
-        xlenin = (abs(x0 - x1)/(par()$usr[2] - par()$usr[1])) * 
-            par()$pin[1]
-        ylenin = (abs(y0 - y1)/(par()$usr[4] - par()$usr[3])) * 
-            par()$pin[2]
-        csteps = csteps * sqrt(xlenin^2 + ylenin^2)
-        if (is.character(lty)) {
-            lty <- switch(lty, blank = 0, solid = 1, dashed = 2, 
-                dotted = 3, dotdash = 4, longdash = 5, twodash = 6, 
-                lty)
-        }
-        else {
-            lty <- as.character(lty)
-        }
-        if (is.na(as.integer(lty))) 
-            lty <- "10"
-        if (as.integer(lty) < 10) 
-            lty <- c("01", "10", "44", "13", "1343", "73", "2262")[as.integer(lty) + 
-                1]
-        if (curve == 0 & lty == "10") {
-            if (ahead) {
-                coord <- rbind(c(-swid/2, toff), c(-swid/2, slen - 
-                  0.5 * ahlen - hoff), c(-swid/2 - ahlen * sin(ahangle), 
-                  slen - ahlen * cos(ahangle) - hoff), c(0, slen - 
-                  hoff), c(swid/2 + ahlen * sin(ahangle), slen - 
-                  ahlen * cos(ahangle) - hoff), c(swid/2, slen - 
-                  0.5 * ahlen - hoff), c(swid/2, toff), c(NA, 
-                  NA))
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            GC.plot(QCinfo$data$GC, toreport = TRUE, samples = samples)
+            layout(matrix(c(1, 1, 2, 3, 4, 4), nrow = 3, ncol = 2, 
+                byrow = TRUE), heights = c(10, 40, 45))
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for differences in RNA composition", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            if ("FAILED" %in% QCinfo$data$countdist$DiagnosticTest[, 
+                "Diagnostic Test"]) {
+                text(5, 5, "FAILED. There is a pair of samples with significantly different RNA composition", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
             }
             else {
-                coord <- rbind(c(-swid/2, toff), c(-swid/2, slen - 
-                  hoff), c(swid/2, slen - hoff), c(swid/2, toff), 
-                  c(NA, NA))
+                text(5, 5, "PASSED. The pairs of compared samples do not present significant differences in RNA composition.", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is NOT required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            if (length(samples2) < 14) {
+                cd.plot(QCinfo$data$countdist, samples = samples2)
+            }
+            else {
+                cd.plot(QCinfo$data$countdist, samples = setdiff(samples2, 
+                  QCinfo$data$countdist$refColumn)[1:12])
+            }
+            par(mar = c(0, 0, 0, 0))
+            lugares = c(1, 4.5, 6.5, 8.5)
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(lugares[1], 10, "Confidence intervals for median of M values", 
+                adj = 0, font = 2, cex = 1.2)
+            text(lugares[1], 9.4, "Sample", adj = 0, font = 1, 
+                cex = 1)
+            abline(h = 9.2, lty = 2, col = "grey")
+            for (j in 1:3) {
+                text(lugares[j + 1], 9.4, colnames(QCinfo$data$countdist$DiagnosticTest)[j], 
+                  adj = 0, font = 1, cex = 1)
+                for (i in 1:min(30, nrow(QCinfo$data$countdist$DiagnosticTest))) {
+                  if (j == 1) 
+                    text(lugares[j], 9.2 - i * 0.3, rownames(QCinfo$data$countdist$DiagnosticTest)[i], 
+                      adj = 0, font = 1, cex = 1)
+                  if (j < 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 1, 
+                      font = 1, cex = 1, round(as.numeric(QCinfo$data$countdist$DiagnosticTest[i, 
+                        j]), 4))
+                  if (j == 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 0, 
+                      font = 1, cex = 1, QCinfo$data$countdist$DiagnosticTest[i, 
+                        j])
+                }
+            }
+            if (nrow(QCinfo$data$countdist$DiagnosticTest) > 
+                30) {
+                print("WARNING: In Diagnostic Test for RNA composition, the confidence intervals are shown for only \n              the first 30 samples.")
             }
         }
         else {
-            theta <- atan2(y1 - y0, x1 - x0)
-            x0 <- x0 + cos(theta) * toff
-            x1 <- x1 - cos(theta) * hoff
-            y0 <- y0 + sin(theta) * toff
-            y1 <- y1 - sin(theta) * hoff
-            slen <- sqrt((x0 - x1)^2 + (y0 - y1)^2)
-            if (ahead) {
-                inc <- (0:csteps)/csteps
-                coord <- rbind(cbind(-curve * (1 - (2 * (inc - 
-                  0.5))^2) - swid/2, inc * (slen - ahlen * 0.5)), 
-                  c(-swid/2 + ahlen * sin(-ahangle - (curve > 
-                    0) * pi/16), slen - ahlen * cos(-ahangle - 
-                    (curve > 0) * pi/16)), c(0, slen), c(swid/2 + 
-                    ahlen * sin(ahangle - (curve > 0) * pi/16), 
-                    slen - ahlen * cos(ahangle - (curve > 0) * 
-                      pi/16)), cbind(-curve * (1 - (2 * (rev(inc) - 
-                    0.5))^2) + swid/2, rev(inc) * (slen - ahlen * 
-                    0.5)), c(NA, NA))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for feature length bias", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            laF = lapply(QCinfo$data$length$RegressionModels[samples], 
+                function(x) summary(x)$fstatistic)
+            pvalores = sapply(laF, function(x) pf(x[1], df1 = x[2], 
+                df2 = x[3], lower.tail = FALSE))
+            misR2 = sapply(QCinfo$data$length$RegressionModels[samples], 
+                function(x) summary(x)$r.squared)
+            if (min(pvalores) < QQ) {
+                if (max(misR2) > 0.7) {
+                  text(5, 5, "FAILED. At least one of the model p-values was lower than 0.05 and R2 > 70%.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting length bias is recommended.", 
+                    adj = 0.5, font = 1, cex = 1)
+                }
+                else {
+                  text(5, 5, "WARNING. At least one of the model p-values was lower than 0.05, but R2 < 70% for at least one condition.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting length bias could be advisable.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 2, "Plese check in the plots below the strength of the relationship between length and expression.", 
+                    adj = 0.5, font = 1, cex = 1)
+                }
             }
             else {
-                inc <- (0:csteps)/csteps
-                coord <- rbind(cbind(-curve * (1 - (2 * (inc - 
-                  0.5))^2) - swid/2, inc * slen), cbind(-curve * 
-                  (1 - (2 * (rev(inc) - 0.5))^2) + swid/2, rev(inc) * 
-                  slen), c(NA, NA))
-            }
-        }
-        theta <- atan2(y1 - y0, x1 - x0) - pi/2
-        rmat <- rbind(c(cos(theta), sin(theta)), c(-sin(theta), 
-            cos(theta)))
-        coord <- coord %*% rmat
-        coord[, 1] <- coord[, 1] + x0
-        coord[, 2] <- coord[, 2] + y0
-        if (lty != "10") {
-            inc <- 1
-            lty.i <- 1
-            lty.n <- nchar(lty)
-            inc.solid = as.integer(substr(lty, lty.i, lty.i))
-            inc.blank = as.integer(substr(lty, lty.i + 1, lty.i + 
-                1))
-            coord.n <- dim(coord)[1]
-            coord2 <- NULL
-            while (inc < (csteps - inc.solid - inc.blank + 1)) {
-                coord2 <- rbind(coord2, coord[inc:(inc + inc.solid), 
-                  ], coord[(coord.n - inc.solid - inc):(coord.n - 
-                  inc), ], c(NA, NA))
-                inc <- inc + inc.solid + inc.blank
-                lty.i = lty.i + 2
-                if (lty.i > lty.n) 
-                  lty.i <- 1
-            }
-            if (inc < (coord.n - inc)) 
-                coord2 <- rbind(coord2, coord[inc:(coord.n - 
-                  inc), ], c(NA, NA))
-            coord <- coord2
-        }
-        coord
-    }
-    n <- length(x0)
-    angle <- rep(angle, length = n)/360 * 2 * pi
-    length <- rep(length, length = n)
-    width <- rep(width, length = n)
-    col <- rep(col, length = n)
-    border <- rep(border, length = n)
-    lty <- rep(lty, length = n)
-    arrowhead <- rep(arrowhead, length = n)
-    offset.head <- rep(offset.head, length = n)
-    offset.tail <- rep(offset.tail, length = n)
-    curve <- rep(curve, length = n)
-    edge.steps <- rep(edge.steps, length = n)
-    coord <- vector()
-    for (i in 1:n) coord <- rbind(coord, make.coords(x0[i], y0[i], 
-        x1[i], y1[i], angle[i], length[i], width[i], offset.tail[i], 
-        offset.head[i], arrowhead[i], curve[i], edge.steps[i], 
-        lty[i]))
-    coord <- coord[-NROW(coord), ]
-    polygon(coord, col = col, border = border, ...)
-}
-
-gplot.layout.adj (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "invadj"
-    layout.par$dist = "none"
-    layout.par$exp = 1
-    gplot.layout.mds(d, layout.par)
-}
-
-gplot.layout.circle (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    cbind(sin(2 * pi * ((0:(n - 1))/n)), cos(2 * pi * ((0:(n - 
-        1))/n)))
-}
-
-gplot.layout.circrand (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$dist = "uniang"
-    gplot.layout.random(d, layout.par)
-}
-
-gplot.layout.eigen (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- d
-    else vm <- switch(layout.par$var, symupper = symmetrize(d, 
-        rule = "uppper"), symlower = symmetrize(d, rule = "lower"), 
-        symstrong = symmetrize(d, rule = "strong"), symweak = symmetrize(d, 
-            rule = "weak"), user = layout.par$mat, raw = d)
-    e <- eigen(vm)
-    if (is.null(layout.par$evsel)) 
-        coord <- Re(e$vectors[, 1:2])
-    else coord <- switch(layout.par$evsel, first = Re(e$vectors[, 
-        1:2]), size = Re(e$vectors[, rev(order(abs(e$values)))[1:2]]))
-    coord
-}
-
-gplot.layout.fruchtermanreingold (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$niter)) 
-        niter <- 500
-    else niter <- layout.par$niter
-    if (is.null(layout.par$max.delta)) 
-        max.delta <- n
-    else max.delta <- layout.par$max.delta
-    if (is.null(layout.par$area)) 
-        area <- n^2
-    else area <- layout.par$area
-    if (is.null(layout.par$cool.exp)) 
-        cool.exp <- 3
-    else cool.exp <- layout.par$cool.exp
-    if (is.null(layout.par$repulse.rad)) 
-        repulse.rad <- area * log(n)
-    else repulse.rad <- layout.par$repulse.rad
-    if (is.null(layout.par$ncell)) 
-        ncell <- ceiling(n^0.4)
-    else ncell <- layout.par$ncell
-    if (is.null(layout.par$cell.jitter)) 
-        cell.jitter <- 0.5
-    else cell.jitter <- layout.par$cell.jitter
-    if (is.null(layout.par$cell.pointpointrad)) 
-        cell.pointpointrad <- 0
-    else cell.pointpointrad <- layout.par$cell.pointpointrad
-    if (is.null(layout.par$cell.pointcellrad)) 
-        cell.pointcellrad <- 18
-    else cell.pointcellrad <- layout.par$cell.pointcellrad
-    if (is.null(layout.par$cellcellcellrad)) 
-        cell.cellcellrad <- ncell^2
-    else cell.cellcellrad <- layout.par$cell.cellcellrad
-    if (is.null(layout.par$seed.coord)) {
-        tempa <- sample((0:(n - 1))/n)
-        x <- n/(2 * pi) * sin(2 * pi * tempa)
-        y <- n/(2 * pi) * cos(2 * pi * tempa)
-    }
-    else {
-        x <- layout.par$seed.coord[, 1]
-        y <- layout.par$seed.coord[, 2]
-    }
-    d <- symmetrize(d, rule = "weak", return.as.edgelist = TRUE)
-    layout <- .C("gplot_layout_fruchtermanreingold_R", as.double(d), 
-        as.double(n), as.double(NROW(d)), as.integer(niter), 
-        as.double(max.delta), as.double(area), as.double(cool.exp), 
-        as.double(repulse.rad), as.integer(ncell), as.double(cell.jitter), 
-        as.double(cell.pointpointrad), as.double(cell.pointcellrad), 
-        as.double(cell.cellcellrad), x = as.double(x), y = as.double(y), 
-        PACKAGE = "sna")
-    cbind(layout$x, layout$y)
-}
-
-gplot.layout.geodist (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "geodist"
-    layout.par$dist = "none"
-    layout.par$exp = 1
-    gplot.layout.mds(d, layout.par)
-}
-
-gplot.layout.hall (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- NROW(d)
-    sd <- symmetrize(d)
-    laplacian <- -sd
-    diag(laplacian) <- degree(sd, cmode = "indegree")
-    eigen(laplacian)$vec[, (n - 1):(n - 2)]
-}
-
-gplot.layout.kamadakawai (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$niter)) {
-        niter <- 1000
-    }
-    else niter <- layout.par$niter
-    if (is.null(layout.par$sigma)) {
-        sigma <- n/4
-    }
-    else sigma <- layout.par$sigma
-    if (is.null(layout.par$initemp)) {
-        initemp <- 10
-    }
-    else initemp <- layout.par$initemp
-    if (is.null(layout.par$coolexp)) {
-        coolexp <- 0.99
-    }
-    else coolexp <- layout.par$coolexp
-    if (is.null(layout.par$kkconst)) {
-        kkconst <- n^2
-    }
-    else kkconst <- layout.par$kkconst
-    if (is.null(layout.par$edge.val.as.str)) 
-        edge.val.as.str <- TRUE
-    else edge.val.as.str <- layout.par$edge.val.as.str
-    if (is.null(layout.par$elen)) {
-        d <- symmetrize(d, return.as.edgelist = TRUE)
-        if (edge.val.as.str) 
-            d[, 3] <- 1/d[, 3]
-        elen <- geodist(d, ignore.eval = FALSE)$gdist
-        elen[elen == Inf] <- max(elen[is.finite(elen)]) * 1.25
-    }
-    else elen <- layout.par$elen
-    if (is.null(layout.par$seed.coord)) {
-        x <- rnorm(n, 0, n/4)
-        y <- rnorm(n, 0, n/4)
-    }
-    else {
-        x <- layout.par$seed.coord[, 1]
-        y <- layout.par$seed.coord[, 2]
-    }
-    pos <- .C("gplot_layout_kamadakawai_R", as.integer(n), as.integer(niter), 
-        as.double(elen), as.double(initemp), as.double(coolexp), 
-        as.double(kkconst), as.double(sigma), x = as.double(x), 
-        y = as.double(y), PACKAGE = "sna")
-    cbind(pos$x, pos$y)
-}
-
-gplot.layout.mds (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- cbind(d, t(d))
-    else vm <- switch(layout.par$var, rowcol = cbind(d, t(d)), 
-        col = t(d), row = d, rcsum = d + t(d), rcdiff = t(d) - 
-            d, invadj = max(d) - d, geodist = geodist(d, inf.replace = NCOL(d))$gdist, 
-        user = layout.par$vm)
-    if (is.null(layout.par$dist)) 
-        dm <- as.matrix(dist(vm))
-    else dm <- switch(layout.par$dist, euclidean = as.matrix(dist(vm)), 
-        maximum = as.matrix(dist(vm, method = "maximum")), manhattan = as.matrix(dist(vm, 
-            method = "manhattan")), canberra = as.matrix(dist(vm, 
-            method = "canberra")), none = vm)
-    if (is.null(layout.par$exp)) 
-        dm <- dm^2
-    else dm <- dm^layout.par$exp
-    cmdscale(dm, 2)
-}
-
-gplot.layout.princoord (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- rbind(d, t(d))
-    else vm <- switch(layout.par$var, rowcol = rbind(d, t(d)), 
-        col = d, row = t(d), rcsum = d + t(d), rcdiff = d - t(d), 
-        user = layout.par$vm)
-    if (is.null(layout.par$cor) || layout.par$cor) 
-        cd <- cor(vm, use = "pairwise.complete.obs")
-    else cd <- cov(vm, use = "pairwise.complete.obs")
-    cd <- replace(cd, is.na(cd), 0)
-    e <- eigen(cd, symmetric = TRUE)
-    x <- Re(e$vectors[, 1])
-    y <- Re(e$vectors[, 2])
-    cbind(x, y)
-}
-
-gplot.layout.random (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$dist)) 
-        temp <- matrix(runif(2 * n, -1, 1), n, 2)
-    else if (layout.par$dist == "unif") 
-        temp <- matrix(runif(2 * n, -1, 1), n, 2)
-    else if (layout.par$dist == "uniang") {
-        tempd <- rnorm(n, 1, 0.25)
-        tempa <- runif(n, 0, 2 * pi)
-        temp <- cbind(tempd * sin(tempa), tempd * cos(tempa))
-    }
-    else if (layout.par$dist == "normal") 
-        temp <- matrix(rnorm(2 * n), n, 2)
-    temp
-}
-
-gplot.layout.rmds (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "row"
-    layout.par$dist = "euclidean"
-    layout.par$exp = 1
-    gplot.layout.mds(d, layout.par)
-}
-
-gplot.layout.segeo (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "geodist"
-    layout.par$dist = "euclidean"
-    gplot.layout.mds(d, layout.par)
-}
-
-gplot.layout.seham (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "rowcol"
-    layout.par$dist = "manhattan"
-    layout.par$exp = 1
-    gplot.layout.mds(d, layout.par)
-}
-
-gplot.layout.spring (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    ep <- vector()
-    if (is.null(layout.par$mass)) 
-        ep[1] <- 0.1
-    else ep[1] <- layout.par$mass
-    if (is.null(layout.par$equil)) 
-        ep[2] <- 1
-    else ep[2] <- layout.par$equil
-    if (is.null(layout.par$k)) 
-        ep[3] <- 0.001
-    else ep[3] <- layout.par$k
-    if (is.null(layout.par$repeqdis)) 
-        ep[4] <- 0.1
-    else ep[4] <- layout.par$repeqdis
-    if (is.null(layout.par$kfr)) 
-        ep[5] <- 0.01
-    else ep[5] <- layout.par$kfr
-    if (is.null(layout.par$repulse)) 
-        repulse <- FALSE
-    else repulse <- layout.par$repulse
-    n <- dim(d)[1]
-    f.x <- rep(0, n)
-    f.y <- rep(0, n)
-    v.x <- rep(0, n)
-    v.y <- rep(0, n)
-    tempa <- sample((0:(n - 1))/n)
-    x <- n/(2 * pi) * sin(2 * pi * tempa)
-    y <- n/(2 * pi) * cos(2 * pi * tempa)
-    ds <- symmetrize(d, "weak")
-    kfr <- ep[5]
-    niter <- 1
-    repeat {
-        niter <- niter + 1
-        dis <- as.matrix(dist(cbind(x, y)))
-        theta <- acos(t(outer(x, x, "-"))/dis) * sign(t(outer(y, 
-            y, "-")))
-        f.x <- apply(ds * cos(theta) * ep[3] * (dis - ep[2]), 
-            1, sum, na.rm = TRUE)
-        f.y <- apply(ds * sin(theta) * ep[3] * (dis - ep[2]), 
-            1, sum, na.rm = TRUE)
-        if (repulse) {
-            f.x <- f.x - apply(cos(theta) * ep[3]/(dis/ep[4])^3, 
-                1, sum, na.rm = TRUE)
-            f.y <- f.y - apply(sin(theta) * ep[3]/(dis/ep[4])^3, 
-                1, sum, na.rm = TRUE)
-        }
-        v.x <- v.x + f.x/ep[1]
-        v.y <- v.y + f.y/ep[1]
-        spd <- sqrt(v.x^2 + v.y^2)
-        fmag <- pmin(spd, kfr)
-        theta <- acos(v.x/spd) * sign(v.y)
-        f.x <- fmag * cos(theta)
-        f.y <- fmag * sin(theta)
-        f.x[is.nan(f.x)] <- 0
-        f.y[is.nan(f.y)] <- 0
-        v.x <- v.x - f.x
-        v.y <- v.y - f.y
-        x <- x + v.x
-        y <- y + v.y
-        mdist <- mean(dis)
-        if (all(v.x < mdist * 1e-05) && all(v.y < mdist * 1e-05)) 
-            break
-        else kfr <- ep[5] * exp(0.1 * niter)
-    }
-    cbind(x, y)
-}
-
-gplot.layout.springrepulse (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$repulse <- TRUE
-    gplot.layout.spring(d, layout.par)
-}
-
-gplot.layout.target (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- NROW(d)
-    if (is.null(layout.par$niter)) {
-        niter <- 1000
-    }
-    else niter <- layout.par$niter
-    if (is.null(layout.par$radii)) {
-        temp <- degree(d)
-        offset <- min(sum(temp == max(temp))/(n - 1), 0.5)
-        radii <- 1 - (temp - min(temp))/(diff(range(temp)) + 
-            offset)
-    }
-    else radii <- layout.par$radii
-    if (is.null(layout.par$minlen)) {
-        minlen <- 0.05
-    }
-    else minlen <- layout.par$minlen
-    if (is.null(layout.par$initemp)) {
-        initemp <- 10
-    }
-    else initemp <- layout.par$initemp
-    if (is.null(layout.par$coolexp)) {
-        coolexp <- 0.99
-    }
-    else coolexp <- layout.par$coolexp
-    if (is.null(layout.par$maxdelta)) {
-        maxdelta <- pi
-    }
-    else maxdelta <- layout.par$maxdelta
-    if (is.null(layout.par$periph.outside)) {
-        periph.outside <- FALSE
-    }
-    else periph.outside <- layout.par$periph.outside
-    if (is.null(layout.par$periph.outside.offset)) {
-        periph.outside.offset <- 1.2
-    }
-    else periph.outside.offset <- layout.par$periph.outside.offset
-    if (is.null(layout.par$disconst)) {
-        disconst <- 1
-    }
-    else disconst <- layout.par$disconst
-    if (is.null(layout.par$crossconst)) {
-        crossconst <- 1
-    }
-    else crossconst <- layout.par$crossconst
-    if (is.null(layout.par$repconst)) {
-        repconst <- 1
-    }
-    else repconst <- layout.par$repconst
-    if (is.null(layout.par$minpdis)) {
-        minpdis <- 0.05
-    }
-    else minpdis <- layout.par$minpdis
-    theta <- runif(n, 0, 2 * pi)
-    core <- apply(d & t(d), 1, any)
-    if (periph.outside) 
-        radii[!core] <- periph.outside.offset
-    elen <- abs(outer(radii, radii, "-"))
-    elen[elen < minlen] <- (outer(radii, radii, "+")/sqrt(2))[elen < 
-        minlen]
-    elen <- geodist(elen * d, inf.replace = n)$gdist
-    pos <- .C("gplot_layout_target_R", as.integer(d), as.double(n), 
-        as.integer(niter), as.double(elen), as.double(radii), 
-        as.integer(core), as.double(disconst), as.double(crossconst), 
-        as.double(repconst), as.double(minpdis), as.double(initemp), 
-        as.double(coolexp), as.double(maxdelta), theta = as.double(theta), 
-        PACKAGE = "sna")
-    cbind(radii * cos(pos$theta), radii * sin(pos$theta))
-}
-
-gplot.loop (closure) = function (x0, y0, length = 0.1, angle = 10, width = 0.01, col = 1, 
-    border = 1, lty = 1, offset = 0, edge.steps = 10, radius = 1, 
-    arrowhead = TRUE, xctr = 0, yctr = 0, ...) 
-{
-    if (length(x0) == 0) 
-        return()
-    make.coords <- function(x0, y0, xctr, yctr, ahangle, ahlen, 
-        swid, off, rad, ahead) {
-        xoff <- x0 - xctr
-        yoff <- y0 - yctr
-        roff <- sqrt(xoff^2 + yoff^2)
-        x0hat <- xoff/roff
-        y0hat <- yoff/roff
-        r0.vertex <- off
-        r0.loop <- rad
-        x0.loop <- x0hat * r0.loop
-        y0.loop <- y0hat * r0.loop
-        ang <- (((0:edge.steps)/edge.steps) * (1 - (2 * r0.vertex + 
-            0.5 * ahlen * ahead)/(2 * pi * r0.loop)) + r0.vertex/(2 * 
-            pi * r0.loop)) * 2 * pi + atan2(-yoff, -xoff)
-        ang2 <- ((1 - (2 * r0.vertex)/(2 * pi * r0.loop)) + r0.vertex/(2 * 
-            pi * r0.loop)) * 2 * pi + atan2(-yoff, -xoff)
-        if (ahead) {
-            x0.arrow <- x0.loop + (r0.loop + swid/2) * cos(ang2)
-            y0.arrow <- y0.loop + (r0.loop + swid/2) * sin(ang2)
-            coord <- rbind(cbind(x0.loop + (r0.loop + swid/2) * 
-                cos(ang), y0.loop + (r0.loop + swid/2) * sin(ang)), 
-                cbind(x0.arrow + ahlen * cos(ang2 - pi/2), y0.arrow + 
-                  ahlen * sin(ang2 - pi/2)), cbind(x0.arrow, 
-                  y0.arrow), cbind(x0.arrow + ahlen * cos(-2 * 
-                  ahangle + ang2 - pi/2), y0.arrow + ahlen * 
-                  sin(-2 * ahangle + ang2 - pi/2)), cbind(x0.loop + 
-                  (r0.loop - swid/2) * cos(rev(ang)), y0.loop + 
-                  (r0.loop - swid/2) * sin(rev(ang))), c(NA, 
-                  NA))
-        }
-        else {
-            coord <- rbind(cbind(x0.loop + (r0.loop + swid/2) * 
-                cos(ang), y0.loop + (r0.loop + swid/2) * sin(ang)), 
-                cbind(x0.loop + (r0.loop - swid/2) * cos(rev(ang)), 
-                  y0.loop + (r0.loop - swid/2) * sin(rev(ang))), 
-                c(NA, NA))
-        }
-        coord[, 1] <- coord[, 1] + x0
-        coord[, 2] <- coord[, 2] + y0
-        coord
-    }
-    n <- length(x0)
-    angle <- rep(angle, length = n)/360 * 2 * pi
-    length <- rep(length, length = n)
-    width <- rep(width, length = n)
-    col <- rep(col, length = n)
-    border <- rep(border, length = n)
-    lty <- rep(lty, length = n)
-    rad <- rep(radius, length = n)
-    arrowhead <- rep(arrowhead, length = n)
-    offset <- rep(offset, length = n)
-    coord <- vector()
-    for (i in 1:n) coord <- rbind(coord, make.coords(x0[i], y0[i], 
-        xctr, yctr, angle[i], length[i], width[i], offset[i], 
-        rad[i], arrowhead[i]))
-    coord <- coord[-NROW(coord), ]
-    polygon(coord, col = col, border = border, lty = lty, ...)
-}
-
-gplot.target (closure) = function (dat, x, circ.rad = (1:10)/10, circ.col = "blue", circ.lwd = 1, 
-    circ.lty = 3, circ.lab = TRUE, circ.lab.cex = 0.75, circ.lab.theta = pi, 
-    circ.lab.col = 1, circ.lab.digits = 1, circ.lab.offset = 0.025, 
-    periph.outside = FALSE, periph.outside.offset = 1.2, ...) 
-{
-    offset <- min(0.5, sum(x == max(x))/(length(x) - 1))
-    xrange <- diff(range(x))
-    xmin <- min(x)
-    x <- 1 - (x - xmin)/(xrange + offset)
-    circ.val <- (1 - circ.rad) * (xrange + offset) + xmin
-    cl <- match.call()
-    if (is.null(cl$layout.par)) 
-        cl$layout.par <- list(radii = x)
-    else cl$layout.par$radii <- x
-    cl$layout.par$periph.outside <- periph.outside
-    cl$layout.par$periph.outside.offset <- periph.outside.offset
-    cl$x <- NULL
-    cl$circ.rad <- NULL
-    cl$circ.col <- NULL
-    cl$circ.lwd <- NULL
-    cl$circ.lty <- NULL
-    cl$circ.lab <- NULL
-    cl$circ.lab.theta <- NULL
-    cl$circ.lab.col <- NULL
-    cl$circ.lab.cex <- NULL
-    cl$circ.lab.digits <- NULL
-    cl$circ.lab.offset <- NULL
-    cl$periph.outside <- NULL
-    cl$periph.outside.offset <- NULL
-    cl$mode <- "target"
-    cl$xlim = c(-periph.outside.offset, periph.outside.offset)
-    cl$ylim = c(-periph.outside.offset, periph.outside.offset)
-    cl[[1]] <- match.fun("gplot")
-    coord <- eval(cl)
-    if (length(circ.col) < length(x)) 
-        circ.col <- rep(circ.col, length = length(x))
-    if (length(circ.lwd) < length(x)) 
-        circ.lwd <- rep(circ.lwd, length = length(x))
-    if (length(circ.lty) < length(x)) 
-        circ.lty <- rep(circ.lty, length = length(x))
-    for (i in 1:length(circ.rad)) segments(circ.rad[i] * sin(2 * 
-        pi/100 * (0:99)), circ.rad[i] * cos(2 * pi/100 * (0:99)), 
-        circ.rad[i] * sin(2 * pi/100 * (1:100)), circ.rad[i] * 
-            cos(2 * pi/100 * (1:100)), col = circ.col[i], lwd = circ.lwd[i], 
-        lty = circ.lty[i])
-    if (circ.lab) 
-        text((circ.rad + circ.lab.offset) * cos(circ.lab.theta), 
-            (circ.rad + circ.lab.offset) * sin(circ.lab.theta), 
-            round(circ.val, digits = circ.lab.digits), cex = circ.lab.cex, 
-            col = circ.lab.col)
-    invisible(coord)
-}
-
-gplot.vertex (closure) = function (x, y, radius = 1, sides = 4, border = 1, col = 2, lty = NULL, 
-    rot = 0, ...) 
-{
-    make.coords <- function(x, y, r, s, rot) {
-        ang <- (1:s)/s * 2 * pi + rot * 2 * pi/360
-        rbind(cbind(x + r * cos(ang), y + r * sin(ang)), c(NA, 
-            NA))
-    }
-    n <- length(x)
-    radius <- rep(radius, length = n)
-    sides <- rep(sides, length = n)
-    border <- rep(border, length = n)
-    col <- rep(col, length = n)
-    lty <- rep(lty, length = n)
-    rot <- rep(rot, length = n)
-    coord <- vector()
-    for (i in 1:length(x)) coord <- rbind(coord, make.coords(x[i], 
-        y[i], radius[i], sides[i], rot[i]))
-    polygon(coord, border = border, col = col, lty = lty, ...)
-}
-
-gplot3d (closure) = function (dat, g = 1, gmode = "digraph", diag = FALSE, label = NULL, 
-    coord = NULL, jitter = TRUE, thresh = 0, mode = "fruchtermanreingold", 
-    displayisolates = TRUE, displaylabels = !missing(label), 
-    xlab = NULL, ylab = NULL, zlab = NULL, vertex.radius = NULL, 
-    absolute.radius = FALSE, label.col = "gray50", edge.col = "black", 
-    vertex.col = NULL, edge.alpha = 1, vertex.alpha = 1, edge.lwd = NULL, 
-    suppress.axes = TRUE, new = TRUE, bg.col = "white", layout.par = NULL) 
-{
-    requireNamespace("rgl")
-    d <- as.edgelist.sna(dat, force.bipartite = (gmode == "twomode"))
-    if (is.list(d)) 
-        d <- d[[g]]
-    n <- attr(d, "n")
-    if (is.null(label)) {
-        if (displaylabels != TRUE) 
-            displaylabels <- FALSE
-        if (!is.null(attr(d, "vnames"))) 
-            label <- attr(d, "vnames")
-        else if ((gmode == "twomode") && (!is.null(attr(d, "bipartite")))) 
-            label <- c(paste("R", 1:attr(d, "bipartite"), sep = ""), 
-                paste("C", (attr(d, "bipartite") + 1):n, sep = ""))
-        else {
-            label <- 1:n
+                text(5, 4, "PASSED. No normalization for correcting length bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            length.plot(QCinfo$data$length, toreport = TRUE, 
+                samples = samples)
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for differences in RNA composition", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            if ("FAILED" %in% QCinfo$data$countdist$DiagnosticTest[, 
+                "Diagnostic Test"]) {
+                text(5, 5, "FAILED. There is a pair of samples with significantly different RNA composition", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            else {
+                text(5, 5, "PASSED. The pairs of compared samples do not present significant differences in RNA composition.", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is NOT required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            if (length(samples2) < 14) {
+                cd.plot(QCinfo$data$countdist, samples = samples2)
+            }
+            else {
+                cd.plot(QCinfo$data$countdist, samples = setdiff(samples2, 
+                  QCinfo$data$countdist$refColumn)[1:12])
+            }
+            par(mar = c(0, 0, 0, 0))
+            lugares = c(1, 4.5, 6.5, 8.5)
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(lugares[1], 10, "Confidence intervals for median of M values", 
+                adj = 0, font = 2, cex = 1.2)
+            text(lugares[1], 9.4, "Sample", adj = 0, font = 1, 
+                cex = 1)
+            abline(h = 9.2, lty = 2, col = "grey")
+            for (j in 1:3) {
+                text(lugares[j + 1], 9.4, colnames(QCinfo$data$countdist$DiagnosticTest)[j], 
+                  adj = 0, font = 1, cex = 1)
+                for (i in 1:min(30, nrow(QCinfo$data$countdist$DiagnosticTest))) {
+                  if (j == 1) 
+                    text(lugares[j], 9.2 - i * 0.3, rownames(QCinfo$data$countdist$DiagnosticTest)[i], 
+                      adj = 0, font = 1, cex = 1)
+                  if (j < 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 1, 
+                      font = 1, cex = 1, round(as.numeric(QCinfo$data$countdist$DiagnosticTest[i, 
+                        j]), 4))
+                  if (j == 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 0, 
+                      font = 1, cex = 1, QCinfo$data$countdist$DiagnosticTest[i, 
+                        j])
+                }
+            }
+            if (nrow(QCinfo$data$countdist$DiagnosticTest) > 
+                30) {
+                print("WARNING: In Diagnostic Test for RNA composition, the confidence intervals are shown for only \n              the first 30 samples.")
+            }
         }
     }
-    if (gmode == "graph") {
-        usearrows <- FALSE
-    }
-    else if (gmode == "twomode") {
-        if (is.null(vertex.col)) 
-            vertex.col <- rep(c("red", "blue"), times = c(attr(d, 
-                "bipartite"), n - attr(d, "bipartite")))
-    }
-    if (is.null(vertex.col)) 
-        vertex.col <- "red"
-    d <- d[!is.na(d[, 3]), , drop = FALSE]
-    d.raw <- d
-    d <- d[d[, 3] > thresh, , drop = FALSE]
-    attr(d, "n") <- n
-    if (!is.null(coord)) {
-        x <- coord[, 1]
-        y <- coord[, 2]
-        z <- coord[, 3]
-    }
-    else {
-        layout.fun <- try(match.fun(paste("gplot3d.layout.", 
-            mode, sep = "")), silent = TRUE)
-        if (inherits(layout.fun, "try-error")) 
-            stop("Error in gplot3d: no layout function for mode ", 
-                mode)
-        temp <- layout.fun(d, layout.par)
-        x <- temp[, 1]
-        y <- temp[, 2]
-        z <- temp[, 3]
-    }
-    if (jitter) {
-        x <- jitter(x)
-        y <- jitter(y)
-        z <- jitter(z)
-    }
-    use <- displayisolates | (!is.isolate(d, ego = 1:n))
-    if (is.null(xlab)) 
-        xlab = ""
-    if (is.null(ylab)) 
-        ylab = ""
-    if (is.null(zlab)) 
-        zlab = ""
-    if (new) {
-        rgl::rgl.clear()
-        if (!suppress.axes) 
-            rgl::rgl.bbox(xlab = xlab, ylab = ylab, zlab = zlab)
-    }
-    rgl::rgl.bg(color = bg.col)
-    temp <- as.matrix(dist(cbind(x[use], y[use], z[use])))
-    diag(temp) <- Inf
-    baserad <- min(temp)/5
-    if (is.null(vertex.radius)) {
-        vertex.radius <- rep(baserad, n)
-    }
-    else if (absolute.radius) 
-        vertex.radius <- rep(vertex.radius, length = n)
-    else vertex.radius <- rep(vertex.radius * baserad, length = n)
-    vertex.col <- rep(vertex.col, length = n)
-    vertex.alpha <- rep(vertex.alpha, length = n)
-    if (!all(use == FALSE)) 
-        rgl::rgl.spheres(x[use], y[use], z[use], radius = vertex.radius[use], 
-            color = vertex.col[use], alpha = vertex.alpha[use])
-    pt <- vector()
-    ph <- vector()
-    e.lwd <- vector()
-    e.col <- vector()
-    e.alpha <- vector()
-    e.diag <- vector()
-    if (length(dim(edge.col)) == 2) 
-        edge.col <- edge.col[d[, 1:2]]
-    else edge.col <- rep(edge.col, length = NROW(d))
-    if (is.null(edge.lwd)) {
-        edge.lwd <- 0.5 * apply(cbind(vertex.radius[d[, 1]], 
-            vertex.radius[d[, 2]]), 1, min) + vertex.radius[d[, 
-            1]] * (d[, 1] == d[, 2])
-    }
-    else if (length(dim(edge.lwd)) == 2) {
-        edge.lwd <- edge.lwd[d[, 1:2]]
-    }
-    else {
-        if (edge.lwd == 0) 
-            edge.lwd <- 0.5 * apply(cbind(vertex.radius[d[, 1]], 
-                vertex.radius[d[, 2]]), 1, min) + vertex.radius[d[, 
-                1]] * (d[, 1] == d[, 2])
-        else edge.lwd <- rep(edge.lwd, length = NROW(d))
-    }
-    if (length(dim(edge.alpha)) == 2) {
-        edge.alpha <- edge.alpha[d[, 1:2]]
-    }
-    else {
-        edge.alpha <- rep(edge.alpha, length = NROW(d))
-    }
-    for (i in 1:NROW(d)) if (use[d[i, 1]] && use[d[i, 2]]) {
-        pt <- rbind(pt, as.double(c(x[d[i, 1]], y[d[i, 1]], z[d[i, 
-            1]])))
-        ph <- rbind(ph, as.double(c(x[d[i, 2]], y[d[i, 2]], z[d[i, 
-            2]])))
-        e.col <- c(e.col, edge.col[i])
-        e.alpha <- c(e.alpha, edge.alpha[i])
-        e.lwd <- c(e.lwd, edge.lwd[i])
-        e.diag <- c(e.diag, d[i, 1] == d[i, 2])
-    }
-    m <- NROW(pt)
-    if (diag && (m > 0) && sum(e.diag > 0)) {
-        gplot3d.loop(pt[e.diag, ], radius = e.lwd[e.diag], color = e.col[e.diag], 
-            alpha = e.alpha[e.diag])
-    }
-    if (m > 0) {
-        pt <- pt[!e.diag, ]
-        ph <- ph[!e.diag, ]
-        e.alpha <- e.alpha[!e.diag]
-        e.lwd <- e.lwd[!e.diag]
-        e.col <- e.col[!e.diag]
-    }
-    if (length(e.alpha) > 0) {
-        gplot3d.arrow(pt, ph, radius = e.lwd, color = e.col, 
-            alpha = e.alpha)
-    }
-    if (displaylabels & (!all(label == "")) & (!all(use == FALSE))) {
-        rgl::rgl.texts(x[use] - vertex.radius[use], y[use], z[use], 
-            label[use], color = label.col)
-    }
-    invisible(cbind(x, y, z))
-}
-
-gplot3d.arrow (closure) = function (a, b, radius, color = "white", alpha = 1) 
-{
-    make.coords <- function(a, b, radius) {
-        alen <- sqrt(sum((a - b)^2))
-        xos <- radius * sin(pi/8)
-        yos <- radius * cos(pi/8)
-        basetri <- rbind(c(-xos, -yos, 0), c(0, 0, alen), c(xos, 
-            -yos, 0))
-        coord <- vector()
-        for (i in (1:8)/8 * 2 * pi) {
-            rmat <- rbind(c(cos(i), sin(i), 0), c(-sin(i), cos(i), 
-                0), c(0, 0, 1))
-            coord <- rbind(coord, basetri %*% rmat)
-        }
-        phi <- -atan2(b[2] - a[2], a[1] - b[1]) - pi/2
-        psi <- acos((b[3] - a[3])/alen)
-        coord <- coord %*% rbind(c(1, 0, 0), c(0, cos(psi), sin(psi)), 
-            c(0, -sin(psi), cos(psi)))
-        coord <- coord %*% rbind(c(cos(phi), sin(phi), 0), c(-sin(phi), 
-            cos(phi), 0), c(0, 0, 1))
-        coord[, 1] <- coord[, 1] + a[1]
-        coord[, 2] <- coord[, 2] + a[2]
-        coord[, 3] <- coord[, 3] + a[3]
-        coord
-    }
-    if (is.null(dim(a))) {
-        a <- matrix(a, ncol = 3)
-        b <- matrix(b, ncol = 3)
-    }
-    n <- NROW(a)
-    radius <- rep(radius, length = n)
-    color <- rep(color, length = n)
-    alpha <- rep(alpha, length = n)
-    coord <- vector()
-    for (i in 1:n) coord <- rbind(coord, make.coords(a[i, ], 
-        b[i, ], radius[i]))
-    rgl::rgl.triangles(coord[, 1], coord[, 2], coord[, 3], color = rep(color, 
-        each = 24), alpha = rep(alpha, each = 24))
-}
-
-gplot3d.layout.adj (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "invadj"
-    layout.par$dist = "none"
-    layout.par$exp = 1
-    gplot3d.layout.mds(d, layout.par)
-}
-
-gplot3d.layout.eigen (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- d
-    else vm <- switch(layout.par$var, symupper = symmetrize(d, 
-        rule = "uppper"), symlower = symmetrize(d, rule = "lower"), 
-        symstrong = symmetrize(d, rule = "strong"), symweak = symmetrize(d, 
-            rule = "weak"), user = layout.par$mat, raw = d)
-    e <- eigen(vm)
-    if (is.null(layout.par$evsel)) 
-        coord <- Re(e$vectors[, 1:3])
-    else coord <- switch(layout.par$evsel, first = Re(e$vectors[, 
-        1:3]), size = Re(e$vectors[, rev(order(abs(e$values)))[1:3]]))
-    coord
-}
-
-gplot3d.layout.fruchtermanreingold (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$niter)) 
-        niter <- 300
-    else niter <- layout.par$niter
-    if (is.null(layout.par$max.delta)) 
-        max.delta <- n
-    else max.delta <- layout.par$max.delta
-    if (is.null(layout.par$volume)) 
-        volume <- n^3
-    else volume <- layout.par$volume
-    if (is.null(layout.par$cool.exp)) 
-        cool.exp <- 3
-    else cool.exp <- layout.par$cool.exp
-    if (is.null(layout.par$repulse.rad)) 
-        repulse.rad <- volume * n
-    else repulse.rad <- layout.par$repulse.rad
-    if (is.null(layout.par$seed.coord)) {
-        tempa <- runif(n, 0, 2 * pi)
-        tempb <- runif(n, 0, pi)
-        x <- n * sin(tempb) * cos(tempa)
-        y <- n * sin(tempb) * sin(tempa)
-        z <- n * cos(tempb)
-    }
-    else {
-        x <- layout.par$seed.coord[, 1]
-        y <- layout.par$seed.coord[, 2]
-        z <- layout.par$seed.coord[, 3]
-    }
-    d <- symmetrize(d, return.as.edgelist = TRUE)
-    layout <- .C("gplot3d_layout_fruchtermanreingold_R", as.double(d), 
-        as.integer(n), as.integer(NROW(d)), as.integer(niter), 
-        as.double(max.delta), as.double(volume), as.double(cool.exp), 
-        as.double(repulse.rad), x = as.double(x), y = as.double(y), 
-        z = as.double(z), PACKAGE = "sna")
-    cbind(layout$x, layout$y, layout$z)
-}
-
-gplot3d.layout.geodist (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "geodist"
-    layout.par$dist = "none"
-    layout.par$exp = 1
-    gplot3d.layout.mds(d, layout.par)
-}
-
-gplot3d.layout.hall (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- NCOL(d)
-    sd <- symmetrize(d)
-    laplacian <- -sd
-    diag(laplacian) <- degree(sd, cmode = "indegree")
-    eigen(laplacian)$vec[, (n - 1):(n - 3)]
-}
-
-gplot3d.layout.kamadakawai (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$niter)) {
-        niter <- 1000
-    }
-    else niter <- layout.par$niter
-    if (is.null(layout.par$sigma)) {
-        sigma <- n/4
-    }
-    else sigma <- layout.par$sigma
-    if (is.null(layout.par$initemp)) {
-        initemp <- 10
-    }
-    else initemp <- layout.par$initemp
-    if (is.null(layout.par$coolexp)) {
-        coolexp <- 0.99
-    }
-    else coolexp <- layout.par$coolexp
-    if (is.null(layout.par$kkconst)) {
-        kkconst <- n^3
-    }
-    else kkconst <- layout.par$kkconst
-    if (is.null(layout.par$edge.val.as.str)) 
-        edge.val.as.str <- TRUE
-    else edge.val.as.str <- layout.par$edge.val.as.str
-    if (is.null(layout.par$elen)) {
-        d <- symmetrize(d, return.as.edgelist = TRUE)
-        if (edge.val.as.str) 
-            d[, 3] <- 1/d[, 3]
-        elen <- geodist(d, ignore.eval = FALSE)$gdist
-        elen[elen == Inf] <- max(elen[is.finite(elen)]) * 1.5
-    }
-    else elen <- layout.par$elen
-    if (is.null(layout.par$seed.coord)) {
-        x <- rnorm(n, 0, n/4)
-        y <- rnorm(n, 0, n/4)
-        z <- rnorm(n, 0, n/4)
-    }
-    else {
-        x <- layout.par$seed.coord[, 1]
-        y <- layout.par$seed.coord[, 2]
-        z <- layout.par$seed.coord[, 3]
-    }
-    pos <- .C("gplot3d_layout_kamadakawai_R", as.double(n), as.integer(niter), 
-        as.double(elen), as.double(initemp), as.double(coolexp), 
-        as.double(kkconst), as.double(sigma), x = as.double(x), 
-        y = as.double(y), z = as.double(z), PACKAGE = "sna")
-    cbind(pos$x, pos$y, pos$z)
-}
-
-gplot3d.layout.mds (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- cbind(d, t(d))
-    else vm <- switch(layout.par$var, rowcol = cbind(d, t(d)), 
-        col = t(d), row = d, rcsum = d + t(d), rcdiff = t(d) - 
-            d, invadj = max(d) - d, geodist = geodist(d, inf.replace = NROW(d))$gdist, 
-        user = layout.par$vm)
-    if (is.null(layout.par$dist)) 
-        dm <- as.matrix(dist(vm))
-    else dm <- switch(layout.par$dist, euclidean = as.matrix(dist(vm)), 
-        maximum = as.matrix(dist(vm, method = "maximum")), manhattan = as.matrix(dist(vm, 
-            method = "manhattan")), canberra = as.matrix(dist(vm, 
-            method = "canberra")), none = vm)
-    if (is.null(layout.par$exp)) 
-        dm <- dm^2
-    else dm <- dm^layout.par$exp
-    cmdscale(dm, 3)
-}
-
-gplot3d.layout.princoord (closure) = function (d, layout.par) 
-{
-    d <- as.sociomatrix.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    if (is.null(layout.par$var)) 
-        vm <- rbind(d, t(d))
-    else vm <- switch(layout.par$var, rowcol = rbind(d, t(d)), 
-        col = d, row = t(d), rcsum = d + t(d), rcdiff = d - t(d), 
-        user = layout.par$vm)
-    if (is.null(layout.par$cor) || layout.par$cor) 
-        cd <- cor(vm, use = "pairwise.complete.obs")
-    else cd <- cov(vm, use = "pairwise.complete.obs")
-    cd <- replace(cd, is.na(cd), 0)
-    e <- eigen(cd, symmetric = TRUE)
-    x <- Re(e$vectors[, 1])
-    y <- Re(e$vectors[, 2])
-    z <- Re(e$vectors[, 3])
-    cbind(x, y, z)
-}
-
-gplot3d.layout.random (closure) = function (d, layout.par) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        d <- d[[1]]
-    n <- attr(d, "n")
-    if (is.null(layout.par$dist)) 
-        temp <- matrix(runif(3 * n, -1, 1), n, 3)
-    else if (layout.par$dist == "unif") 
-        temp <- matrix(runif(3 * n, -1, 1), n, 3)
-    else if (layout.par$dist == "uniang") {
-        tempd <- rnorm(n, 1, 0.25)
-        tempa <- runif(n, 0, 2 * pi)
-        tempb <- runif(n, 0, pi)
-        temp <- cbind(tempd * sin(tempb) * cos(tempa), tempd * 
-            sin(tempb) * sin(tempa), tempd * cos(tempb))
-    }
-    else if (layout.par$dist == "normal") 
-        temp <- matrix(rnorm(3 * n), n, 3)
-    temp
-}
-
-gplot3d.layout.rmds (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "row"
-    layout.par$dist = "euclidean"
-    layout.par$exp = 1
-    gplot3d.layout.mds(d, layout.par)
-}
-
-gplot3d.layout.segeo (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "geodist"
-    layout.par$dist = "euclidean"
-    gplot3d.layout.mds(d, layout.par)
-}
-
-gplot3d.layout.seham (closure) = function (d, layout.par) 
-{
-    if (is.null(layout.par)) 
-        layout.par <- list()
-    layout.par$var = "rowcol"
-    layout.par$dist = "manhattan"
-    layout.par$exp = 1
-    gplot3d.layout.mds(d, layout.par)
-}
-
-gplot3d.loop (closure) = function (a, radius, color = "white", alpha = 1) 
-{
-    make.coords <- function(a, radius) {
-        coord <- rbind(cbind(a[1] + c(0, -radius/2, 0), a[2] + 
-            c(0, radius/2, radius/2), a[3] + c(0, 0, radius/4), 
-            c(NA, NA, NA)), cbind(a[1] + c(0, -radius/2, 0), 
-            a[2] + c(0, radius/2, radius/2), a[3] + c(0, 0, -radius/4), 
-            c(NA, NA, NA)), cbind(a[1] + c(0, radius/2, 0), a[2] + 
-            c(0, radius/2, radius/2), a[3] + c(0, 0, radius/4), 
-            c(NA, NA, NA)), cbind(a[1] + c(0, radius/2, 0), a[2] + 
-            c(0, radius/2, radius/2), a[3] + c(0, 0, -radius/4), 
-            c(NA, NA, NA)), cbind(a[1] + c(0, -radius/2, 0), 
-            a[2] + c(radius, radius/2, radius/2), a[3] + c(0, 
-                0, radius/4), c(NA, NA, NA)), cbind(a[1] + c(0, 
-            -radius/2, 0), a[2] + c(radius, radius/2, radius/2), 
-            a[3] + c(0, 0, -radius/4), c(NA, NA, NA)), cbind(a[1] + 
-            c(0, radius/2, 0), a[2] + c(radius, radius/2, radius/2), 
-            a[3] + c(0, 0, radius/4), c(NA, NA, NA)), cbind(a[1] + 
-            c(0, radius/2, 0), a[2] + c(radius, radius/2, radius/2), 
-            a[3] + c(0, 0, -radius/4), c(NA, NA, NA)))
-    }
-    if (is.null(dim(a))) {
-        a <- matrix(a, ncol = 3)
-    }
-    n <- NROW(a)
-    radius <- rep(radius, length = n)
-    color <- rep(color, length = n)
-    alpha <- rep(alpha, length = n)
-    coord <- vector()
-    for (i in 1:n) coord <- rbind(coord, make.coords(a[i, ], 
-        radius[i]))
-    rgl::rgl.triangles(coord[, 1], coord[, 2], coord[, 3], color = rep(color, 
-        each = 24), alpha = rep(alpha, each = 24))
-}
-
-graphcent (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "directed", geodist.precomp = NULL, 
-    rescale = FALSE, ignore.eval = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], graphcent, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            geodist.precomp = geodist.precomp, rescale = rescale, 
-            ignore.eval = ignore.eval))
-    if (gmode == "graph") 
-        cmode <- "undirected"
-    n <- attr(dat, "n")
-    if (tmaxdev) {
-        gc <- switch(cmode, directed = (n - 1) * (1 - 1/n), undirected = (n - 
-            1)/2)
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode == "undirected") 
-            dat <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-        if (is.null(geodist.precomp)) 
-            gd <- geodist(dat, count.paths = FALSE, predecessors = FALSE, 
-                ignore.eval = ignore.eval)
-        else gd <- geodist.precomp
-        gc <- apply(gd$gdist, 1, max)
-        gc <- 1/gc
-        if (rescale) 
-            gc <- gc/sum(gc)
-        gc <- gc[nodes]
-    }
-    gc
-}
-
-grecip (closure) = function (dat, g = NULL, measure = c("dyadic", "dyadic.nonnull", 
-    "edgewise", "edgewise.lrr", "correlation")) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (!is.null(g)) 
-            dat <- dat[g]
-    }
-    if (match.arg(measure) == "correlation") {
-        if (!is.list(dat)) 
-            dat <- list(dat)
-        recip <- sapply(dat, function(z) {
-            n <- attr(z, "n")
-            nd <- choose(n, 2)
-            ne <- nd * 2
-            z <- z[z[, 1] != z[, 2], , drop = FALSE]
-            if (n < 2) {
-                return(NA)
-            }
-            else if (n == 2) {
-                if (NROW(z) == 0) 
-                  return(1)
-                else if (any(is.na(z[, 3]))) 
-                  return(NA)
-                else if (NROW(z) == 1) {
-                  if (z[1, 3] != 0) 
-                    return(0)
-                  else return(1)
+    else {
+        if (QCinfo$parameters$GC) {
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for GC content bias", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            laF = lapply(QCinfo$data$GC$RegressionModels[samples], 
+                function(x) summary(x)$fstatistic)
+            pvalores = sapply(laF, function(x) pf(x[1], df1 = x[2], 
+                df2 = x[3], lower.tail = FALSE))
+            misR2 = sapply(QCinfo$data$GC$RegressionModels[samples], 
+                function(x) summary(x)$r.squared)
+            if (min(pvalores) < QQ) {
+                if (max(misR2) > 0.7) {
+                  text(5, 5, "FAILED. At least one of the model p-values was lower than 0.05 and R2 > 70%.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting GC content bias is recommended.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
-                else return((z[1, 3] == z[2, 3]) + 0)
-            }
-            if (NROW(z) > 0) {
-                emiss <- sum(is.na(z[, 3]))
-                gm <- sum(z[, 3], na.rm = TRUE)/(ne - emiss)
-                gv <- (sum((z[, 3] - gm)^2, na.rm = TRUE) + (ne - 
-                  NROW(z)) * gm^2)/(ne - emiss - 1)
-                if (gv == 0) 
-                  return(1)
-                dc <- .C("dyadcode_R", as.double(z), as.integer(n), 
-                  as.integer(NROW(z)), dc = as.double(rep(0, 
-                    NROW(z))), PACKAGE = "sna", NAOK = TRUE)$dc
-                odc <- order(dc)
-                zv <- z[odc, 3] - gm
-                dc <- dc[odc]
-                dsum <- 0
-                dmiss <- 0
-                dcount <- 0
-                i <- 1
-                while (i <= length(zv)) {
-                  if ((i < length(zv)) && (dc[i] == dc[i + 1])) {
-                    if (is.na(zv[i]) || is.na(zv[i + 1])) 
-                      dmiss <- dmiss + 1
-                    else {
-                      dsum <- dsum + zv[i] * zv[i + 1]
-                      dcount <- dcount + 1
-                    }
-                    i <- i + 2
-                  }
-                  else {
-                    if (is.na(zv[i])) 
-                      dmiss <- dmiss + 1
-                    else {
-                      dsum <- dsum - gm * zv[i]
-                      dcount <- dcount + 1
-                    }
-                    i <- i + 1
-                  }
+                else {
+                  text(5, 5, "WARNING. At least one of the model p-values was lower than 0.05, but R2 < 70% for at least one condition.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 3, "Normalization for correcting GC content bias could be advisable.", 
+                    adj = 0.5, font = 1, cex = 1)
+                  text(5, 2, "Plese check in the plots below the strength of the relationship between GC content and expression.", 
+                    adj = 0.5, font = 1, cex = 1)
                 }
-                return(2 * (dsum + gm^2 * (nd - dcount - dmiss))/((2 * 
-                  nd - 2 * dmiss - 1) * gv))
             }
             else {
-                return(1)
+                text(5, 4, "PASSED. No normalization for correcting GC content bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            GC.plot(QCinfo$data$GC, toreport = TRUE, samples = samples)
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for differences in RNA composition", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            if ("FAILED" %in% QCinfo$data$countdist$DiagnosticTest[, 
+                "Diagnostic Test"]) {
+                text(5, 5, "FAILED. There is a pair of samples with significantly different RNA composition", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            else {
+                text(5, 5, "PASSED. The pairs of compared samples do not present significant differences in RNA composition.", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is NOT required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            if (length(samples2) < 14) {
+                cd.plot(QCinfo$data$countdist, samples = samples2)
+            }
+            else {
+                cd.plot(QCinfo$data$countdist, samples = setdiff(samples2, 
+                  QCinfo$data$countdist$refColumn)[1:12])
+            }
+            par(mar = c(0, 0, 0, 0))
+            lugares = c(1, 4.5, 6.5, 8.5)
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(lugares[1], 10, "Confidence intervals for median of M values", 
+                adj = 0, font = 2, cex = 1.2)
+            text(lugares[1], 9.4, "Sample", adj = 0, font = 1, 
+                cex = 1)
+            abline(h = 9.2, lty = 2, col = "grey")
+            for (j in 1:3) {
+                text(lugares[j + 1], 9.4, colnames(QCinfo$data$countdist$DiagnosticTest)[j], 
+                  adj = 0, font = 1, cex = 1)
+                for (i in 1:min(30, nrow(QCinfo$data$countdist$DiagnosticTest))) {
+                  if (j == 1) 
+                    text(lugares[j], 9.2 - i * 0.3, rownames(QCinfo$data$countdist$DiagnosticTest)[i], 
+                      adj = 0, font = 1, cex = 1)
+                  if (j < 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 1, 
+                      font = 1, cex = 1, round(as.numeric(QCinfo$data$countdist$DiagnosticTest[i, 
+                        j]), 4))
+                  if (j == 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 0, 
+                      font = 1, cex = 1, QCinfo$data$countdist$DiagnosticTest[i, 
+                        j])
+                }
+            }
+            if (nrow(QCinfo$data$countdist$DiagnosticTest) > 
+                30) {
+                print("WARNING: In Diagnostic Test for RNA composition, the confidence intervals are shown for only \n              the first 30 samples.")
             }
-        })
-    }
-    else {
-        dc <- dyad.census(dat)
-        recip <- switch(match.arg(measure), dyadic = (dc[, 1] + 
-            dc[, 3])/(dc[, 1] + dc[, 2] + dc[, 3]), dyadic.nonnull = dc[, 
-            1]/(dc[, 1] + dc[, 2]), edgewise = 2 * dc[, 1]/(2 * 
-            dc[, 1] + dc[, 2]), edgewise.lrr = log(dc[, 1] * 
-            (dc[, 1] + dc[, 2] + dc[, 3])/(dc[, 1] + dc[, 2]/2)^2))
-    }
-    recip
-}
-
-gscor (closure) = function (dat, dat2 = NULL, g1 = NULL, g2 = NULL, diag = FALSE, 
-    mode = "digraph", method = "anneal", reps = 1000, prob.init = 0.9, 
-    prob.decay = 0.85, freeze.time = 25, full.neighborhood = TRUE, 
-    exchange.list = 0) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in gscor.")
-    if (!is.null(dat2)) {
-        dat2 <- as.sociomatrix.sna(dat2)
-        if (is.list(dat2)) 
-            stop("Identical graph orders required in gscor.")
-    }
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (!is.null(dat2)) {
-        if (length(dim(dat)) > 2) 
-            temp1 <- dat
-        else {
-            temp1 <- array(dim = c(1, dim(dat)[2], dim(dat)[2]))
-            temp1[1, , ] <- dat
-        }
-        if (length(dim(dat2)) > 2) 
-            temp2 <- dat2
-        else {
-            temp2 <- array(dim = c(1, dim(dat2)[2], dim(dat2)[2]))
-            temp2[1, , ] <- dat2
-        }
-        if (dim(temp1)[2] > dim(temp2)[2]) 
-            temp2 <- add.isolates(temp2, dim(temp1)[2] - dim(temp2)[2])
-        if (dim(temp2)[2] > dim(temp1)[2]) 
-            temp1 <- add.isolates(temp1, dim(temp2)[2] - dim(temp1)[2])
-        n <- dim(temp1)[2]
-        gn <- dim(temp1)[1] + dim(temp2)[1]
-        gn1 <- dim(temp1)[1]
-        gn2 <- dim(temp2)[1]
-        d <- array(dim = c(gn, n, n))
-        d[1:gn1, , ] <- temp1
-        d[(gn1 + 1):(gn2 + gn1), , ] <- temp2
-        g1 <- 1:gn1
-        g2 <- (gn1 + 1):(gn1 + gn2)
-    }
-    else {
-        d <- dat
-        n <- dim(dat)[2]
-        gn <- dim(dat)[1]
-        gn1 <- length(g1)
-        gn2 <- length(g2)
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, gn * n), nrow = gn, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, gn)
-        }
-    }
-    else el <- exchange.list
-    gd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(gd) <- g1
-    colnames(gd) <- g2
-    if (method == "none") {
-        for (i in 1:gn1) for (j in 1:gn2) {
-            d1 <- d[g1[i], order(el[1, ]), order(el[1, ])]
-            d2 <- d[g2[j], order(el[2, ]), order(el[2, ])]
-            if (any(el[1, ] != el[2, ])) 
-                stop("Illegal exchange list; lists must be comparable!\n")
-            gd[i, j] <- cor(as.vector(d1), as.vector(d2), use = "complete.obs")
-        }
-    }
-    else if (method == "exhaustive") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.exhaustive(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cor(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max")
-    }
-    else if (method == "anneal") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.anneal(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cor(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max", 
-            prob.init = prob.init, prob.decay = prob.decay, freeze.time = freeze.time, 
-            full.neighborhood = full.neighborhood)
-    }
-    else if (method == "hillclimb") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.hillclimb(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cor(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max")
-    }
-    else if (method == "mc") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.mc(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cor(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max", 
-            draws = reps)
-    }
-    if ((gn1 == 1) & (gn2 == 1)) 
-        gd[1, 1]
-    else gd
-}
-
-gscov (closure) = function (dat, dat2 = NULL, g1 = NULL, g2 = NULL, diag = FALSE, 
-    mode = "digraph", method = "anneal", reps = 1000, prob.init = 0.9, 
-    prob.decay = 0.85, freeze.time = 25, full.neighborhood = TRUE, 
-    exchange.list = 0) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in gscov.")
-    if (!is.null(dat2)) {
-        dat2 <- as.sociomatrix.sna(dat2)
-        if (is.list(dat2)) 
-            stop("Identical graph orders required in gscov.")
-    }
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (!is.null(dat2)) {
-        if (length(dim(dat)) > 2) 
-            temp1 <- dat
-        else {
-            temp1 <- array(dim = c(1, dim(dat)[2], dim(dat)[2]))
-            temp1[1, , ] <- dat
-        }
-        if (length(dim(dat2)) > 2) 
-            temp2 <- dat2
-        else {
-            temp2 <- array(dim = c(1, dim(dat2)[2], dim(dat2)[2]))
-            temp2[1, , ] <- dat2
-        }
-        if (dim(temp1)[2] > dim(temp2)[2]) 
-            temp2 <- add.isolates(temp2, dim(temp1)[2] - dim(temp2)[2])
-        if (dim(temp2)[2] > dim(temp1)[2]) 
-            temp1 <- add.isolates(temp1, dim(temp2)[2] - dim(temp1)[2])
-        n <- dim(temp1)[2]
-        gn <- dim(temp1)[1] + dim(temp2)[1]
-        gn1 <- dim(temp1)[1]
-        gn2 <- dim(temp2)[1]
-        d <- array(dim = c(gn, n, n))
-        d[1:gn1, , ] <- temp1
-        d[(gn1 + 1):(gn2 + gn1), , ] <- temp2
-        g1 <- 1:gn1
-        g2 <- (gn1 + 1):(gn1 + gn2)
-    }
-    else {
-        d <- dat
-        n <- dim(dat)[2]
-        gn <- dim(dat)[1]
-        gn1 <- length(g1)
-        gn2 <- length(g2)
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, gn * n), nrow = gn, 
-                ncol = n)
         }
         else {
-            el <- sapply(exchange.list, rep, gn)
+            par(mar = c(0, 0, 0, 0))
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(5, 8, "Diagnostic plot for differences in RNA composition", 
+                adj = 0.5, font = 4, cex = 1.5, col = "aquamarine4")
+            if ("FAILED" %in% QCinfo$data$countdist$DiagnosticTest[, 
+                "Diagnostic Test"]) {
+                text(5, 5, "FAILED. There is a pair of samples with significantly different RNA composition", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            else {
+                text(5, 5, "PASSED. The pairs of compared samples do not present significant differences in RNA composition.", 
+                  adj = 0.5, font = 1, cex = 1)
+                text(5, 3, "Normalization for correcting this bias is NOT required.", 
+                  adj = 0.5, font = 1, cex = 1)
+            }
+            par(mar = c(5.1, 4.1, 4.1, 2.1))
+            if (length(samples2) < 14) {
+                cd.plot(QCinfo$data$countdist, samples = samples2)
+            }
+            else {
+                cd.plot(QCinfo$data$countdist, samples = setdiff(samples2, 
+                  QCinfo$data$countdist$refColumn)[1:12])
+            }
+            par(mar = c(0, 0, 0, 0))
+            lugares = c(1, 4.5, 6.5, 8.5)
+            plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", 
+                ylab = "")
+            text(lugares[1], 10, "Confidence intervals for median of M values", 
+                adj = 0, font = 2, cex = 1.2)
+            text(lugares[1], 9.4, "Sample", adj = 0, font = 1, 
+                cex = 1)
+            abline(h = 9.2, lty = 2, col = "grey")
+            for (j in 1:3) {
+                text(lugares[j + 1], 9.4, colnames(QCinfo$data$countdist$DiagnosticTest)[j], 
+                  adj = 0, font = 1, cex = 1)
+                for (i in 1:min(30, nrow(QCinfo$data$countdist$DiagnosticTest))) {
+                  if (j == 1) 
+                    text(lugares[j], 9.2 - i * 0.3, rownames(QCinfo$data$countdist$DiagnosticTest)[i], 
+                      adj = 0, font = 1, cex = 1)
+                  if (j < 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 1, 
+                      font = 1, cex = 1, round(as.numeric(QCinfo$data$countdist$DiagnosticTest[i, 
+                        j]), 4))
+                  if (j == 3) 
+                    text(lugares[j + 1], 9.2 - i * 0.3, adj = 0, 
+                      font = 1, cex = 1, QCinfo$data$countdist$DiagnosticTest[i, 
+                        j])
+                }
+            }
+            if (nrow(QCinfo$data$countdist$DiagnosticTest) > 
+                30) {
+                print("WARNING: In Diagnostic Test for RNA composition, the confidence intervals are shown for only \n              the first 30 samples.")
+            }
         }
     }
-    else el <- exchange.list
-    gd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(gd) <- g1
-    colnames(gd) <- g2
-    if (method == "none") {
-        for (i in 1:gn1) for (j in 1:gn2) {
-            d1 <- d[g1[i], order(el[1, ]), order(el[1, ])]
-            d2 <- d[g2[j], order(el[2, ]), order(el[2, ])]
-            if (any(el[1, ] != el[2, ])) 
-                stop("Illegal exchange list; lists must be comparable!\n")
-            gd[i, j] <- cov(as.vector(d1), as.vector(d2), use = "complete.obs")
-        }
-    }
-    else if (method == "exhaustive") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.exhaustive(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cov(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max")
-    }
-    else if (method == "anneal") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.anneal(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cov(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max", 
-            prob.init = prob.init, prob.decay = prob.decay, freeze.time = freeze.time, 
-            full.neighborhood = full.neighborhood)
-    }
-    else if (method == "hillclimb") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.hillclimb(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cov(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max")
-    }
-    else if (method == "mc") {
-        for (i in 1:gn1) for (j in 1:gn2) gd[i, j] <- lab.optimize.mc(d[g1[i], 
-            , ], d[g2[j], , ], function(m1, m2) {
-            cov(as.vector(m1), as.vector(m2), use = "complete.obs")
-        }, exchange.list = el[c(g1[i], g2[j]), ], seek = "max", 
-            draws = reps)
-    }
-    if ((gn1 == 1) & (gn2 == 1)) 
-        gd[1, 1]
-    else gd
-}
-
-gt (closure) = function (x, return.as.edgelist = FALSE) 
-{
-    if (return.as.edgelist) {
-        x <- as.edgelist.sna(x)
-        if (is.list(x)) 
-            return(lapply(x, gt, return.as.edgelist = TRUE))
-        n <- attr(x, "n")
-        vnames <- attr(x, "vnames")
-        bipartite <- attr(x, "bipartite")
-        x <- x[, c(2, 1, 3)]
-        attr(x, "n") <- n
-        attr(x, "vnames") <- vnames
-        attr(x, "bipartite") <- bipartite
-        x
-    }
-    else {
-        x <- as.sociomatrix.sna(x)
-        if (is.list(x)) 
-            return(lapply(x, gt, return.as.edgelist = FALSE))
-        if (length(dim(x)) == 3) {
-            aperm(x, c(1, 3, 2))
-        }
-        else t(x)
-    }
-}
-
-gtrans (closure) = function (dat, g = NULL, diag = FALSE, mode = "digraph", measure = c("weak", 
-    "strong", "weakcensus", "strongcensus", "rank", "correlation"), 
-    use.adjacency = TRUE) 
-{
-    if (use.adjacency && (!(match.arg(measure) %in% c("correlation", 
-        "rank")))) {
-        adjisok <- function(z) {
-            if (is.edgelist.sna(z)) {
-                if (attr(z, "n") > 40000) 
-                  FALSE
-                else if ((attr(z, "n") > 1000) && (NROW(z)/attr(z, 
-                  "n")^2 < 0.5)) 
-                  FALSE
-                else TRUE
-            }
-            else if (inherits(z, "matrix")) {
-                if (NCOL(z) > 1000) 
-                  FALSE
-                else TRUE
-            }
-            else if (inherits(z, "array")) {
-                if (dim(z)[2] > 1000) 
-                  FALSE
-                else TRUE
-            }
-            else if (inherits(z, "network")) {
-                if (network.size(z) > 40000) 
-                  FALSE
-                else if ((network.size(z) > 1000) && (network.edgecount(z)/network.size(z)^2 < 
-                  0.5)) 
-                  FALSE
-                else TRUE
-            }
-            else TRUE
-        }
-        if (is.list(dat) && (!inherits(dat, "network"))) 
-            adjcheck <- sapply(dat, adjisok)
-        else adjcheck <- adjisok(dat)
-        if (any(!adjcheck)) {
-            use.adjacency <- FALSE
-            warning("gtrans called with use.adjacency=TRUE, but your data looks too large for that to work well.  Overriding to edgelist method.")
-        }
-    }
-    if (use.adjacency && (match.arg(measure) == "rank")) {
-        use.adjacency <- FALSE
-    }
-    if ((!use.adjacency) && (match.arg(measure) == "correlation")) {
-        warning("Currently, non-adjacency computation for the correlation measure is not supported.  Defaulting to use.adjacency==TRUE in gtrans.\n")
-        use.adjacency <- TRUE
-    }
-    if (use.adjacency) {
-        dat <- as.sociomatrix.sna(dat)
-        if (is.list(dat)) {
-            if (is.null(g)) 
-                g <- 1:length(dat)
-            return(sapply(dat[g], gtrans, diag = diag, mode = mode, 
-                measure = measure, use.adjacency = use.adjacency))
-        }
-        n <- dim(dat)[2]
-        if (length(dim(dat)) > 2) {
-            if (!is.null(g)) {
-                gn <- length(g)
-                d <- dat[g, , ]
+    layout(matrix(c(1, 1, 2, 3, 4, 4), nrow = 3, ncol = 2, byrow = TRUE), 
+        heights = c(30, 40, 40))
+    par(mar = c(0, 0, 0, 0))
+    plot(1:10, 1:10, type = "n", axes = FALSE, xlab = "", ylab = "")
+    text(5, 6, "Exploratory PCA", adj = 0.5, font = 2, cex = 2, 
+        col = "dodgerblue4")
+    text(5, 4, "Use this plot to see if samples are clustered according to the experimental design.", 
+        adj = 0.5, font = 1, cex = 1)
+    text(5, 3, "Use ARSyNseq function to correct potential batch effects.", 
+        adj = 0.5, font = 1, cex = 1)
+    if (is.null(factor)) 
+        factor = colnames(QCinfo$data$PCA$factors)[1]
+    par(mar = c(5.1, 4.1, 4.1, 2.1))
+    PCA.plot(QCinfo$data$PCA, samples = 1:2, factor = factor)
+    par(mar = c(5.1, 4.1, 4.1, 2.1))
+    PCA.plot(QCinfo$data$PCA, samples = c(1, 3), factor = factor)
+    dev.off()
+}
+
+addData (closure) = function (data, length = NULL, biotype = NULL, chromosome = NULL, 
+    factors = NULL, gc = NULL) 
+{
+    if (inherits(data, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object.")
+    if (is.null(length) == FALSE && is.vector(length) == FALSE && 
+        is.data.frame(length) == FALSE && is.matrix(length) == 
+        FALSE) 
+        stop("The length info should be a vector or a data.frame/matrix.")
+    if (is.null(gc) == FALSE && is.vector(gc) == FALSE && is.data.frame(gc) == 
+        FALSE && is.matrix(gc) == FALSE) 
+        stop("The GC content info should be a vector or a data.frame/matrix.")
+    if (is.null(biotype) == FALSE && is.vector(biotype) == FALSE && 
+        is.data.frame(biotype) == FALSE && is.matrix(biotype) == 
+        FALSE) 
+        stop("The biotype info should be a vector or a data.frame/matrix.")
+    if (is.null(chromosome) == FALSE && ncol(chromosome) != 3) 
+        stop("The chromosome object should be a matrix or data.frame with 3 columns: chromosome, start position and end position.")
+    if (!is.null(assayData(data)$exprs)) 
+        rowNames <- rownames(assayData(data)$exprs)
+    else rowNames <- rownames(assayData(data)$counts)
+    if (!is.null(length)) {
+        Length <- rep(NA, length(rowNames))
+        names(Length) <- rowNames
+        if (is.vector(length)) {
+            Length[rowNames] <- as.numeric(as.character(length[rowNames]))
+        }
+        else if (is.data.frame(length) || is.matrix(length)) {
+            if (ncol(length) == 2) {
+                rownames(length) <- length[, 1]
+                Length[rowNames] <- as.numeric(as.character(length[rowNames, 
+                  2]))
+            }
+            else if (ncol(length) == 1) {
+                Length[rowNames] <- as.numeric(as.character(length[rowNames, 
+                  1]))
             }
             else {
-                d <- dat
-                gn <- dim(dat)[1]
+                stop("The length matrix/data.frame contains more columns than expected.")
             }
         }
-        else {
-            d <- dat
-            gn <- 1
-        }
-        if (gn == 1) {
-            temp <- array(dim = c(1, n, n))
-            temp[1, , ] <- d
-            d <- temp
-        }
-        if (!diag) 
-            d <- diag.remove(d, remove.val = 0)
-        t <- vector()
-        for (i in 1:gn) {
-            if (match.arg(measure) != "correlation") {
-                dt <- d[i, , ] != 0
+        featureData(data)@data <- cbind(featureData(data)@data, 
+            Length)
+    }
+    if (!is.null(gc)) {
+        GC <- rep(NA, length(rowNames))
+        names(GC) <- rowNames
+        if (is.vector(gc)) {
+            GC[rowNames] <- as.numeric(as.character(gc[rowNames]))
+        }
+        else if (is.data.frame(gc) || is.matrix(gc)) {
+            if (ncol(gc) == 2) {
+                rownames(gc) <- gc[, 1]
+                GC[rowNames] <- as.numeric(as.character(gc[rowNames, 
+                  2]))
+            }
+            else if (ncol(gc) == 1) {
+                GC[rowNames] <- as.numeric(as.character(gc[rowNames, 
+                  1]))
             }
             else {
-                dt <- d[i, , ]
+                stop("The GC matrix/data.frame contains more columns than expected.")
             }
-            dsqt <- (dt %*% dt)
-            if (!diag) {
-                diag(dt) <- NA
-                diag(dsqt) <- NA
-            }
-            t[i] <- switch(match.arg(measure), strong = sum(dt * 
-                dsqt + (!dt) * (NCOL(d[i, , ]) - 2 - dsqt), na.rm = TRUE)/(choose(NCOL(d[i, 
-                , ]), 3) * 6), strongcensus = sum(dt * dsqt + 
-                (!dt) * (NCOL(d[i, , ]) - 2 - dsqt), na.rm = TRUE), 
-                weak = sum(dt * dsqt, na.rm = TRUE)/sum(dsqt, 
-                  na.rm = TRUE), weakcensus = sum(dt * dsqt, 
-                  na.rm = TRUE), correlation = (function(x, y) {
-                  tv <- var(x, use = "pairwise.complete.obs") * 
-                    var(y, use = "pairwise.complete.obs")
-                  if (is.na(tv)) NA else if (tv == 0) all(x == 
-                    y, na.rm = TRUE) + 0 else cor(x, y, use = "pairwise.complete.obs")
-                })(x = as.vector(dt), y = as.vector(dsqt)))
-            if (is.nan(t[i])) 
-                t[i] <- 1
-        }
-        t
-    }
-    else {
-        dat <- as.edgelist.sna(dat)
-        if (is.list(dat)) {
-            if (is.null(g)) 
-                g <- 1:length(dat)
-            return(sapply(dat[g], gtrans, diag = diag, mode = mode, 
-                measure = measure, use.adjacency = use.adjacency))
-        }
-        if (attr(dat, "n") < 3) 
-            return(1)
-        meas <- switch(match.arg(measure), strong = 0, strongcensus = 0, 
-            weak = 1, weakcensus = 1, rank = 2, correlation = 3)
-        gt <- .C("transitivity_R", as.double(dat), as.integer(attr(dat, 
-            "n")), as.integer(NROW(dat)), gt = as.double(c(0, 
-            0)), as.integer(meas), as.integer(1), NAOK = TRUE, 
-            PACKAGE = "sna")$gt
-        if (match.arg(measure) %in% c("weak", "strong", "rank")) {
-            if (gt[2] == 0) 
-                1
-            else gt[1]/gt[2]
-        }
-        else gt[1]
-    }
-}
-
-gvectorize (closure) = function (mats, mode = "digraph", diag = FALSE, censor.as.na = TRUE) 
-{
-    mats <- as.sociomatrix.sna(mats)
-    if (is.list(mats)) 
-        return(lapply(mats, gvectorize, mode = mode, diag = diag, 
-            censor.as.na = censor.as.na))
-    if (length(dim(mats)) > 2) {
-        m <- dim(mats)[1]
-        n <- dim(mats)[2]
-        n <- dim(mats)[3]
-        d <- mats
-    }
-    else {
-        m <- 1
-        n <- dim(mats)[1]
-        o <- dim(mats)[2]
-        d <- array(dim = c(1, n, o))
-        d[1, , ] <- mats
-    }
-    if (censor.as.na) {
-        if (mode == "graph") 
-            d <- upper.tri.remove(d)
-        if (!diag) 
-            d <- diag.remove(d)
-        out <- apply(d, 1, as.vector)
-    }
-    else {
-        if (mode == "graph") 
-            mask <- apply(d, 1, lower.tri, diag = diag)
-        else {
-            if (diag) 
-                mask <- matrix(TRUE, nrow = dim(d)[2] * dim(d)[3], 
-                  ncol = dim(d)[1])
-            else mask <- apply(d, 1, function(z) {
-                diag(NROW(z)) == 0
-            })
-        }
-        out <- apply(d, 1, as.vector)
-        if (m == 1) 
-            out <- out[mask]
-        else out <- matrix(out[mask], ncol = m)
-    }
-    out
-}
-
-hdist (closure) = function (dat, dat2 = NULL, g1 = NULL, g2 = NULL, normalize = FALSE, 
-    diag = FALSE, mode = "digraph") 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in hdist.")
-    if (!is.null(dat2)) {
-        dat2 <- as.sociomatrix.sna(dat2)
-        if (is.list(dat2)) 
-            stop("Identical graph orders required in hdist.")
-    }
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (!is.null(dat2)) {
-        if (length(dim(dat)) > 2) 
-            temp1 <- dat
-        else {
-            temp1 <- array(dim = c(1, dim(dat)[2], dim(dat)[2]))
-            temp1[1, , ] <- dat
-        }
-        if (length(dim(dat2)) > 2) 
-            temp2 <- dat2
-        else {
-            temp2 <- array(dim = c(1, dim(dat2)[2], dim(dat2)[2]))
-            temp2[1, , ] <- dat2
         }
-        if (dim(temp1)[2] > dim(temp2)[2]) 
-            temp2 <- add.isolates(temp2, dim(temp1)[2] - dim(temp2)[2])
-        if (dim(temp2)[2] > dim(temp1)[2]) 
-            temp1 <- add.isolates(temp1, dim(temp2)[2] - dim(temp1)[2])
-        n <- dim(temp1)[2]
-        gn <- dim(temp1)[1] + dim(temp2)[1]
-        gn1 <- dim(temp1)[1]
-        gn2 <- dim(temp2)[1]
-        d <- array(dim = c(gn, n, n))
-        d[1:gn1, , ] <- temp1
-        d[(gn1 + 1):(gn2 + gn1), , ] <- temp2
-        g1 <- 1:gn1
-        g2 <- (gn1 + 1):(gn1 + gn2)
-    }
-    else {
-        d <- dat
-        n <- dim(dat)[2]
-        gn <- dim(dat)[1]
-        gn1 <- length(g1)
-        gn2 <- length(g2)
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    hd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(hd) <- g1
-    colnames(hd) <- g2
-    for (i in 1:gn1) for (j in 1:gn2) hd[i, j] <- sum(abs(d[g1[i], 
-        , ] - d[g2[j], , ]), na.rm = TRUE)
-    if (normalize) 
-        hd <- hd/nties(dat[1, , ], mode = mode, diag = diag)
-    if ((gn1 == 1) & (gn2 == 1)) 
-        hd[1, 1]
-    else hd
-}
-
-hideOutput (NULL) = NULL
-
-hierarchy (closure) = function (dat, g = NULL, measure = c("reciprocity", "krackhardt")) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(sapply(dat[g], hierarchy, measure = measure))
-    }
-    if (is.null(g)) 
-        g <- 1:stackcount(dat)
-    if (match.arg(measure) == "reciprocity") 
-        h <- 1 - grecip(dat, g)
-    else if (match.arg(measure) == "krackhardt") {
-        d <- array(dim = c(length(g), dim(dat)[2], dim(dat)[2]))
-        if (length(dim(dat)) > 2) 
-            d <- dat[g, , , drop = FALSE]
-        else d[1, , ] <- dat
-        h <- 1 - apply(d, 1, function(x) {
-            r <- reachability(x)
-            grecip(r, measure = "dyadic.nonnull")
-        })
-    }
-    h
-}
-
-infocent (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    cmode = "weak", tmaxdev = FALSE, rescale = FALSE, tol = 1e-20) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], infocent, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, cmode = cmode, tmaxdev = tmaxdev, 
-            rescale = rescale, tol = tol))
-    else if ((length(g) > 1) && (length(dim(dat)) > 2)) 
-        return(apply(dat[g, , ], 1, infocent, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, cmode = cmode, tmaxdev = tmaxdev, 
-            rescale = rescale, tol = tol))
-    if (tmaxdev) {
-        m <- matrix(0, nrow = dim(dat)[2], ncol = dim(dat)[2])
-        m[1, 2] <- 1
-        m[2, 1] <- 1
-        IC <- infocent(m, 1, rescale = rescale)
-        cent <- sum(max(IC) - IC, na.rm = TRUE)
-    }
-    else {
-        if (length(dim(dat)) > 2) 
-            m <- dat[g, , ]
-        else m <- dat
-        if (is.null(nodes)) 
-            nodes <- 1:dim(dat)[2]
-        if (sum(m != t(m), na.rm = TRUE) > 0) 
-            m <- symmetrize(m, rule = cmode)
-        n <- dim(m)[1]
-        if (!diag) 
-            diag(m) <- NA
-        iso <- is.isolate(m, 1:n, diag = diag)
-        ix <- which(!iso)
-        m <- m[ix, ix]
-        A <- 1 - m
-        A[m == 0] <- 1
-        diag(A) <- 1 + apply(m, 1, sum, na.rm = TRUE)
-        Cn <- solve(A, tol = tol)
-        Tr <- sum(diag(Cn))
-        R <- apply(Cn, 1, sum)
-        IC <- 1/(diag(Cn) + (Tr - 2 * R)/n)
-        cent <- rep(0, n)
-        cent[ix] <- IC
-        if (rescale) 
-            cent <- cent/sum(cent)
-        cent <- cent[nodes]
-    }
-    cent
-}
-
-interval.graph (closure) = function (slist, type = "simple", diag = FALSE) 
-{
-    o <- list()
-    m <- stackcount(slist)
-    if (m == 1) {
-        d <- array(dim = c(m, dim(slist)[1], dim(slist)[2]))
-        d[1, , ] <- slist
-    }
-    else d <- slist
-    ns <- dim(d)[2]
-    o$exchange.list <- d[, , 1]
-    o$graph <- array(dim = c(m, ns, ns))
-    for (i in 1:ns) for (j in 1:ns) o$graph[, i, j] <- switch(type, 
-        simple = as.numeric((d[, i, 2] <= d[, j, 3]) & (d[, i, 
-            3] >= d[, j, 2])), overlap = pmax(pmin(d[, i, 3], 
-            d[, j, 3]) - pmax(d[, i, 2], d[, j, 2]), 0), fracxy = pmax(pmin(d[, 
-            i, 3], d[, j, 3]) - pmax(d[, i, 2], d[, j, 2]), 0)/(d[, 
-            i, 3] - d[, i, 2]), fracyx = pmax(pmin(d[, i, 3], 
-            d[, j, 3]) - pmax(d[, i, 2], d[, j, 2]), 0)/(d[, 
-            j, 3] - d[, j, 2]), jntfrac = 2 * pmax(pmin(d[, i, 
-            3], d[, j, 3]) - pmax(d[, i, 2], d[, j, 2]), 0)/(d[, 
-            i, 3] - d[, i, 2] + d[, j, 3] - d[, j, 2]))
-    if (m == 1) 
-        o$graph <- o$graph[1, , ]
-    if (!diag) 
-        o$graph <- diag.remove(o$graph, remove.val = 0)
-    o
-}
-
-is.connected (closure) = function (g, connected = "strong", comp.dist.precomp = NULL) 
-{
-    g <- as.edgelist.sna(g)
-    if (is.list(g)) 
-        return(lapply(g, is.connected, connected = connected, 
-            comp.dist.precomp = comp.dist.precomp))
-    components(g, connected = connected, comp.dist.precomp = comp.dist.precomp) == 
-        1
-}
-
-is.edgelist.sna (closure) = function (x) 
-{
-    if (is.list(x) && (!inherits(x, "network"))) 
-        return(sapply(x, is.edgelist.sna))
-    if (!inherits(x, c("matrix", "array"))) 
-        FALSE
-    else if (length(dim(x)) != 2) 
-        FALSE
-    else if (dim(x)[2] != 3) 
-        FALSE
-    else if (is.null(attr(x, "n"))) 
-        FALSE
-    else TRUE
-}
-
-is.isolate (closure) = function (dat, ego, g = 1, diag = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat[g], is.isolate, ego = ego, g = 1, diag = diag))
-    if (!diag) 
-        dat <- dat[dat[, 1] != dat[, 2], , drop = FALSE]
-    dat <- dat[!is.na(dat[, 3]), , drop = FALSE]
-    noniso <- unique(c(dat[, 1], dat[, 2]))
-    !(ego %in% noniso)
-}
-
-isolates (closure) = function (dat, diag = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, isolates, diag))
-    n <- attr(dat, "n")
-    if (!diag) {
-        dat <- dat[dat[, 1] != dat[, 2], , drop = FALSE]
-    }
-    which(tabulate(as.vector(dat[, 1:2]), n) == 0)
-}
-
-kcores (closure) = function (dat, mode = "digraph", diag = FALSE, cmode = "freeman", 
-    ignore.eval = FALSE) 
-{
-    dat <- as.edgelist.sna(dat, as.digraph = TRUE, suppress.diag = TRUE)
-    if (is.list(dat)) 
-        return(lapply(dat, kcores, dat = dat, mode = mode, diag = diag, 
-            cmode = cmode, ignore.eval = ignore.eval))
-    if (mode == "graph") 
-        cmode <- "indegree"
-    n <- attr(dat, "n")
-    m <- NROW(dat)
-    corevec <- 1:n
-    dtype <- switch(cmode, indegree = 0, outdegree = 1, freeman = 2)
-    if (!(cmode %in% c("indegree", "outdegree", "freeman"))) 
-        stop("Illegal cmode in kcores.\n")
-    solve <- .C("kcores_R", as.double(dat), as.integer(n), as.integer(m), 
-        cv = as.double(corevec), as.integer(dtype), as.integer(diag), 
-        as.integer(ignore.eval), NAOK = TRUE, PACKAGE = "sna")
-    if (is.null(attr(dat, "vnames"))) 
-        names(solve$cv) <- 1:n
-    else names(solve$cv) <- attr(dat, "vnames")
-    solve$cv
-}
-
-kcycle.census (closure) = function (dat, maxlen = 3, mode = "digraph", tabulate.by.vertex = TRUE, 
-    cycle.comembership = c("none", "sum", "bylength")) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, kcycle.census, maxlen = maxlen, mode = mode, 
-            tabulate.by.vertex = tabulate.by.vertex, cycle.comembership = cycle.comembership))
-    n <- attr(dat, "n")
-    if (is.null(maxlen)) 
-        maxlen <- n
-    if (maxlen < 2) 
-        stop("maxlen must be >=2")
-    if (is.null(attr(dat, "vnames"))) 
-        vnam <- paste("v", 1:n, sep = "")
-    else vnam <- attr(dat, "vnames")
-    if (mode == "digraph") 
-        directed <- TRUE
-    else directed <- FALSE
-    cocycles <- switch(match.arg(cycle.comembership), none = 0, 
-        sum = 1, bylength = 2)
-    if (!tabulate.by.vertex) 
-        count <- rep(0, maxlen - 1)
-    else count <- matrix(0, maxlen - 1, n + 1)
-    if (!cocycles) 
-        cccount <- NULL
-    else if (cocycles == 1) 
-        cccount <- matrix(0, n, n)
-    else cccount <- array(0, dim = c(maxlen - 1, n, n))
-    if (is.null(maxlen)) 
-        maxlen <- n
-    ccen <- .C("cycleCensus_R", as.integer(dat), as.integer(n), 
-        as.integer(NROW(dat)), count = as.double(count), cccount = as.double(cccount), 
-        as.integer(maxlen), as.integer(directed), as.integer(tabulate.by.vertex), 
-        as.integer(cocycles), PACKAGE = "sna")
-    if (!tabulate.by.vertex) {
-        count <- ccen$count
-        names(count) <- 2:maxlen
-    }
-    else {
-        count <- matrix(ccen$count, maxlen - 1, n + 1)
-        rownames(count) <- 2:maxlen
-        colnames(count) <- c("Agg", vnam)
-    }
-    if (cocycles == 1) {
-        cccount <- matrix(ccen$cccount, n, n)
-        rownames(cccount) <- vnam
-        colnames(cccount) <- vnam
-    }
-    else if (cocycles == 2) {
-        cccount <- array(ccen$cccount, dim = c(maxlen - 1, n, 
-            n))
-        dimnames(cccount) <- list(2:maxlen, vnam, vnam)
-    }
-    out <- list(cycle.count = count)
-    if (cocycles > 0) 
-        out$cycle.comemb <- cccount
-    out
-}
-
-kpath.census (closure) = function (dat, maxlen = 3, mode = "digraph", tabulate.by.vertex = TRUE, 
-    path.comembership = c("none", "sum", "bylength"), dyadic.tabulation = c("none", 
-        "sum", "bylength")) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, kpath.census, maxlen = maxlen, mode = mode, 
-            tabulate.by.vertex = tabulate.by.vertex, path.comembership = path.comembership, 
-            dyadic.tabulation = dyadic.tabulation))
-    n <- attr(dat, "n")
-    if (is.null(maxlen)) 
-        maxlen <- n - 1
-    if (maxlen < 1) 
-        stop("maxlen must be >=1")
-    if (is.null(attr(dat, "vnames"))) 
-        vnam <- paste("v", 1:n, sep = "")
-    else vnam <- attr(dat, "vnames")
-    if (mode == "digraph") 
-        directed <- TRUE
-    else directed <- FALSE
-    copaths <- switch(match.arg(path.comembership), none = 0, 
-        sum = 1, bylength = 2)
-    dyadpaths <- switch(match.arg(dyadic.tabulation), none = 0, 
-        sum = 1, bylength = 2)
-    if (!tabulate.by.vertex) 
-        count <- rep(0, maxlen)
-    else count <- matrix(0, maxlen, n + 1)
-    if (!copaths) 
-        cpcount <- NULL
-    else if (copaths == 1) 
-        cpcount <- matrix(0, n, n)
-    else cpcount <- array(0, dim = c(maxlen, n, n))
-    if (!dyadpaths) 
-        dpcount <- NULL
-    else if (dyadpaths == 1) 
-        dpcount <- matrix(0, n, n)
-    else dpcount <- array(0, dim = c(maxlen, n, n))
-    pcen <- .C("pathCensus_R", as.double(dat), as.integer(n), 
-        as.integer(NROW(dat)), count = as.double(count), cpcount = as.double(cpcount), 
-        dpcount = as.double(dpcount), as.integer(maxlen), as.integer(directed), 
-        as.integer(tabulate.by.vertex), as.integer(copaths), 
-        as.integer(dyadpaths), PACKAGE = "sna")
-    if (!tabulate.by.vertex) {
-        count <- pcen$count
-        names(count) <- 1:maxlen
-    }
-    else {
-        count <- matrix(pcen$count, maxlen, n + 1)
-        rownames(count) <- 1:maxlen
-        colnames(count) <- c("Agg", vnam)
-    }
-    if (copaths == 1) {
-        cpcount <- matrix(pcen$cpcount, n, n)
-        rownames(cpcount) <- vnam
-        colnames(cpcount) <- vnam
-    }
-    else if (copaths == 2) {
-        cpcount <- array(pcen$cpcount, dim = c(maxlen, n, n))
-        dimnames(cpcount) <- list(1:maxlen, vnam, vnam)
-    }
-    if (dyadpaths == 1) {
-        dpcount <- matrix(pcen$dpcount, n, n)
-        rownames(dpcount) <- vnam
-        colnames(dpcount) <- vnam
-    }
-    else if (dyadpaths == 2) {
-        dpcount <- array(pcen$dpcount, dim = c(maxlen, n, n))
-        dimnames(dpcount) <- list(1:maxlen, vnam, vnam)
-    }
-    out <- list(path.count = count)
-    if (copaths > 0) 
-        out$path.comemb <- cpcount
-    if (dyadpaths > 0) 
-        out$paths.bydyad <- dpcount
-    out
-}
-
-lab.optimize (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", opt.method = c("anneal", 
-    "exhaustive", "mc", "hillclimb", "gumbel"), ...) 
-{
-    meth <- match.arg(opt.method)
-    if (meth == "anneal") 
-        lab.optimize.anneal(d1, d2, FUN, exchange.list, seek, 
-            ...)
-    else if (meth == "exhaustive") 
-        lab.optimize.exhaustive(d1, d2, FUN, exchange.list, seek, 
-            ...)
-    else if (meth == "mc") 
-        lab.optimize.mc(d1, d2, FUN, exchange.list, seek, ...)
-    else if (meth == "hillclimb") 
-        lab.optimize.hillclimb(d1, d2, FUN, exchange.list, seek, 
-            ...)
-    else if (meth == "gumbel") {
-        warning("Warning, gumbel method not yet supported. Try at your own risk.\n")
-        lab.optimize.gumbel(d1, d2, FUN, exchange.list, seek, 
-            ...)
+        featureData(data)@data <- cbind(featureData(data)@data, 
+            GC)
     }
-}
-
-lab.optimize.anneal (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", prob.init = 1, 
-    prob.decay = 0.99, freeze.time = 1000, full.neighborhood = TRUE, 
-    ...) 
-{
-    d1 <- as.sociomatrix.sna(d1)
-    d2 <- as.sociomatrix.sna(d2)
-    if (is.list(d1) || is.list(d2) || (dim(d1)[2] != dim(d2)[2])) 
-        stop("lab.optimize routines require input graphs to be of identical order.")
-    n <- dim(d1)[2]
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, 2 * n), nrow = 2, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, 2)
+    if (!is.null(biotype)) {
+        Biotype <- rep(NA, length(rowNames))
+        names(Biotype) <- rowNames
+        if (is.vector(biotype)) {
+            Biotype[rowNames] <- as.character(biotype[rowNames])
+        }
+        else if (is.data.frame(biotype) || is.matrix(biotype)) {
+            if (ncol(biotype) == 2) {
+                rownames(biotype) <- biotype[, 1]
+                Biotype[rowNames] <- as.character(biotype[rowNames, 
+                  2])
+            }
+            else if (ncol(biotype) == 1) {
+                Biotype[rowNames] <- as.character(biotype[rowNames, 
+                  1])
+            }
+            else {
+                stop("The biotype matrix/data.frame contains more columns than expected.")
+            }
         }
-    }
-    else el <- exchange.list
-    fun <- match.fun(FUN)
-    d1 <- d1[order(el[1, ]), order(el[1, ])]
-    d2 <- d2[order(el[2, ]), order(el[2, ])]
-    el[1, ] <- el[1, order(el[1, ])]
-    el[2, ] <- el[2, order(el[2, ])]
-    if (any(el[1, ] != el[2, ])) 
-        stop("Illegal exchange list; lists must be comparable!\n")
-    best <- fun(d1, d2, ...)
-    o <- 1:n
-    global.best <- best
-    global.o <- o
-    prob <- prob.init
-    ftime <- freeze.time
-    nc <- choose(n, 2)
-    candp <- sapply(o, rep, choose(n, 2))
-    ccount <- 1
-    for (i in 1:n) for (j in i:n) if (i != j) {
-        temp <- candp[ccount, i]
-        candp[ccount, i] <- candp[ccount, j]
-        candp[ccount, j] <- temp
-        ccount <- ccount + 1
-    }
-    flag <- FALSE
-    if (any(duplicated(el[2, ]))) 
-        while ((!flag) | (ftime > 0)) {
-            flag <- TRUE
-            if (full.neighborhood) {
-                candperf <- vector()
-                for (i in 1:nc) if (all(el[2, ] == el[2, o[candp[i, 
-                  ]]])) 
-                  candperf[i] <- fun(d1, d2[o[candp[i, ]], o[candp[i, 
-                    ]]], ...)
-                else candperf[i] <- NA
-                if (seek == "min") {
-                  bestcand <- (1:nc)[candperf == min(candperf, 
-                    na.rm = TRUE)]
-                  bestcand <- bestcand[!is.na(bestcand)]
-                  if (length(bestcand) > 1) 
-                    bestcand <- sample(bestcand, 1)
-                  if (candperf[bestcand] < best) {
-                    o <- o[candp[bestcand, ]]
-                    best <- candperf[bestcand]
-                    flag <- FALSE
-                    if (best < global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
-                  }
-                  else if ((ftime > 0) & (runif(1, 0, 1) < prob)) {
-                    bestcand <- sample(1:nc, 1)
-                    while (!all(el[2, ] == el[2, o[candp[bestcand, 
-                      ]]])) bestcand <- sample(1:nc, 1)
-                    o <- o[candp[bestcand, ]]
-                    best <- candperf[bestcand]
-                  }
+        featureData(data)@data <- cbind(featureData(data)@data, 
+            Biotype)
+        featureData(data)@data$Biotype <- as.character(featureData(data)@data$Biotype)
+    }
+    if (!is.null(chromosome)) {
+        Chromosome <- GeneStart <- GeneEnd <- rep(NA, length(rowNames))
+        names(Chromosome) <- names(GeneStart) <- names(GeneEnd) <- rowNames
+        Chromosome[rowNames] <- as.character(chromosome[rowNames, 
+            1])
+        GeneStart[rowNames] <- as.numeric(as.character(chromosome[rowNames, 
+            2]))
+        GeneEnd[rowNames] <- as.numeric(as.character(chromosome[rowNames, 
+            3]))
+        featureData(data)@data <- cbind(featureData(data)@data, 
+            Chromosome, GeneStart, GeneEnd)
+    }
+    if (!is.null(factors)) 
+        phenoData(data)@data <- cbind(phenoData(data)@data, factors)
+    data
+}
+
+allMD (closure) = function (input, factor, conditions, k = 0.5, replicates, norm = "rpkm", 
+    pnr = 0.2, nss = 5, v = 0.02, lc = 0) 
+{
+    condition_fac = FALSE
+    condition_lev = FALSE
+    datos1 <- datos2 <- matrix()
+    for (i in colnames(pData(input))) {
+        if (factor == i) {
+            condition_fac = TRUE
+            if (!is.factor(pData(input)[, i])) 
+                pData(input)[, i] = as.factor(pData(input)[, 
+                  i])
+            if (length(levels(pData(input)[, i])) == 2) {
+                if (!is.null(assayData(input)$exprs)) {
+                  datos1 <- assayData(input)$exprs[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[1]), drop = FALSE]
+                  datos2 <- assayData(input)$exprs[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[2]), drop = FALSE]
                 }
                 else {
-                  bestcand <- (1:nc)[candperf == max(candperf, 
-                    na.rm = TRUE)]
-                  bestcand <- bestcand[!is.na(bestcand)]
-                  if (length(bestcand) > 1) 
-                    bestcand <- sample(bestcand, 1)
-                  if ((candperf[bestcand] > best) | (runif(1, 
-                    0, 1) < prob)) {
-                    o <- o[candp[bestcand, ]]
-                    best <- candperf[bestcand]
-                    flag <- FALSE
-                    if (best > global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
-                  }
-                  else if ((ftime > 0) & (runif(1, 0, 1) < prob)) {
-                    bestcand <- sample(1:nc, 1)
-                    while (!all(el[2, ] == el[2, o[candp[bestcand, 
-                      ]]])) bestcand <- sample(1:nc, 1)
-                    o <- o[candp[bestcand, ]]
-                    best <- candperf[bestcand]
-                  }
+                  datos1 <- assayData(input)$counts[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[1]), drop = FALSE]
+                  datos2 <- assayData(input)$counts[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[2]), drop = FALSE]
                 }
+                comparison <- paste(levels(pData(input)[, i])[1], 
+                  levels(pData(input)[, i])[2], sep = " - ")
+                condition_lev = TRUE
             }
             else {
-                i <- sample(1:nc, 1)
-                while (!all(el[2, ] == el[2, o[candp[i, ]]])) i <- sample(1:nc, 
-                  1)
-                candperf <- fun(d1, d2[o[candp[i, ]], o[candp[i, 
-                  ]]], ...)
-                if (seek == "min") {
-                  if (candperf < best) {
-                    o <- o[candp[i, ]]
-                    best <- candperf
-                    flag <- FALSE
-                    if (best < global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
+                if (is.null(conditions)) 
+                  stop("Error. You must specify which conditions you wish to compare when the factor has two or more conditions.\n")
+                if (length(conditions) != 2) 
+                  stop("Error. The argument conditions must contain the 2 conditions you wish to compare.")
+                l <- conditions %in% pData(input)[, i]
+                if (l[1] == TRUE && l[2] == TRUE) {
+                  if (!is.null(assayData(input)$exprs)) {
+                    datos1 <- assayData(input)$exprs[, which(pData(input)[, 
+                      i] == conditions[1]), drop = FALSE]
+                    datos2 <- assayData(input)$exprs[, which(pData(input)[, 
+                      i] == conditions[2]), drop = FALSE]
                   }
-                  else if ((ftime > 0) & (runif(1, 0, 1) < prob)) {
-                    i <- sample(1:nc, 1)
-                    while (!all(el[2, ] == el[2, o[candp[i, ]]])) i <- sample(1:nc, 
-                      1)
-                    o <- o[candp[i, ]]
-                    best <- candperf
-                    if (best < global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
+                  else {
+                    datos1 <- assayData(input)$counts[, which(pData(input)[, 
+                      i] == conditions[1]), drop = FALSE]
+                    datos2 <- assayData(input)$counts[, which(pData(input)[, 
+                      i] == conditions[2]), drop = FALSE]
                   }
+                  comparison <- paste(conditions[1], conditions[2], 
+                    sep = " - ")
+                  condition_lev = TRUE
+                }
+            }
+        }
+    }
+    if (condition_fac == FALSE) 
+        stop("The factor you have written does not correspond with any of the ones you have defined.")
+    if (condition_lev == FALSE) 
+        stop("The conditions you have written don't exist in the factor specified.\n")
+    if (replicates == "no") 
+        replicates = "technical"
+    n1 <- ncol(as.matrix(datos1))
+    n2 <- ncol(as.matrix(datos2))
+    if (norm == "n") {
+        datos1 <- round(datos1, 100)
+        datos2 <- round(datos2, 100)
+    }
+    if (is.null(k)) {
+        m1 <- min(datos1[noceros(datos1, num = FALSE)], na.rm = TRUE)
+        m2 <- min(datos2[noceros(datos2, num = FALSE)], na.rm = TRUE)
+        mm <- min(m1, m2)
+        k <- mm/2
+    }
+    suma1 <- rowSums(as.matrix(datos1))
+    suma2 <- rowSums(as.matrix(datos2))
+    todos <- rownames(as.matrix(datos1))
+    concounts <- names(which(suma1 + suma2 > 0))
+    long <- 1000
+    g.sinL <- NULL
+    if (!is.null(featureData(input)@data$Length)) {
+        g.sinL <- names(which(is.na(featureData(input)@data$Length)))
+        if (any(!is.na(featureData(input)@data$Length)) == TRUE) 
+            long <- featureData(input)@data[concounts, "Length"]
+    }
+    if (replicates == "technical") {
+        suma1 <- suma1[concounts]
+        suma2 <- suma2[concounts]
+        if (norm == "rpkm") {
+            suma1.norm <- rpkm(suma1, long = long, k = k, lc = lc)
+            suma2.norm <- rpkm(suma2, long = long, k = k, lc = lc)
+        }
+        if (norm == "uqua") {
+            suma.norm <- uqua(cbind(suma1, suma2), long = long, 
+                lc = lc, k = k)
+            suma1.norm <- as.matrix(suma.norm[, 1])
+            suma2.norm <- as.matrix(suma.norm[, 2])
+        }
+        if (norm == "tmm") {
+            suma.norm <- tmm(as.matrix(cbind(suma1, suma2)), 
+                long = long, lc = lc, k = k)
+            suma1.norm <- as.matrix(suma.norm[, 1])
+            suma2.norm <- as.matrix(suma.norm[, 2])
+        }
+    }
+    if ((n1 + n2) > 2) {
+        datitos <- cbind(datos1, datos2)
+        datitos <- datitos[concounts, ]
+        gens.sin0 <- setdiff(concounts, g.sinL)
+        if (norm == "n") {
+            datitos.0 <- sinceros(datitos, k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "rpkm") {
+            datitos.0 <- rpkm(datitos, long = long, k = k, lc = lc)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "uqua") {
+            datitos.0 <- uqua(datitos, long = long, lc = lc, 
+                k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "tmm") {
+            datitos.0 <- tmm(datitos, long = long, lc = lc, k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        datos1.norm <- datitos.norm[, 1:n1]
+        datos2.norm <- datitos.norm[, (n1 + 1):(n1 + n2)]
+        if (n1 > 1) {
+            MD1 <- MD(dat = datos1.norm)
+        }
+        else {
+            MD1 <- NULL
+        }
+        if (n2 > 1) {
+            MD2 <- MD(dat = datos2.norm)
+        }
+        else {
+            MD2 <- NULL
+        }
+    }
+    else {
+        if (nss == 0) {
+            nss <- 5
+        }
+        datos.sim <- sim.samples(counts1 = sinceros(suma1, k = k), 
+            counts2 = sinceros(suma2, k = k), pnr = pnr, nss = nss, 
+            v = v)
+        nn <- sapply(datos.sim, ncol)
+        dat.sim.norm <- vector("list", length = 2)
+        datitos <- cbind(datos.sim[[1]], datos.sim[[2]])
+        rownames(datitos) = names(suma1)
+        sumita <- rowSums(datitos)
+        g.sin0 <- names(which(sumita > 0))
+        gens.sin0 <- setdiff(g.sin0, g.sinL)
+        if (norm == "n") {
+            datitos.0 <- sinceros(datitos, k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "rpkm") {
+            datitos.0 <- rpkm(datitos, long = long, k = k, lc = lc)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "uqua") {
+            datitos.0 <- uqua(datitos, long = long, lc = lc, 
+                k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        if (norm == "tmm") {
+            datitos.0 <- tmm(datitos, long = long, lc = lc, k = k)
+            datitos.norm <- datitos.0[gens.sin0, ]
+        }
+        dat.sim.norm[[1]] <- datitos.norm[, 1:nn[1]]
+        dat.sim.norm[[2]] <- datitos.norm[, (nn[1] + 1):sum(nn)]
+        MD1 <- MD(dat = dat.sim.norm[[1]])
+        MD2 <- MD(dat = dat.sim.norm[[2]])
+    }
+    Mr <- c(as.numeric(MD1$M), as.numeric(MD2$M))
+    Dr <- c(as.numeric(MD1$D), as.numeric(MD2$D))
+    if (replicates == "technical" & norm != "n") {
+        MDs <- MD(dat = cbind(suma1.norm, suma2.norm))
+        lev1 <- suma1.norm[, 1]
+        lev1 <- lev1[todos]
+        lev2 <- suma2.norm[, 1]
+        lev2 <- lev2[todos]
+    }
+    else {
+        if ((n1 + n1) == 2) {
+            datos1.norm <- sinceros(as.matrix(datos1)[concounts, 
+                ], k = k)
+            datos2.norm <- sinceros(as.matrix(datos2)[concounts, 
+                ], k = k)
+        }
+        resum1.norm <- rowMeans(as.matrix(datos1.norm))
+        resum2.norm <- rowMeans(as.matrix(datos2.norm))
+        lev1 <- resum1.norm[todos]
+        lev2 <- resum2.norm[todos]
+        MDs <- MD(dat = cbind(resum1.norm, resum2.norm))
+    }
+    names(lev1) <- names(lev2) <- todos
+    Ms <- as.numeric(MDs$M)
+    names(Ms) <- rownames(MDs$M)
+    Ms <- Ms[todos]
+    names(Ms) <- todos
+    Ds <- as.numeric(MDs$D)
+    names(Ds) <- rownames(MDs$D)
+    Ds <- Ds[todos]
+    names(Ds) <- todos
+    list(k = k, comp = comparison, Level1 = lev1, Level2 = lev2, 
+        Ms = Ms, Ds = Ds, Mn = Mr, Dn = Dr)
+}
+
+allMDbio (closure) = function (input, factor, conditions, k = 0.5, norm = "rpkm", 
+    lc = 1, r = 10, a0per = 0.9, nclust = 15, filter = 1, depth = NULL, 
+    cv.cutoff = 0, cpm = 1) 
+{
+    condition_fac = FALSE
+    condition_lev = FALSE
+    datos1 <- datos2 <- matrix()
+    for (i in colnames(pData(input))) {
+        if (factor == i) {
+            condition_fac = TRUE
+            if (!is.factor(pData(input)[, i])) 
+                pData(input)[, i] = as.factor(pData(input)[, 
+                  i])
+            if (length(levels(pData(input)[, i])) == 2) {
+                if (!is.null(assayData(input)$exprs)) {
+                  datos1 <- assayData(input)$exprs[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[1])]
+                  datos2 <- assayData(input)$exprs[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[2])]
                 }
                 else {
-                  if (candperf > best) {
-                    o <- o[candp[i, ]]
-                    best <- candperf
-                    flag <- FALSE
-                    if (best > global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
+                  datos1 <- assayData(input)$counts[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[1])]
+                  datos2 <- assayData(input)$counts[, which(pData(input)[, 
+                    i] == levels(pData(input)[, i])[2])]
+                }
+                comparison <- paste(levels(pData(input)[, i])[1], 
+                  levels(pData(input)[, i])[2], sep = " - ")
+                condition_lev = TRUE
+                if (!((ncol(datos1) > 1) && (ncol(datos2) > 1))) 
+                  stop("Error. NOISeqBIO needs at least 2 biological replicates per condition.\n")
+            }
+            else {
+                if (is.null(conditions)) 
+                  stop("Error. You must specify which conditions you wish to compare when the factor has two or more conditions.\n")
+                if (length(conditions) != 2) 
+                  stop("Error. The argument conditions must contain the 2 conditions you wish to compare.")
+                l <- conditions %in% pData(input)[, i]
+                if (l[1] == TRUE && l[2] == TRUE) {
+                  if (!is.null(assayData(input)$exprs)) {
+                    datos1 <- assayData(input)$exprs[, which(pData(input)[, 
+                      i] == conditions[1])]
+                    datos2 <- assayData(input)$exprs[, which(pData(input)[, 
+                      i] == conditions[2])]
                   }
-                  else if ((ftime > 0) & (runif(1, 0, 1) < prob)) {
-                    i <- sample(1:nc, 1)
-                    while (!all(el[2, ] == el[2, o[candp[i, ]]])) i <- sample(1:nc, 
-                      1)
-                    o <- o[candp[i, ]]
-                    best <- candperf
-                    if (best > global.best) {
-                      global.best <- best
-                      global.o <- o
-                    }
+                  else {
+                    datos1 <- assayData(input)$counts[, which(pData(input)[, 
+                      i] == conditions[1])]
+                    datos2 <- assayData(input)$counts[, which(pData(input)[, 
+                      i] == conditions[2])]
                   }
+                  comparison <- paste(conditions[1], conditions[2], 
+                    sep = " - ")
+                  condition_lev = TRUE
                 }
             }
-            ftime <- ftime - 1
-            prob <- prob * prob.decay
-        }
-    global.best
-}
-
-lab.optimize.exhaustive (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", ...) 
-{
-    d1 <- as.sociomatrix.sna(d1)
-    d2 <- as.sociomatrix.sna(d2)
-    if (is.list(d1) || is.list(d2) || (dim(d1)[2] != dim(d2)[2])) 
-        stop("lab.optimize routines require input graphs to be of identical order.")
-    n <- dim(d1)[2]
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, 2 * n), nrow = 2, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, 2)
-        }
-    }
-    else el <- exchange.list
-    fun <- match.fun(FUN)
-    d1 <- d1[order(el[1, ]), order(el[1, ])]
-    d2 <- d2[order(el[2, ]), order(el[2, ])]
-    el[1, ] <- el[1, order(el[1, ])]
-    el[2, ] <- el[2, order(el[2, ])]
-    if (any(el[1, ] != el[2, ])) 
-        stop("Illegal exchange list; lists must be comparable!\n")
-    best <- fun(d1, d2, ...)
-    if (any(duplicated(el[1, ]))) 
-        for (k in 0:(gamma(n + 1) - 1)) {
-            o <- numperm(n, k)
-            if (all(el[1, ] == el[2, o])) {
-                if (seek == "min") 
-                  best <- min(best, fun(d1, d2[o, o], ...))
-                else best <- max(best, fun(d1, d2[o, o], ...))
-            }
-        }
-    best
-}
-
-lab.optimize.gumbel (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", draws = 500, 
-    tol = 1e-05, estimator = "median", ...) 
-{
-    d1 <- as.sociomatrix.sna(d1)
-    d2 <- as.sociomatrix.sna(d2)
-    if (is.list(d1) || is.list(d2) || (dim(d1)[2] != dim(d2)[2])) 
-        stop("lab.optimize routines require input graphs to be of identical order.")
-    n <- dim(d1)[2]
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, 2 * n), nrow = 2, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, 2)
-        }
-    }
-    else el <- exchange.list
-    fun <- match.fun(FUN)
-    fg <- vector()
-    d1 <- d1[order(el[1, ]), order(el[1, ])]
-    d2 <- d2[order(el[2, ]), order(el[2, ])]
-    el[1, ] <- el[1, order(el[1, ])]
-    el[2, ] <- el[2, order(el[2, ])]
-    if (any(el[1, ] != el[2, ])) 
-        stop("Illegal exchange list; lists must be comparable!\n")
-    for (i in 1:draws) {
-        o <- rperm(el[2, ])
-        fg[i] <- fun(d1, d2[o, o], ...)
-    }
-    b <- 1
-    b.old <- 1
-    bdiff <- Inf
-    mfg <- mean(fg)
-    print(quantile(fg))
-    while (bdiff > tol) {
-        cat("bold=", b.old, "b=", b, "bdiff=", bdiff, "\n")
-        b.old <- b
-        b <- mfg - sum(fg * exp(-fg/b))/sum(exp(-fg/b))
-        bdiff <- abs(b.old - b)
-    }
-    a <- -b * log(sum(exp(-fg/b))/draws)
-    cat("a=", a, "b=", b, "\n")
-    switch(estimator, mean = a - b * digamma(1), mode = a, median = a - 
-        b * log(log(2)))
-}
-
-lab.optimize.hillclimb (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", ...) 
-{
-    d1 <- as.sociomatrix.sna(d1)
-    d2 <- as.sociomatrix.sna(d2)
-    if (is.list(d1) || is.list(d2) || (dim(d1)[2] != dim(d2)[2])) 
-        stop("lab.optimize routines require input graphs to be of identical order.")
-    n <- dim(d1)[2]
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, 2 * n), nrow = 2, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, 2)
         }
     }
-    else el <- exchange.list
-    fun <- match.fun(FUN)
-    d1 <- d1[order(el[1, ]), order(el[1, ])]
-    d2 <- d2[order(el[2, ]), order(el[2, ])]
-    el[1, ] <- el[1, order(el[1, ])]
-    el[2, ] <- el[2, order(el[2, ])]
-    if (any(el[1, ] != el[2, ])) 
-        stop("Illegal exchange list; lists must be comparable!\n")
-    best <- fun(d1, d2, ...)
-    o <- 1:n
-    nc <- choose(n, 2)
-    candp <- sapply(o, rep, choose(n, 2))
-    ccount <- 1
-    for (i in 1:n) for (j in i:n) if (i != j) {
-        temp <- candp[ccount, i]
-        candp[ccount, i] <- candp[ccount, j]
-        candp[ccount, j] <- temp
-        ccount <- ccount + 1
-    }
-    flag <- FALSE
-    while (!flag) {
-        flag <- TRUE
-        candperf <- vector()
-        for (i in 1:nc) if (all(el[2, ] == el[2, o[candp[i, ]]])) 
-            candperf[i] <- fun(d1, d2[o[candp[i, ]], o[candp[i, 
-                ]]], ...)
-        else candperf[i] <- NA
-        if (seek == "min") {
-            bestcand <- (1:nc)[candperf == min(candperf, na.rm = TRUE)]
-            if (length(bestcand) > 1) 
-                bestcand <- sample(bestcand, 1)
-            if (candperf[bestcand] < best) {
-                o <- o[candp[bestcand, ]]
-                best <- candperf[bestcand]
-                flag <- FALSE
-            }
-        }
-        else {
-            bestcand <- (1:nc)[candperf == max(candperf, na.rm = TRUE)]
-            if (length(bestcand) > 1) 
-                bestcand <- sample(bestcand, 1)
-            if (candperf[bestcand] > best) {
-                o <- o[candp[bestcand, ]]
-                best <- candperf[bestcand]
-                flag <- FALSE
+    if (condition_fac == FALSE) 
+        stop("The factor specified does not correspond with any of the ones you have defined.")
+    if (condition_lev == FALSE) 
+        stop("The conditions specified don't exist for the factor specified.\n")
+    n1 <- ncol(as.matrix(datos1))
+    n2 <- ncol(as.matrix(datos2))
+    if (max(n1, n2) == 1) 
+        stop("There is only one replicate per condition. Please, use NOISeq instead of NOISeqBIO.\n")
+    if (norm == "n") {
+        datos1 <- round(datos1, 10)
+        datos2 <- round(datos2, 10)
+    }
+    if (is.null(k)) {
+        m1 <- min(datos1[noceros(datos1, num = FALSE)], na.rm = TRUE)
+        m2 <- min(datos2[noceros(datos2, num = FALSE)], na.rm = TRUE)
+        k <- min(m1, m2)/2
+    }
+    suma1 <- rowSums(as.matrix(datos1))
+    suma2 <- rowSums(as.matrix(datos2))
+    concounts <- names(which(suma1 + suma2 > 0))
+    todos <- rownames(as.matrix(datos1))
+    long <- 1000
+    g.sinL <- NULL
+    if (!is.null(featureData(input)@data$Length)) {
+        g.sinL <- names(which(is.na(featureData(input)@data$Length)))
+        if (any(!is.na(featureData(input)@data$Length)) == TRUE) 
+            long <- featureData(input)@data[concounts, "Length"]
+    }
+    gens.sin0 <- setdiff(concounts, g.sinL)
+    datitos <- cbind(datos1, datos2)
+    datitos <- datitos[concounts, ]
+    if (filter == 3 && is.null(depth)) 
+        depth = colSums(datitos)
+    if (norm == "n") {
+        datitos.0 <- sinceros(datitos, k = k)
+        datitos.norm <- datitos.0[gens.sin0, ]
+    }
+    if (norm == "rpkm") {
+        datitos.0 <- rpkm(datitos, long = long, k = k, lc = lc)
+        datitos.norm <- datitos.0[gens.sin0, ]
+    }
+    if (norm == "uqua") {
+        datitos.0 <- uqua(datitos, long = long, lc = lc, k = k)
+        datitos.norm <- datitos.0[gens.sin0, ]
+    }
+    if (norm == "tmm") {
+        datitos.0 <- tmm(datitos, long = long, lc = lc, k = k)
+        datitos.norm <- datitos.0[gens.sin0, ]
+    }
+    if (filter != 0) {
+        datos.filt = filtered.data(dataset = datitos.norm, factor = c(rep("cond1", 
+            n1), rep("cond2", n2)), norm = TRUE, depth = depth, 
+            method = filter, cv.cutoff = cv.cutoff, cpm = cpm)
+    }
+    else {
+        datos.filt = datitos.norm
+    }
+    datos1.filt <- datos.filt[, 1:n1]
+    datos2.filt <- datos.filt[, (n1 + 1):(n1 + n2)]
+    Zr = NULL
+    if (n1 + n2 <= 9) {
+        Zr = share.info(mydata = datos.filt, n1 = n1, n2 = n2, 
+            r = r, nclust = nclust)
+    }
+    else {
+        for (i in 1:r) {
+            print(paste("r =", i))
+            mipermu = sample(1:(n1 + n2))
+            mipermu = datos.filt[, mipermu]
+            mean1 = rowMeans(mipermu[, 1:n1])
+            mean2 = rowMeans(mipermu[, (n1 + 1):(n1 + n2)])
+            sd1 = apply(mipermu[, 1:n1], 1, sd)
+            sd2 = apply(mipermu[, (n1 + 1):(n1 + n2)], 1, sd)
+            myparam = list(n = c(n1, n2), sd = cbind(sd1, sd2))
+            MDperm <- MDbio(dat = cbind(mean1, mean2), param = myparam, 
+                a0per = a0per)
+            Zr = cbind(Zr, myDfunction(mydif = MDperm$D, myrat = MDperm$M, 
+                stat = 1, coef = 0.5))
+        }
+    }
+    mean1 = rowMeans(as.matrix(datos1.filt))
+    mean2 = rowMeans(as.matrix(datos2.filt))
+    sd1 = apply(as.matrix(datos1.filt), 1, sd)
+    sd2 = apply(as.matrix(datos2.filt), 1, sd)
+    myparam = list(n = c(n1, n2), sd = cbind(sd1, sd2))
+    MDs <- MDbio(dat = cbind(mean1, mean2), param = myparam, 
+        a0per = a0per)
+    Zs = myDfunction(mydif = MDs$D, myrat = MDs$M, stat = 1, 
+        coef = 0.5)
+    lev1 <- mean1[todos]
+    lev2 <- mean2[todos]
+    names(lev1) <- names(lev2) <- todos
+    Zs <- as.numeric(Zs)
+    names(Zs) <- rownames(MDs$M)
+    Zs <- Zs[todos]
+    names(Zs) <- todos
+    Zn = as.numeric(Zr)
+    list(k = k, comp = comparison, Level1 = lev1, Level2 = lev2, 
+        Zs = Zs, Zn = Zn)
+}
+
+biodetection.dat (closure) = function (input, factor = NULL, k = 0) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. The input data must be an eSet object\n")
+    if (any(!is.na(featureData(input)@data$Biotype)) == FALSE) 
+        stop("No biological classification was provided.\nPlease run addData() function to add \n          this information\n")
+    if (!is.null(assayData(input)$exprs)) {
+        dat <- as.matrix(assayData(input)$exprs)
+        mysamples = colnames(assayData(input)$exprs)
+    }
+    else {
+        dat <- as.matrix(assayData(input)$counts)
+        mysamples = colnames(assayData(input)$counts)
+    }
+    numgenes = nrow(dat)
+    if (is.null(factor)) {
+        cat("Biotypes detection is to be computed for:\n")
+        print(colnames(dat))
+        biotablas = vector("list", length = NCOL(dat))
+        names(biotablas) = colnames(dat)
+    }
+    else {
+        mifactor = as.factor(pData(input)[, factor])
+        niveles = levels(mifactor)
+        cat("Biotypes detection is to be computed for:\n")
+        print(niveles)
+        biotablas = vector("list", length = length(niveles))
+        names(biotablas) = niveles
+        dat = sapply(niveles, function(k) rowSums(as.matrix(dat[, 
+            mifactor == k])))
+    }
+    infobio <- as.character(featureData(input)@data$Biotype)
+    genome <- 100 * table(infobio)/sum(table(infobio))
+    ordre <- order(genome, decreasing = TRUE)
+    for (i in 1:length(biotablas)) {
+        detect <- dat[, i] > k
+        perdet1 <- genome * table(infobio, detect)[names(genome), 
+            "TRUE"]/table(infobio)[names(genome)]
+        perdet2 <- 100 * table(infobio, detect)[names(genome), 
+            "TRUE"]/sum(table(infobio, detect)[, "TRUE"])
+        biotablas[[i]] <- as.matrix(rbind(perdet1[ordre], perdet2[ordre]))
+        rownames(biotablas[[i]]) <- c("detectionVSgenome", "detectionVSsample")
+    }
+    mybiotable = list(genome = genome[ordre], biotables = biotablas, 
+        genomesize = numgenes)
+    mybiotable
+}
+
+biodetection.plot (closure) = function (dat, samples = c(1, 2), plottype = c("persample", "comparison"), 
+    toplot = "protein_coding", toreport = FALSE, ...) 
+{
+    mypar = par(no.readonly = TRUE)
+    plottype = match.arg(plottype)
+    if (length(samples) > 2) {
+        stop("ERROR: This function cannot generate plots for more than 2 samples.\n \n         Please, use it as many times as needed to generate the plots for all your samples.\n")
+    }
+    if (is.numeric(samples)) 
+        samples = names(dat$biotables)[samples]
+    biotable1 <- rbind(dat$genome, dat$biotables[[samples[1]]], 
+        rep(0, length(dat$genome)))
+    if (ncol(biotable1) >= 3) {
+        ymaxL <- ceiling(max(biotable1[, 1:3], na.rm = TRUE))
+        ymaxR <- max(biotable1[, -c(1:3)], na.rm = TRUE)
+    }
+    else {
+        ymaxL <- ceiling(max(biotable1, na.rm = TRUE))
+        ymaxR = 0
+    }
+    if (length(samples) == 2) {
+        biotable2 <- rbind(dat$genome, dat$biotables[[samples[2]]], 
+            rep(0, length(dat$genome)))
+        if (ncol(biotable2) >= 3) {
+            ymax2 <- ceiling(max(biotable2[, 1:3], na.rm = TRUE))
+            ymax2sin <- max(biotable2[, -c(1:3)], na.rm = TRUE)
+            ymaxR <- ceiling(max(ymaxR, ymax2sin))
+        }
+        else {
+            ymax2 <- ceiling(max(biotable2, na.rm = TRUE))
+        }
+        ymaxL = max(ymaxL, ymax2)
+    }
+    if (length(samples) == 2) {
+        if (ncol(biotable2) >= 3) 
+            biotable2[, -c(1:3)] <- biotable2[, -c(1:3)] * ymaxL/ymaxR
+    }
+    if (ncol(biotable1) >= 3) 
+        biotable1[, -c(1:3)] <- biotable1[, -c(1:3)] * ymaxL/ymaxR
+    if (length(samples) == 1) {
+        par(mar = c(11, 4, 2, 2))
+        barplot(biotable1[c(1, 3), ], main = samples[1], xlab = NULL, 
+            ylab = "%features", axis.lty = 1, legend = FALSE, 
+            beside = TRUE, col = c("grey", 2), las = 2, ylim = c(0, 
+                ymaxL), border = c("grey", 2))
+        barplot(biotable1[c(2, 4), ], main = samples[1], xlab = NULL, 
+            ylab = "%features", axis.lty = 1, legend = FALSE, 
+            beside = TRUE, col = c(2, 1), las = 2, density = 30, 
+            ylim = c(0, ymaxL), border = 2, add = TRUE)
+        if (ymaxR > 0) {
+            axis(side = 4, at = pretty(c(0, ymaxL), n = 5), labels = round(pretty(c(0, 
+                ymaxL), n = 5) * ymaxR/ymaxL, 1))
+            abline(v = 9.5, col = 3, lwd = 2, lty = 2)
+        }
+        legend(x = "topright", bty = "n", horiz = FALSE, fill = c("grey", 
+            2, 2), density = c(NA, 30, NA), border = c("grey", 
+            2, 2), legend = c("% in genome", "detected", "% in sample"))
+    }
+    else {
+        par(mar = c(11, 4, 2, 2))
+        if (plottype == "persample") {
+            barplot(biotable1[c(1, 3), ], main = samples[1], 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c("grey", 
+                  2), las = 2, ylim = c(0, ymaxL), border = c("grey", 
+                  2))
+            barplot(biotable1[c(2, 4), ], main = samples[1], 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c(2, 1), 
+                las = 2, density = 30, ylim = c(0, ymaxL), border = 2, 
+                add = TRUE)
+            if (ymaxR > 0) {
+                axis(side = 4, at = pretty(c(0, ymaxL), n = 5), 
+                  labels = round(pretty(c(0, ymaxL), n = 5) * 
+                    ymaxR/ymaxL, 1))
+                abline(v = 9.5, col = 3, lwd = 2, lty = 2)
+            }
+            legend(x = "topright", bty = "n", horiz = FALSE, 
+                fill = c("grey", 2, 2), density = c(NA, 30, NA), 
+                border = c("grey", 2, 2), legend = c("% in genome", 
+                  "detected", "% in sample"))
+            barplot(biotable2[c(1, 3), ], main = samples[2], 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c("grey", 
+                  4), las = 2, ylim = c(0, ymaxL), border = c("grey", 
+                  4))
+            barplot(biotable2[c(2, 4), ], main = samples[2], 
+                xlab = NULL, ylab = "%features", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c(4, 1), 
+                las = 2, density = 30, ylim = c(0, ymaxL), border = 4, 
+                add = TRUE)
+            if (ymaxR > 0) {
+                axis(side = 4, at = pretty(c(0, ymaxL), n = 5), 
+                  labels = round(pretty(c(0, ymaxL), n = 5) * 
+                    ymaxR/ymaxL, 1))
+                abline(v = 9.5, col = 3, lwd = 2, lty = 2)
+            }
+            legend(x = "topright", bty = "n", horiz = FALSE, 
+                fill = c("grey", 4, 4), density = c(NA, 30, NA), 
+                border = c("grey", 4, 4), legend = c("% in genome", 
+                  "detected", "% in sample"))
+        }
+        if (plottype == "comparison") {
+            lefttable = rbind(100 * dat$biotables[[samples[1]]][1, 
+                ]/dat$genome, 100 * dat$biotables[[samples[2]]][1, 
+                ]/dat$genome)
+            righttable = rbind(dat$biotables[[samples[1]]][2, 
+                ], dat$biotables[[samples[2]]][2, ])
+            if (length(toplot) > 1) {
+                toplot = toplot[1]
+                print("WARNING: More than one biotype was provided, the proportion test will only by applied to the first biotype.")
+            }
+            if ((toplot != 1) && (toplot != "global")) {
+                numgenes = dat$genomesize
+                myx = round(righttable[, toplot] * numgenes/100, 
+                  0)
+                mytest = prop.test(x = myx, n = rep(numgenes, 
+                  2), alternative = "two.sided")
+                if (is.numeric(toplot)) 
+                  toplot = colnames(righttable)[toplot]
+            }
+            asumar = colSums(righttable)
+            asumar = which(asumar < 0.25)
+            if (length(asumar) > 1) {
+                righttable = cbind(righttable[, -asumar], rowSums(righttable[, 
+                  asumar]))
+                colnames(righttable)[ncol(righttable)] = "Others"
+            }
+            bbb = barplot(lefttable, main = "Biotype detection over genome total", 
+                xlab = NULL, ylab = "% detected features", axis.lty = 1, 
+                legend = FALSE, cex.names = 0.8, beside = TRUE, 
+                col = c(2, 4), las = 2, density = 80, border = c(2, 
+                  4), ylim = c(0, 100))
+            bbb = colSums(bbb)/2
+            lines(bbb, dat$genome, pch = 20, type = "o", lwd = 2)
+            barplot(righttable, main = "Relative biotype abundance in sample", 
+                xlab = NULL, ylab = "Relative % biotypes", axis.lty = 1, 
+                legend = FALSE, beside = TRUE, col = c(2, 4), 
+                las = 2, border = c(2, 4))
+            legend(x = "topright", bty = "n", horiz = FALSE, 
+                pch = c(15, 15, 20), lwd = c(NA, NA, 1), legend = c(samples, 
+                  "% in genome"), col = c(2, 4, 1))
+            if ((toplot != 1) && (toplot != "global")) {
+                print(paste("Percentage of", toplot, "biotype in each sample:"))
+                names(mytest$estimate) = samples
+                print(round(mytest$estimate * 100, 4))
+                print(paste("Confidence interval at 95% for the difference of percentages:", 
+                  samples[1], "-", samples[2]))
+                print(round(mytest$conf.int[1:2] * 100, 4))
+                if (mytest$p.value < 0.05) {
+                  print(paste("The percentage of this biotype is significantly DIFFERENT for these two samples (p-value =", 
+                    signif(mytest$p.value, 4), ")."))
+                }
+                else {
+                  print(paste("The percentage of this biotype is NOT significantly different for these two samples (p-value =", 
+                    signif(mytest$p.value, 4), ")."))
+                }
             }
         }
     }
-    best
+    if (!toreport) 
+        par(mypar)
 }
 
-lab.optimize.mc (closure) = function (d1, d2, FUN, exchange.list = 0, seek = "min", draws = 1000, 
-    ...) 
+busca (closure) = function (x, S) 
 {
-    d1 <- as.sociomatrix.sna(d1)
-    d2 <- as.sociomatrix.sna(d2)
-    if (is.list(d1) || is.list(d2) || (dim(d1)[2] != dim(d2)[2])) 
-        stop("lab.optimize routines require input graphs to be of identical order.")
-    n <- dim(d1)[2]
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, 2 * n), nrow = 2, 
-                ncol = n)
-        }
-        else {
-            el <- sapply(exchange.list, rep, 2)
-        }
+    which(S[, 1] == x[1] & S[, 2] == x[2])
+}
+
+cd.dat (closure) = function (input, norm = FALSE, refColumn = 1) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("ERROR: The input data must be an eSet object.\n")
+    if (!is.null(assayData(input)$exprs)) {
+        if (ncol(assayData(input)$exprs) < 2) 
+            stop("ERROR: The input object should have at least two samples.\n")
+        datos <- assayData(input)$exprs
     }
-    else el <- exchange.list
-    fun <- match.fun(FUN)
-    d1 <- d1[order(el[1, ]), order(el[1, ])]
-    d2 <- d2[order(el[2, ]), order(el[2, ])]
-    el[1, ] <- el[1, order(el[1, ])]
-    el[2, ] <- el[2, order(el[2, ])]
-    if (any(el[1, ] != el[2, ])) 
-        stop("Illegal exchange list; lists must be comparable!\n")
-    best <- fun(d1, d2, ...)
-    if (any(duplicated(el[1, ]))) 
-        for (i in 1:draws) {
-            o <- rperm(el[2, ])
-            if (seek == "min") 
-                best <- min(best, fun(d1, d2[o, o], ...))
-            else best <- max(best, fun(d1, d2[o, o], ...))
-        }
-    best
-}
-
-lnam (closure) = function (y, x = NULL, W1 = NULL, W2 = NULL, theta.seed = NULL, 
-    null.model = c("meanstd", "mean", "std", "none"), method = "BFGS", 
-    control = list(), tol = 1e-10) 
-{
-    agg <- function(a, w) {
-        m <- length(w)
-        n <- dim(a)[2]
-        mat <- as.double(matrix(0, n, n))
-        matrix(.C("aggarray3d_R", as.double(a), as.double(w), 
-            mat = mat, as.integer(m), as.integer(n), PACKAGE = "sna", 
-            NAOK = TRUE)$mat, n, n)
-    }
-    betahat <- function(y, X, W1a, W2a) {
-        if (nw1 == 0) {
-            if (nw2 == 0) {
-                return(qr.solve(t(X) %*% X, t(X) %*% y))
-            }
-            else {
-                tXtW2aW2a <- t(X) %*% t(W2a) %*% W2a
-                return(qr.solve(tXtW2aW2a %*% X, tXtW2aW2a %*% 
-                  y))
-            }
-        }
-        else {
-            if (nw2 == 0) {
-                return(qr.solve(t(X) %*% X, t(X) %*% W1a %*% 
-                  y))
-            }
-            else {
-                tXtW2aW2a <- t(X) %*% t(W2a) %*% W2a
-                qr.solve(tXtW2aW2a %*% X, tXtW2aW2a %*% W1a %*% 
-                  y)
-            }
-        }
+    else {
+        if (ncol(assayData(input)$counts) < 2) 
+            stop("ERROR: The input object should have at least two samples.\n")
+        datos <- assayData(input)$counts
     }
-    muhat <- function(y, X, W1a, W2a, betahat) {
-        if (nx > 0) 
-            Xb <- X %*% betahat
-        else Xb <- 0
-        switch((nw1 > 0) + 2 * (nw2 > 0) + 1, y - Xb, W1a %*% 
-            y - Xb, W2a %*% (y - Xb), W2a %*% (W1a %*% y - Xb))
-    }
-    sigmasqhat <- function(muhat) {
-        t(muhat) %*% muhat/length(muhat)
-    }
-    n2ll.rho <- function(rho, beta, sigmasq) {
-        if (nw1 > 0) {
-            W1a <- diag(n) - agg(W1, rho[1:nw1])
-            W1ay <- W1a %*% y
-            adetW1a <- abs(det(W1a))
-        }
-        else {
-            W1ay <- y
-            adetW1a <- 1
-        }
-        if (nw2 > 0) {
-            W2a <- diag(n) - agg(W2, rho[(nw1 + 1):(nw1 + nw2)])
-            tpW2a <- t(W2a) %*% W2a
-            adetW2a <- abs(det(W2a))
-        }
-        else {
-            tpW2a <- diag(n)
-            adetW2a <- 1
-        }
-        if (nx > 0) {
-            Xb <- x %*% beta
-        }
-        else {
-            Xb <- 0
-        }
-        n * (log(2 * pi) + log(sigmasq)) + t(W1ay - Xb) %*% tpW2a %*% 
-            (W1ay - Xb)/sigmasq - 2 * (log(adetW1a) + log(adetW2a))
+    ceros = which(rowSums(datos) == 0)
+    hayceros = (length(ceros) > 0)
+    if (hayceros) {
+        print(paste("Warning:", length(ceros), "features with 0 counts in all samples are to be removed for this analysis."))
+        datos = datos[-ceros, ]
     }
-    n2ll <- function(W1a, W2a, sigmasqhat) {
-        switch((nw1 > 0) + 2 * (nw2 > 0) + 1, n * (1 + log(2 * 
-            pi) + log(sigmasqhat)), n * (1 + log(2 * pi) + log(sigmasqhat)) - 
-            2 * log(abs(det(W1a))), n * (1 + log(2 * pi) + log(sigmasqhat)) - 
-            2 * log(abs(det(W2a))), n * (1 + log(2 * pi) + log(sigmasqhat)) - 
-            2 * (log(abs(det(W1a))) + log(abs(det(W2a)))))
-    }
-    estimate <- function(parm, final = FALSE) {
-        if (nw1 > 0) 
-            W1a <- diag(n) - agg(W1, parm$rho1)
-        else W1a <- NULL
-        if (nw2 > 0) 
-            W2a <- diag(n) - agg(W2, parm$rho2)
-        else W2a <- NULL
-        if (nx > 0) 
-            parm$beta <- betahat(y, x, W1a, W2a)
-        parm$sigmasq <- sigmasqhat(muhat(y, x, W1a, W2a, parm$beta))
-        if (!(final || (nw1 + nw2 == 0))) {
-            rho <- c(parm$rho1, parm$rho2)
-            temp <- optim(rho, n2ll.rho, method = method, control = control, 
-                beta = parm$beta, sigmasq = parm$sigmasq)
-            if (nw1 > 0) 
-                parm$rho1 <- temp$par[1:nw1]
-            if (nw2 > 0) 
-                parm$rho2 <- temp$par[(nw1 + 1):(nw1 + nw2)]
-        }
-        parm$dev <- n2ll(W1a, W2a, parm$sigmasq)
-        parm
-    }
-    infomat <- function(parm) {
-        requireNamespace("numDeriv")
-        locnll <- function(par) {
-            if (nw1 > 0) {
-                W1a <- diag(n) - agg(W1, par[(nx + 1):(nx + nw1)])
-                W1ay <- W1a %*% y
-                ladetW1a <- log(abs(det(W1a)))
-            }
-            else {
-                W1ay <- y
-                ladetW1a <- 0
-            }
-            if (nw2 > 0) {
-                W2a <- diag(n) - agg(W2, par[(nx + nw1 + 1):(nx + 
-                  nw1 + nw2)])
-                tpW2a <- t(W2a) %*% W2a
-                ladetW2a <- log(abs(det(W2a)))
-            }
-            else {
-                tpW2a <- diag(n)
-                ladetW2a <- 0
-            }
-            if (nx > 0) {
-                Xb <- x %*% par[1:nx]
-            }
-            else {
-                Xb <- 0
-            }
-            n/2 * (log(2 * pi) + log(par[m])) + t(W1ay - Xb) %*% 
-                tpW2a %*% (W1ay - Xb)/(2 * par[m]) - ladetW1a - 
-                ladetW2a
-        }
-        numDeriv::hessian(locnll, c(parm$beta, parm$rho1, parm$rho2, 
-            parm$sigmasq))
-    }
-    n <- length(y)
-    if (!is.null(x)) {
-        if (is.vector(x)) 
-            x <- as.matrix(x)
-        if (NROW(x) != n) 
-            stop("Number of observations in x must match length of y.")
-        nx <- NCOL(x)
-    }
-    else nx <- 0
-    if (!is.null(W1)) {
-        W1 <- as.sociomatrix.sna(W1)
-        if (!(is.matrix(W1) || is.array(W1))) 
-            stop("All networks supplied in W1 must be of identical order.")
-        if (dim(W1)[2] != n) 
-            stop("Order of W1 must match length of y.")
-        if (length(dim(W1)) == 2) 
-            W1 <- array(W1, dim = c(1, n, n))
-        nw1 <- dim(W1)[1]
-    }
-    else nw1 <- 0
-    if (!is.null(W2)) {
-        W2 <- as.sociomatrix.sna(W2)
-        if (!(is.matrix(W2) || is.array(W2))) 
-            stop("All networks supplied in W2 must be of identical order.")
-        if (dim(W2)[2] != n) 
-            stop("Order of W2 must match length of y.")
-        if (length(dim(W2)) == 2) 
-            W2 <- array(W2, dim = c(1, n, n))
-        nw2 <- dim(W2)[1]
-    }
-    else nw2 <- 0
-    comp.mode <- as.character(as.numeric(1 * (nx > 0) + 10 * 
-        (nw1 > 0) + 100 * (nw2 > 0)))
-    if (comp.mode == "0") 
-        stop("At least one of x, W1, W2 must be specified.\n")
-    m <- switch(comp.mode, `1` = nx + 1, `10` = nw1 + 1, `100` = nw2 + 
-        1, `11` = nx + nw1 + 1, `101` = nx + nw2 + 1, `110` = nw1 + 
-        nw2 + 1, `111` = nx + nw1 + nw2 + 1)
-    parm <- list()
-    if (is.null(theta.seed)) {
-        if (nx > 0) 
-            parm$beta <- rep(0, nx)
-        if (nw1 > 0) 
-            parm$rho1 <- rep(0, nw1)
-        if (nw2 > 0) 
-            parm$rho2 <- rep(0, nw2)
-        parm$sigmasq <- 1
-    }
-    else {
-        if (nx > 0) 
-            parm$beta <- theta.seed[1:nx]
-        if (nw1 > 0) 
-            parm$rho1 <- theta.seed[(nx + 1):(nx + nw1)]
-        if (nw2 > 0) 
-            parm$rho2 <- theta.seed[(nx + nw1 + 1):(nx + nw1 + 
-                nw2)]
-        parm$sigmasq <- theta.seed[nx + nw1 + nw2 + 1]
-    }
-    parm$dev <- Inf
-    olddev <- Inf
-    while (is.na(parm$dev - olddev) || (abs(parm$dev - olddev) > 
-        tol)) {
-        olddev <- parm$dev
-        parm <- estimate(parm, final = FALSE)
-    }
-    parm <- estimate(parm, final = TRUE)
-    o <- list()
-    o$y <- y
-    o$x <- x
-    o$W1 <- W1
-    o$W2 <- W2
-    o$model <- comp.mode
-    o$infomat <- infomat(parm)
-    o$acvm <- qr.solve(o$infomat)
-    o$null.model <- match.arg(null.model)
-    o$lnlik.null <- switch(match.arg(null.model), meanstd = sum(dnorm(y - 
-        mean(y), 0, as.numeric(sqrt(var(y))), log = TRUE)), mean = sum(dnorm(y - 
-        mean(y), log = TRUE)), std = sum(dnorm(y, 0, as.numeric(sqrt(var(y))), 
-        log = TRUE)), none = sum(dnorm(y, log = TRUE)))
-    o$df.null.resid <- switch(match.arg(null.model), meanstd = n - 
-        2, mean = n - 1, std = n - 1, none = n)
-    o$df.null <- switch(match.arg(null.model), meanstd = 2, mean = 1, 
-        std = 1, none = 0)
-    o$null.param <- switch(match.arg(null.model), meanstd = c(mean(y), 
-        sqrt(var(y))), mean = mean(y), std = sqrt(var(y)), none = NULL)
-    o$lnlik.model <- -parm$dev/2
-    o$df.model <- m
-    o$df.residual <- n - m
-    o$df.total <- n
-    o$beta <- parm$beta
-    o$rho1 <- parm$rho1
-    o$rho2 <- parm$rho2
-    o$sigmasq <- parm$sigmasq
-    o$sigma <- o$sigmasq^0.5
-    temp <- sqrt(diag(o$acvm))
-    if (nx > 0) 
-        o$beta.se <- temp[1:nx]
-    if (nw1 > 0) 
-        o$rho1.se <- temp[(nx + 1):(nx + nw1)]
-    if (nw2 > 0) 
-        o$rho2.se <- temp[(nx + nw1 + 1):(nx + nw1 + nw2)]
-    o$sigmasq.se <- temp[m]
-    o$sigma.se <- o$sigmasq.se^2/(4 * o$sigmasq)
-    if (!is.null(o$beta)) {
-        if (!is.null(colnames(x))) {
-            names(o$beta) <- colnames(x)
-            names(o$beta.se) <- colnames(x)
+    if (norm) {
+        datos = sinceros(datos, k = NULL)
+    }
+    else {
+        datos = rpkm(datos, long = 1000, lc = 1, k = 0.5)
+    }
+    data2plot = log2(datos/datos[, refColumn])
+    if (is.numeric(refColumn)) 
+        refColumn = colnames(datos)[refColumn]
+    print(paste("Reference sample is:", refColumn))
+    MsinRef = as.matrix(data2plot[, -match(refColumn, colnames(data2plot))])
+    colnames(MsinRef) = colnames(data2plot)[-match(refColumn, 
+        colnames(data2plot))]
+    alpha = 0.05
+    alpha = alpha/ncol(MsinRef)
+    nperm = 10^3
+    bootmed = sapply(1:nperm, function(k) {
+        permut = sample(1:nrow(MsinRef), replace = TRUE, nrow(MsinRef))
+        permut = as.matrix(MsinRef[permut, ])
+        permut = apply(permut, 2, median)
+        permut
+    })
+    if (is.null(dim(bootmed))) 
+        bootmed = t(as.matrix(bootmed))
+    bootmed = t(apply(bootmed, 1, quantile, probs = round(c(alpha/2, 
+        1 - alpha/2), 4)))
+    diagno = apply(bootmed, 1, function(x) {
+        ddd = (x[1] <= 0) * (0 <= x[2])
+        if (ddd == 1) {
+            ddd = "PASSED"
         }
         else {
-            names(o$beta) <- paste("X", 1:nx, sep = "")
-            names(o$beta.se) <- paste("X", 1:nx, sep = "")
+            ddd = "FAILED"
         }
-    }
-    if (!is.null(o$rho1)) {
-        if ((!is.null(dimnames(W1))) && (!is.null(dimnames(W1)[[1]]))) {
-            names(o$rho1) <- dimnames(W1)[[1]]
-            names(o$rho1.se) <- dimnames(W1)[[1]]
+        ddd
+    })
+    bootmed = cbind(bootmed, diagno)
+    rownames(bootmed) = colnames(MsinRef)
+    colnames(bootmed)[3] = "Diagnostic Test"
+    print("Confidence intervals for median of M:")
+    print(bootmed)
+    if ("FAILED" %in% bootmed[, 3]) {
+        print("Diagnostic test: FAILED. Normalization is required to correct this bias.")
+    }
+    else {
+        print("Diagnostic test: PASSED.")
+    }
+    list(data2plot = data2plot, refColumn = refColumn, DiagnosticTest = bootmed)
+}
+
+cd.plot (closure) = function (dat, samples = NULL, ...) 
+{
+    refColumn = dat$refColumn
+    dat = dat$data2plot
+    if (is.null(samples)) 
+        samples <- 1:ncol(dat)
+    if (is.numeric(samples)) {
+        samples = colnames(dat)[samples]
+    }
+    samples = setdiff(samples, refColumn)
+    if (length(samples) > 12) 
+        stop("Please select 12 samples or less to be plotted (excluding reference).")
+    dat = as.matrix(dat[, samples])
+    dat.dens = apply(dat, 2, density, adjust = 1.5)
+    limY = c(0, max(sapply(dat.dens, function(x) max(x$y, na.rm = TRUE))))
+    plot(dat.dens[[1]], xlab = "M = log2(sample/refsample)", 
+        ylab = "Density", lwd = 2, ylim = limY, type = "l", col = miscolores[1], 
+        main = paste("Reference sample:", refColumn), ...)
+    abline(v = median(dat[, 1], na.rm = TRUE), col = miscolores[1], 
+        lty = 2)
+    if (length(samples) > 1) {
+        for (i in 2:length(samples)) {
+            lines(dat.dens[[i]], col = miscolores[i], lwd = 2)
+            abline(v = median(dat[, i], na.rm = TRUE), col = miscolores[i], 
+                lty = i + 1)
+        }
+    }
+    legend("topleft", legend = samples, text.col = miscolores[1:length(samples)], 
+        bty = "n", lty = 1, lwd = 2, col = miscolores[1:length(samples)])
+}
+
+countsbio.dat (closure) = function (input, biotypes = NULL, factor = NULL, norm = FALSE) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object\n")
+    if (!is.null(assayData(input)$exprs)) 
+        datos <- assayData(input)$exprs
+    else datos <- assayData(input)$counts
+    depth = round(colSums(datos)/10^6, 1)
+    names(depth) = colnames(datos)
+    ceros = which(rowSums(datos) == 0)
+    hayceros = (length(ceros) > 0)
+    if (hayceros) {
+        print(paste("Warning:", length(ceros), "features with 0 counts in all samples are to be removed for this analysis."))
+        datos0 = datos[-ceros, ]
+    }
+    else {
+        datos0 = datos
+    }
+    nsam <- NCOL(datos)
+    if (nsam == 1) {
+        datos <- as.matrix(datos)
+        datos0 <- as.matrix(datos0)
+    }
+    if (is.null(factor)) {
+        print("Count distributions are to be computed for:")
+        print(colnames(datos))
+    }
+    else {
+        mifactor = as.factor(pData(input)[, factor])
+        niveles = levels(mifactor)
+        print("Counts per million distributions are to be computed for:")
+        print(niveles)
+        if (norm) {
+            datos = sapply(niveles, function(k) {
+                rowMeans(as.matrix(datos[, mifactor == k]))
+            })
+            datos0 = sapply(niveles, function(k) {
+                rowMeans(as.matrix(datos0[, mifactor == k]))
+            })
         }
         else {
-            names(o$rho1) <- paste("rho1", 1:nw1, sep = ".")
-            names(o$rho1.se) <- paste("rho1", 1:nw1, sep = ".")
+            datos = sapply(niveles, function(k) {
+                10^6 * rowMeans(t(t(datos[, mifactor == k])/colSums(as.matrix(datos[, 
+                  mifactor == k]))))
+            })
+            datos0 = sapply(niveles, function(k) {
+                10^6 * rowMeans(t(t(datos0[, mifactor == k])/colSums(as.matrix(datos0[, 
+                  mifactor == k]))))
+            })
         }
+        colnames(datos) = colnames(datos0) = niveles
+        depth = sapply(niveles, function(k) paste(range(depth[mifactor == 
+            k]), collapse = "-"))
     }
-    if (!is.null(o$rho2)) {
-        if ((!is.null(dimnames(W2))) && (!is.null(dimnames(W2)[[1]]))) {
-            names(o$rho2) <- dimnames(W2)[[1]]
-            names(o$rho2.se) <- dimnames(W2)[[1]]
+    if (!is.null(featureData(input)$Biotype)) {
+        if (hayceros) {
+            infobio0 <- as.character(featureData(input)$Biotype)[-ceros]
         }
         else {
-            names(o$rho2) <- paste("rho2", 1:nw2, sep = ".")
-            names(o$rho2.se) <- paste("rho2", 1:nw2, sep = ".")
+            infobio0 = as.character(featureData(input)$Biotype)
         }
+        infobio <- as.character(featureData(input)$Biotype)
     }
-    if (nw1 > 0) 
-        W1ag <- agg(W1, o$rho1)
-    if (nw2 > 0) 
-        W2ag <- agg(W2, o$rho2)
-    o$disturbances <- as.vector(switch(comp.mode, `1` = y - x %*% 
-        o$beta, `10` = (diag(n) - W1ag) %*% y, `100` = (diag(n) - 
-        W2ag) %*% y, `11` = (diag(n) - W1ag) %*% y - x %*% o$beta, 
-        `101` = (diag(n) - W2ag) %*% (y - x %*% o$beta), `110` = (diag(n) - 
-            W2ag) %*% ((diag(n) - W1ag) %*% y), `111` = (diag(n) - 
-            W2ag) %*% ((diag(n) - W1ag) %*% y - x %*% o$beta)))
-    o$fitted.values <- as.vector(switch(comp.mode, `1` = x %*% 
-        o$beta, `10` = rep(0, n), `100` = rep(0, n), `11` = qr.solve(diag(n) - 
-        W1ag, x %*% o$beta), `101` = x %*% o$beta, `110` = rep(0, 
-        n), `111` = qr.solve(diag(n) - W1ag, x %*% o$beta)))
-    o$residuals <- as.vector(y - o$fitted.values)
-    o$call <- match.call()
-    class(o) <- c("lnam")
-    o
-}
-
-loadcent (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "directed", geodist.precomp = NULL, 
-    rescale = FALSE, ignore.eval = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], loadcent, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            geodist.precomp = geodist.precomp, rescale = rescale, 
-            ignore.eval = ignore.eval))
-    n <- attr(dat, "n")
-    if (gmode == "graph") 
-        cmode <- "undirected"
-    if (tmaxdev) {
-        lc <- switch(cmode, directed = (n - 1)^2 * (n - 2), undirected = (n - 
-            1)^2 * (n - 2)/2)
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode == "undirected") 
-            dat <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-        else dat <- gt(dat, return.as.edgelist = TRUE)
-        if (!is.null(geodist.precomp)) {
-            if (is.null(geodist.precomp$gdist) || is.null(geodist.precomp$counts) || 
-                is.null(geodist.precomp$predecessors)) {
-                warning("Precomputed geodist output must include distance, count, and predecessor information (at least one of which was missing in geodist.precomp).  Re-computing on the fly.\n")
-                precomp <- FALSE
-            }
-            else precomp <- TRUE
-        }
-        else {
-            precomp <- FALSE
+    else {
+        infobio0 = NULL
+        infobio = NULL
+    }
+    if (!is.null(infobio)) {
+        if (is.null(biotypes)) {
+            biotypes <- unique(infobio)
+            names(biotypes) <- biotypes
         }
-        lc <- .Call("betweenness_R", dat, n, NROW(dat), 8, precomp, 
-            ignore.eval, geodist.precomp$gdist, geodist.precomp$counts, 
-            geodist.precomp$predecessors, PACKAGE = "sna")
-        if (rescale) 
-            lc <- lc/sum(lc)
-        lc <- lc[nodes]
-    }
-    lc
-}
-
-logMean (closure) = function (x) 
-{
-    if (length(x) == 0) 
-        numeric(0)
-    else .C("logadd_R", as.double(x), as.integer(length(x)), 
-        lsum = as.double(0), NAOK = TRUE, PACKAGE = "sna")$lsum - 
-        log(length(x))
-}
-
-logSub (closure) = function (x, y) 
-{
-    if (length(x) != length(y)) 
-        stop("x and y must be of the same length.")
-    else if (length(x) == 0) 
-        numeric(0)
-    else .C("logsub_R", as.double(x), as.double(y), as.integer(length(x)), 
-        ldiff = as.double(rep(0, length(x))), NAOK = TRUE, PACKAGE = "sna")$ldiff
-}
-
-logSum (closure) = function (x) 
-{
-    if (length(x) == 0) 
-        numeric(0)
-    else .C("logadd_R", as.double(x), as.integer(length(x)), 
-        lsum = as.double(0), NAOK = TRUE, PACKAGE = "sna")$lsum
-}
-
-lower.tri.remove (closure) = function (dat, remove.val = NA) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, lower.tri.remove, val = remove.val))
-    if (length(dim(dat)) > 2) {
-        d <- dat
-        for (i in 1:dim(dat)[1]) {
-            temp <- d[i, , ]
-            temp[lower.tri(temp, diag = FALSE)] <- remove.val
-            d[i, , ] <- temp
-        }
-    }
-    else {
-        d <- dat
-        d[lower.tri(d, diag = FALSE)] <- remove.val
-    }
-    d
-}
-
-lubness (closure) = function (dat, g = NULL) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) {
-        if (is.null(g)) 
-            g <- 1:length(dat)
-        return(sapply(dat[g], lubness))
-    }
-    intlub <- function(g) {
-        r <- reachability(g)
-        cd <- component.dist(g, connected = "weak")
-        nolub <- 0
-        maxnolub <- 0
-        for (i in 1:max(cd$membership)) {
-            vi <- (1:dim(g)[1])[cd$membership == i]
-            if (length(vi) > 2) {
-                viol <- as.double(0)
-                viol <- .C("lubness_con_R", as.double(g[vi, vi]), 
-                  as.double(length(vi)), as.integer(r[vi, vi]), 
-                  viol = viol, PACKAGE = "sna")$viol
-                nolub <- nolub + viol
-                maxnolub <- maxnolub + (length(vi) - 1) * (length(vi) - 
-                  2)/2
-            }
-        }
-        1 - nolub/maxnolub
-    }
-    if (length(dim(dat)) > 2) {
-        if (!is.null(g)) 
-            dat <- dat[g, , , drop = FALSE]
-        lub <- apply(dat, 1, intlub)
-    }
-    else lub <- intlub(dat)
-    lub
-}
-
-make.stochastic (closure) = function (dat, mode = "rowcol", tol = 0.005, maxiter = prod(dim(dat)) * 
-    100, anneal.decay = 0.01, errpow = 1) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, make.stochastic, mode = mode, tol = tol, 
-            maxiter = maxiter, anneal.decay = anneal.decay, errpow = errpow))
-    m <- stackcount(dat)
-    if (m == 1) {
-        n <- dim(dat)[1]
-        o <- dim(dat)[2]
-        d <- array(dim = c(m, n, o))
-        d[1, , ] <- dat
-    }
-    else {
-        n <- dim(dat)[2]
-        o <- dim(dat)[3]
-        d <- dat
-    }
-    if (mode == "row") {
-        for (i in 1:m) d[i, , ] <- d[i, , ]/t(sapply(apply(d[i, 
-            , ], 1, sum), rep, o))
-    }
-    else if (mode == "col") {
-        for (i in 1:m) d[i, , ] <- d[i, , ]/sapply(apply(d[i, 
-            , ], 2, sum), rep, n)
-    }
-    else if (mode == "rowcol") {
-        for (i in 1:m) {
-            f <- d[i, , ]/t(sapply(apply(d[i, , ], 1, sum), rep, 
-                o))
-            f <- f/sapply(apply(f, 2, sum), rep, n)
-            edgelist <- cbind(rep(1:n, o), rep(1:o, rep(n, o)))
-            edgelist <- edgelist[d[i, , ][edgelist] > 0, ]
-            err <- sum(abs(apply(f, 2, sum) - rep(1, o))^errpow, 
-                abs(apply(f, 1, sum) - rep(1, n))^errpow)
-            iter <- 0
-            while ((err > (n + o) * tol) & (iter < maxiter)) {
-                edge <- sample(1:dim(edgelist)[1], 1)
-                x <- edgelist[edge, 1]
-                y <- edgelist[edge, 2]
-                draw <- max(0, min(rnorm(1, f[x, y], d[i, x, 
-                  y]/10), d[i, x, y]))
-                nerr <- err - abs(sum(f[x, ]) - 1)^errpow - abs(sum(f[, 
-                  y]) - 1)^errpow + abs(sum(f[x, ][-y]) + draw - 
-                  1)^errpow + abs(sum(f[, y][-x]) + draw - 1)^errpow
-                if ((nerr < err) | (runif(1, 0, 1) < exp(-anneal.decay * 
-                  iter))) {
-                  f[x, y] <- draw
-                  err <- nerr
-                }
-                iter <- iter + 1
+        biog <- lapply(biotypes, function(x) {
+            which(is.element(infobio0, x))
+        })
+        names(biog) = biotypes
+        bionum <- c(NROW(datos0), sapply(biog, length))
+        names(bionum) <- c("global", names(biotypes))
+        bio0 = which(bionum == 0)
+        if (length(bio0) > 0) 
+            bionum = bionum[-bio0]
+    }
+    else {
+        biotypes = NULL
+        bionum = NULL
+    }
+    if (is.null(bionum)) {
+        resumen = vector("list", length = 1)
+        names(resumen) = "global"
+    }
+    else {
+        resumen = vector("list", length = length(bionum))
+        names(resumen) = names(bionum)
+    }
+    cuentas = c(0, 1, 2, 5, 10)
+    if (is.null(factor)) {
+        if (norm) {
+            datosCPM = datos
+        }
+        else {
+            datosCPM = 10^6 * t(t(datos)/colSums(as.matrix(datos)))
+        }
+    }
+    else {
+        datosCPM = datos
+    }
+    for (i in 1:length(resumen)) {
+        if (i == 1) {
+            datosR = datosCPM
+        }
+        else {
+            if (!is.null(infobio)) {
+                datosR = datosCPM[which(infobio == names(resumen)[i]), 
+                  , drop = FALSE]
+            }
+        }
+        nfeatures = nrow(datosR)
+        datosR = datosR[which(rowSums(datosR) > 0), , drop = FALSE]
+        myglobal = NULL
+        mypersample = NULL
+        for (kk in 1:length(cuentas)) {
+            mypersample = rbind(mypersample, apply(datosR, 2, 
+                function(x) {
+                  length(which(x > cuentas[kk]))
+                }))
+            myglobal = c(myglobal, sum(apply(datosR, 1, function(x) {
+                max(x) > cuentas[kk]
+            })))
+        }
+        mypersample = round(100 * mypersample/nfeatures, 1)
+        mypersample = rbind(mypersample, depth)
+        rownames(mypersample) = 1:nrow(mypersample)
+        myglobal = c(round(100 * myglobal/nfeatures, 1), nfeatures)
+        resumen[[i]] = data.frame(c(paste("CPM >", cuentas), 
+            "depth"), mypersample, total = myglobal)
+        colnames(resumen[[i]])[1] = names(resumen)[i]
+        colnames(resumen[[i]])[2:(ncol(resumen[[i]]) - 1)] = colnames(datosR)
+    }
+    cosas <- list(result = datos0, bionum = bionum, biotypes = infobio0, 
+        summary = resumen)
+    cosas
+}
+
+countsbio.plot (closure) = function (dat, samples = c(1, 2), toplot = "global", plottype = c("barplot", 
+    "boxplot"), toreport = FALSE, ...) 
+{
+    mypar = par(no.readonly = TRUE)
+    plottype = match.arg(plottype)
+    if (is.null(samples)) {
+        if (NCOL(dat$result) == 1) {
+            samples = 1
+        }
+        else {
+            samples <- 1:NCOL(dat$result)
+        }
+    }
+    if (is.numeric(toplot)) 
+        toplot = names(dat$summary)[toplot]
+    if (is.numeric(samples) && !is.null(colnames(dat$result))) 
+        samples = colnames(dat$result)[samples]
+    if (plottype == "barplot") {
+        if ((exists("ylab") && !is.character(ylab)) || !exists("ylab")) 
+            ylab = ""
+        datos = dat$summary[[toplot]]
+        mytotal = as.numeric(datos[, "total"])
+        datos = as.matrix(datos[, samples])
+        rownames(datos) = as.character(dat$summary[[toplot]][, 
+            1])
+        par(mar = c(6, 4, 4, 2))
+        barplot(as.numeric(datos[1, ]), col = miscolores[1], 
+            las = 2, main = "", ylab = "", density = 70, ylim = c(0, 
+                100), cex.axis = 0.8, names.arg = "", ...)
+        for (i in 2:(length(mytotal) - 2)) {
+            barplot(as.numeric(datos[i, ]), col = miscolores[i], 
+                las = 2, main = "", ylab = "", add = TRUE, density = 70, 
+                ylim = c(0, 100), cex.axis = 0.8, names.arg = "", 
+                ...)
+        }
+        bp = barplot(as.numeric(datos[(length(mytotal) - 1), 
+            ]), col = miscolores[(length(mytotal) - 1)], las = 2, 
+            main = paste(toupper(toplot), " (", mytotal[length(mytotal)], 
+                ")", sep = ""), ylab = "Sensitivity (%)", add = TRUE, 
+            names.arg = colnames(datos), cex.axis = 0.8, density = 70, 
+            ylim = c(0, 100), cex.names = 0.8, ...)
+        for (j in 1:(length(mytotal) - 1)) abline(h = mytotal[j], 
+            col = miscolores[j], lwd = 2)
+        if (length(samples) <= 10) {
+            mtext(side = 3, text = datos["depth", ], adj = 0.5, 
+                at = bp, cex = 0.8)
+        }
+        else {
+            mtext(side = 3, text = datos["depth", ], at = bp, 
+                cex = 0.7, las = 2)
+        }
+        legend("top", rownames(datos)[-length(mytotal)], fill = miscolores, 
+            density = 70, bty = "n", ncol = 3)
+        par(mar = c(5, 4, 4, 4) + 0.1)
+    }
+    if (plottype == "boxplot") {
+        conteos <- as.matrix(dat$result[, samples])
+        if (is.numeric(samples)) 
+            colnames(conteos) = colnames(dat$result)[samples]
+        else colnames(conteos) = samples
+        num <- dat$bionum[toplot]
+        if (is.null(num)) {
+            if (toplot == "global") {
+                num = nrow(conteos)
             }
-            d[i, , ] <- f
-            if (err > (n + o) * tol) 
-                warning(paste("Annealer unable to reduce total error below apx", 
-                  round(err, digits = 7), "in matrix", i, ". Hope that's OK....\n"))
-        }
-    }
-    else if (mode == "total") {
-        for (i in 1:m) d[i, , ] <- d[i, , ]/sum(d[i, , ])
-    }
-    d[is.nan(d)] <- 0
-    if (m == 1) 
-        d[1, , ]
-    else d
-}
-
-maxflow (closure) = function (dat, src = NULL, sink = NULL, ignore.eval = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, maxflow, src = src, sink = sink, ignore.eval = ignore.eval))
-    else if (length(dim(dat)) > 2) 
-        return(apply(dat, 1, maxflow, src = src, sink = sink, 
-            ignore.eval = ignore.eval))
-    n <- NROW(dat)
-    dat[is.na(dat)] <- 0
-    if (ignore.eval) 
-        dat[dat != 0] <- 1
-    if (length(src) == 0) 
-        src <- 1:n
-    else src <- src[(src > 0) & (src <= n)]
-    if (length(sink) == 0) 
-        sink <- 1:n
-    else sink <- sink[(sink > 0) & (sink <= n)]
-    fmat <- matrix(nrow = length(src), ncol = length(sink))
-    for (i in 1:length(src)) for (j in 1:length(sink)) fmat[i, 
-        j] <- .C("maxflow_EK_R", as.double(dat), as.integer(NROW(dat)), 
-        as.integer(src[i] - 1), as.integer(sink[j] - 1), flow = as.double(0), 
-        NAOK = TRUE, PACKAGE = "sna")$flo
-    if (length(src) * length(sink) > 1) {
-        if (is.null(rownames(dat))) 
-            rownames(fmat) <- src
-        else rownames(fmat) <- rownames(dat)[src]
-        if (is.null(colnames(dat))) 
-            colnames(fmat) <- sink
-        else colnames(fmat) <- colnames(dat)[sink]
-    }
-    else fmat <- as.numeric(fmat)
-    fmat
-}
-
-mutuality (closure) = function (dat, g = NULL) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) {
-        if (!is.null(g)) 
-            dat <- dat[g]
-    }
-    dc <- dyad.census(dat)
-    dc[, 1]
-}
-
-nacf (closure) = function (net, y, lag.max = NULL, type = c("correlation", "covariance", 
-    "moran", "geary"), neighborhood.type = c("in", "out", "total"), 
-    partial.neighborhood = TRUE, mode = "digraph", diag = FALSE, 
-    thresh = 0, demean = TRUE) 
-{
-    net <- as.sociomatrix.sna(net)
-    if (is.list(net)) 
-        return(lapply(net, nacf, y = y, lag.max = lag.max, neighborhood.type = neighborhood.type, 
-            partial.neighborhood = partial.neighborhood, mode = mode, 
-            diag = diag, thresh = thresh, demean = demean))
-    else if (length(dim(net)) > 2) 
-        return(apply(net, 1, nacf, y = y, lag.max = lag.max, 
-            neighborhood.type = neighborhood.type, partial.neighborhood = partial.neighborhood, 
-            mode = mode, diag = diag, thresh = thresh, demean = demean))
-    if (length(y) != NROW(net)) 
-        stop("Network size must match covariate length in nacf.")
-    if (demean || (match.arg(type) == "moran")) 
-        y <- y - mean(y)
-    vary <- var(y)
-    if (is.null(lag.max)) 
-        lag.max <- NROW(net) - 1
-    neigh <- neighborhood(net, order = lag.max, neighborhood.type = neighborhood.type, 
-        mode = mode, diag = diag, thresh = thresh, return.all = TRUE, 
-        partial = partial.neighborhood)
-    v <- switch(match.arg(type), covariance = t(y) %*% y/NROW(net), 
-        correlation = 1, moran = 1, geary = 0, )
-    for (i in 1:lag.max) {
-        ec <- sum(neigh[i, , ])
-        if (ec > 0) {
-            v[i + 1] <- switch(match.arg(type), covariance = (t(y) %*% 
-                neigh[i, , ] %*% y)/ec, correlation = ((t(y) %*% 
-                neigh[i, , ] %*% y)/ec)/vary, moran = NROW(net)/ec * 
-                sum((y %o% y) * neigh[i, , ])/sum(y^2), geary = (NROW(net) - 
-                1)/(2 * ec) * sum(neigh[i, , ] * outer(y, y, 
-                "-")^2)/sum((y - mean(y))^2), )
-        }
-        else v[i + 1] <- 0
-    }
-    names(v) <- 0:lag.max
-    v
-}
-
-neighborhood (closure) = function (dat, order, neighborhood.type = c("in", "out", "total"), 
-    mode = "digraph", diag = FALSE, thresh = 0, return.all = FALSE, 
-    partial = TRUE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, neighborhood, order = order, neighborhood.type = neighborhood.type, 
-            mode = mode, diag = diag, thresh = thresh, return.all = return.all, 
-            partial = partial))
-    else if (length(dim(dat)) > 2) 
-        return(apply(dat, 1, neighborhood, order = order, neighborhood.type = neighborhood.type, 
-            mode = mode, diag = diag, thresh = thresh, return.all = return.all, 
-            partial = partial))
-    dat <- dat > thresh
-    if ((mode == "graph") || (match.arg(neighborhood.type) == 
-        "total")) 
-        dat <- dat | t(dat)
-    if (match.arg(neighborhood.type) == "in") 
-        dat <- t(dat)
-    geo <- geodist(dat)
-    if (return.all) {
-        neigh <- array(dim = c(order, NROW(dat), NROW(dat)))
-        for (i in 1:order) {
-            neigh[i, , ] <- switch(partial + 1, geo$gdist <= 
-                i, geo$gdist == i)
-            if (!diag) 
-                diag(neigh[i, , ]) <- 0
-        }
-    }
-    else {
-        neigh <- switch(partial + 1, geo$gdist <= order, geo$gdist == 
-            order)
-        if (!diag) 
-            diag(neigh) <- 0
-    }
-    neigh
-}
-
-netcancor (closure) = function (y, x, mode = "digraph", diag = FALSE, nullhyp = "cugtie", 
-    reps = 1000) 
-{
-    y <- as.sociomatrix.sna(y)
-    x <- as.sociomatrix.sna(x)
-    if (is.list(x) | is.list(y)) 
-        stop("netcancor requires graphs of identical order.")
-    if (length(dim(y)) > 2) {
-        iy <- matrix(nrow = dim(y)[1], ncol = dim(y)[2] * dim(y)[3])
-    }
-    else {
-        iy <- matrix(nrow = 1, ncol = dim(y)[1] * dim(y)[2])
-        temp <- y
-        y <- array(dim = c(1, dim(temp)[1], dim(temp)[2]))
-        y[1, , ] <- temp
-    }
-    if (length(dim(x)) > 2) {
-        ix <- matrix(nrow = dim(x)[1], ncol = dim(x)[2] * dim(x)[3])
-    }
-    else {
-        ix <- matrix(nrow = 1, ncol = dim(x)[1] * dim(x)[2])
-        temp <- x
-        x <- array(dim = c(1, dim(temp)[1], dim(temp)[2]))
-        x[1, , ] <- temp
-    }
-    my <- dim(y)[1]
-    mx <- dim(x)[1]
-    n <- dim(y)[2]
-    out <- list()
-    out$xdist <- array(dim = c(reps, mx, mx))
-    out$ydist <- array(dim = c(reps, my, my))
-    for (i in 1:my) {
-        d <- y[i, , ]
-        iy[i, ] <- as.vector(d)
-    }
-    for (i in 1:mx) {
-        d <- x[i, , ]
-        ix[i, ] <- as.vector(d)
-    }
-    nc <- cancor(t(ix), t(iy))
-    out$cdist <- array(dim = c(reps, length(nc$cor)))
-    for (i in 1:reps) {
-        iy <- matrix(nrow = dim(y)[1], ncol = dim(y)[2] * dim(y)[3])
-        ix <- matrix(nrow = dim(x)[1], ncol = dim(x)[2] * dim(x)[3])
-        for (j in 1:my) {
-            d <- switch(nullhyp, qap = rmperm(y[j, , ]), cug = rgraph(n, 
-                1, mode = mode, diag = diag), cugden = rgraph(n, 
-                1, tprob = gden(y[j, , ], mode = mode, diag = diag), 
-                mode = mode, diag = diag), cugtie = rgraph(n, 
-                1, mode = mode, diag = diag, tielist = y[j, , 
-                  ]))
-            iy[j, ] <- as.vector(d)
-        }
-        for (j in 1:mx) {
-            d <- switch(nullhyp, qap = rmperm(x[j, , ]), cug = rgraph(n, 
-                1, mode = mode, diag = diag), cugden = rgraph(n, 
-                1, tprob = gden(x[j, , ], mode = mode, diag = diag), 
-                mode = mode, diag = diag), cugtie = rgraph(n, 
-                1, mode = mode, diag = diag, tielist = x[j, , 
-                  ]))
-            ix[j, ] <- as.vector(d)
-        }
-        tc <- cancor(t(ix), t(iy))
-        out$cdist[i, ] <- tc$cor
-        out$xdist[i, , ] <- tc$xcoef
-        out$ydist[i, , ] <- tc$ycoef
-    }
-    out$cor <- nc$cor
-    out$xcoef <- nc$xcoef
-    out$ycoef <- nc$ycoef
-    out$cpgreq <- vector(length = length(nc$cor))
-    out$cpleeq <- vector(length = length(nc$cor))
-    for (i in 1:length(nc$cor)) {
-        out$cpgreq[i] <- mean(out$cdist[, i] >= out$cor[i], na.rm = TRUE)
-        out$cpleeq[i] <- mean(out$cdist[, i] <= out$cor[i], na.rm = TRUE)
-    }
-    out$xpgreq <- matrix(ncol = mx, nrow = mx)
-    out$xpleeq <- matrix(ncol = mx, nrow = mx)
-    for (i in 1:mx) {
-        for (j in 1:mx) {
-            out$xpgreq[i, j] <- mean(out$xdist[, i, j] >= out$xcoef[i, 
-                j], na.rm = TRUE)
-            out$xpleeq[i, j] <- mean(out$xdist[, i, j] <= out$xcoef[i, 
-                j], na.rm = TRUE)
-        }
-    }
-    out$ypgreq <- matrix(ncol = my, nrow = my)
-    out$ypleeq <- matrix(ncol = my, nrow = my)
-    for (i in 1:my) {
-        for (j in 1:my) {
-            out$ypgreq[i, j] <- mean(out$ydist[, i, j] >= out$ycoef[i, 
-                j], na.rm = TRUE)
-            out$ypleeq[i, j] <- mean(out$ydist[, i, j] <= out$ycoef[i, 
-                j], na.rm = TRUE)
-        }
-    }
-    out$cnames <- as.vector(paste("cor", 1:min(mx, my), sep = ""))
-    out$xnames <- as.vector(paste("x", 1:mx, sep = ""))
-    out$ynames <- as.vector(paste("y", 1:my, sep = ""))
-    out$xcenter <- nc$xcenter
-    out$ycenter <- nc$ycenter
-    out$nullhyp <- nullhyp
-    class(out) <- c("netcancor")
-    out
-}
-
-netlm (closure) = function (y, x, intercept = TRUE, mode = "digraph", diag = FALSE, 
-    nullhyp = c("qap", "qapspp", "qapy", "qapx", "qapallx", "cugtie", 
-        "cugden", "cuguman", "classical"), test.statistic = c("t-value", 
-        "beta"), tol = 1e-07, reps = 1000) 
-{
-    gettval <- function(x, y, tol) {
-        xqr <- qr(x, tol = tol)
-        coef <- qr.coef(xqr, y)
-        resid <- qr.resid(xqr, y)
-        rank <- xqr$rank
-        n <- length(y)
-        rdf <- n - rank
-        resvar <- sum(resid^2)/rdf
-        cvm <- chol2inv(xqr$qr)
-        se <- sqrt(diag(cvm) * resvar)
-        coef/se
-    }
-    gfit <- function(glist, mode, diag, tol, rety, tstat) {
-        y <- gvectorize(glist[[1]], mode = mode, diag = diag, 
-            censor.as.na = TRUE)
-        x <- vector()
-        for (i in 2:length(glist)) x <- cbind(x, gvectorize(glist[[i]], 
-            mode = mode, diag = diag, censor.as.na = TRUE))
-        if (!is.matrix(x)) 
-            x <- matrix(x, ncol = 1)
-        mis <- is.na(y) | apply(is.na(x), 1, any)
-        if (!rety) {
-            if (tstat == "beta") 
-                qr.solve(x[!mis, ], y[!mis], tol = tol)
-            else if (tstat == "t-value") {
-                gettval(x[!mis, ], y[!mis], tol = tol)
+            else {
+                num = 0
             }
         }
-        else {
-            list(qr(x[!mis, ], tol = tol), y[!mis])
-        }
-    }
-    y <- as.sociomatrix.sna(y)
-    x <- as.sociomatrix.sna(x)
-    if (is.list(y) || ((length(dim(y)) > 2) && (dim(y)[1] > 1))) 
-        stop("y must be a single graph in netlm.")
-    if (length(dim(y)) > 2) 
-        y <- y[1, , ]
-    if (is.list(x) || (dim(x)[2] != dim(y)[2])) 
-        stop("Homogeneous graph orders required in netlm.")
-    nx <- stackcount(x) + intercept
-    n <- dim(y)[2]
-    g <- list(y)
-    if (intercept) 
-        g[[2]] <- matrix(1, n, n)
-    if (nx - intercept == 1) 
-        g[[2 + intercept]] <- x
-    else for (i in 1:(nx - intercept)) g[[i + 1 + intercept]] <- x[i, 
-        , ]
-    if (any(sapply(lapply(g, is.na), any))) 
-        warning("Missing data supplied to netlm; this may pose problems for certain null hypotheses.  Hope you know what you're doing....")
-    fit.base <- gfit(g, mode = mode, diag = diag, tol = tol, 
-        rety = TRUE)
-    fit <- list()
-    fit$coefficients <- qr.coef(fit.base[[1]], fit.base[[2]])
-    fit$fitted.values <- qr.fitted(fit.base[[1]], fit.base[[2]])
-    fit$residuals <- qr.resid(fit.base[[1]], fit.base[[2]])
-    fit$qr <- fit.base[[1]]
-    fit$rank <- fit.base[[1]]$rank
-    fit$n <- length(fit.base[[2]])
-    fit$df.residual <- fit$n - fit$rank
-    tstat <- match.arg(test.statistic)
-    if (tstat == "beta") 
-        fit$tstat <- fit$coefficients
-    else if (tstat == "t-value") 
-        fit$tstat <- fit$coefficients/sqrt(diag(chol2inv(fit$qr$qr)) * 
-            sum(fit$residuals^2)/(fit$n - fit$rank))
-    nullhyp <- match.arg(nullhyp)
-    if ((nullhyp %in% c("qap", "qapspp")) && (nx == 1)) 
-        nullhyp <- "qapy"
-    if (nullhyp == "classical") {
-        resvar <- sum(fit$residuals^2)/fit$df.residual
-        cvm <- chol2inv(fit$qr$qr)
-        se <- sqrt(diag(cvm) * resvar)
-        tval <- fit$coefficients/se
-        fit$dist <- NULL
-        fit$pleeq <- pt(tval, fit$df.residual)
-        fit$pgreq <- pt(tval, fit$df.residual, lower.tail = FALSE)
-        fit$pgreqabs <- 2 * pt(abs(tval), fit$df.residual, lower.tail = FALSE)
-    }
-    else if (nullhyp %in% c("cugtie", "cugden", "cuguman")) {
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            gr <- g
-            for (j in 1:reps) {
-                gr[[i + 1]] <- switch(nullhyp, cugtie = rgraph(n, 
-                  mode = mode, diag = diag, replace = FALSE, 
-                  tielist = g[[i + 1]]), cugden = rgraph(n, tprob = gden(g[[i + 
-                  1]], mode = mode, diag = diag), mode = mode, 
-                  diag = diag), cuguman = (function(dc, n) {
-                  rguman(1, n, mut = dc[1], asym = dc[2], null = dc[3], 
-                    method = "exact")
-                })(dyad.census(g[[i + 1]]), n))
-                repdist[j, i] <- gfit(gr, mode = mode, diag = diag, 
-                  tol = tol, rety = FALSE, tstat = tstat)[i]
-            }
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapy") {
-        repdist <- matrix(0, reps, nx)
-        gr <- g
-        for (i in 1:reps) {
-            gr[[1]] <- rmperm(g[[1]])
-            repdist[i, ] <- gfit(gr, mode = mode, diag = diag, 
-                tol = tol, rety = FALSE, tstat = tstat)
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapx") {
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            gr <- g
-            for (j in 1:reps) {
-                gr[[i + 1]] <- rmperm(gr[[i + 1]])
-                repdist[j, i] <- gfit(gr, mode = mode, diag = diag, 
-                  tol = tol, rety = FALSE, tstat = tstat)[i]
-            }
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapallx") {
-        repdist <- matrix(0, reps, nx)
-        gr <- g
-        for (i in 1:reps) {
-            for (j in 1:nx) gr[[1 + j]] <- rmperm(g[[1 + j]])
-            repdist[i, ] <- gfit(gr, mode = mode, diag = diag, 
-                tol = tol, rety = FALSE, tstat = tstat)
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if ((nullhyp == "qap") || (nullhyp == "qapspp")) {
-        xsel <- matrix(TRUE, n, n)
-        if (!diag) 
-            diag(xsel) <- FALSE
-        if (mode == "graph") 
-            xsel[upper.tri(xsel)] <- FALSE
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            xfit <- gfit(g[1 + c(i, (1:nx)[-i])], mode = mode, 
-                diag = diag, tol = tol, rety = TRUE, tstat = tstat)
-            xres <- g[[1 + i]]
-            xres[xsel] <- qr.resid(xfit[[1]], xfit[[2]])
-            if (mode == "graph") 
-                xres[upper.tri(xres)] <- t(xres)[upper.tri(xres)]
-            for (j in 1:reps) repdist[j, i] <- gfit(c(g[-(1 + 
-                i)], list(rmperm(xres))), mode = mode, diag = diag, 
-                tol = tol, rety = FALSE, tstat = tstat)[nx]
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    fit$nullhyp <- nullhyp
-    fit$names <- paste("x", 1:(nx - intercept), sep = "")
-    if (intercept) 
-        fit$names <- c("(intercept)", fit$names)
-    fit$intercept <- intercept
-    class(fit) <- "netlm"
-    fit
-}
-
-netlogit (closure) = function (y, x, intercept = TRUE, mode = "digraph", diag = FALSE, 
-    nullhyp = c("qap", "qapspp", "qapy", "qapx", "qapallx", "cugtie", 
-        "cugden", "cuguman", "classical"), test.statistic = c("z-value", 
-        "beta"), tol = 1e-07, reps = 1000) 
-{
-    gfit <- function(glist, mode, diag) {
-        y <- gvectorize(glist[[1]], mode = mode, diag = diag, 
-            censor.as.na = TRUE)
-        x <- vector()
-        for (i in 2:length(glist)) x <- cbind(x, gvectorize(glist[[i]], 
-            mode = mode, diag = diag, censor.as.na = TRUE))
-        if (!is.matrix(x)) 
-            x <- matrix(x, ncol = 1)
-        mis <- is.na(y) | apply(is.na(x), 1, any)
-        glm.fit(x[!mis, ], y[!mis], family = binomial(), intercept = FALSE)
-    }
-    gfitlm <- function(glist, mode, diag, tol) {
-        y <- gvectorize(glist[[1]], mode = mode, diag = diag, 
-            censor.as.na = TRUE)
-        x <- vector()
-        for (i in 2:length(glist)) x <- cbind(x, gvectorize(glist[[i]], 
-            mode = mode, diag = diag, censor.as.na = TRUE))
-        if (!is.matrix(x)) 
-            x <- matrix(x, ncol = 1)
-        mis <- is.na(y) | apply(is.na(x), 1, any)
-        list(qr(x[!mis, ], tol = tol), y[!mis])
-    }
-    y <- as.sociomatrix.sna(y)
-    x <- as.sociomatrix.sna(x)
-    if (is.list(y) || ((length(dim(y)) > 2) && (dim(y)[1] > 1))) 
-        stop("y must be a single graph in netlogit.")
-    if (length(dim(y)) > 2) 
-        y <- y[1, , ]
-    if (is.list(x) || (dim(x)[2] != dim(y)[2])) 
-        stop("Homogeneous graph orders required in netlogit.")
-    nx <- stackcount(x) + intercept
-    n <- dim(y)[2]
-    g <- list(y)
-    if (intercept) 
-        g[[2]] <- matrix(1, n, n)
-    if (nx - intercept == 1) 
-        g[[2 + intercept]] <- x
-    else for (i in 1:(nx - intercept)) g[[i + 1 + intercept]] <- x[i, 
-        , ]
-    if (any(sapply(lapply(g, is.na), any))) 
-        warning("Missing data supplied to netlogit; this may pose problems for certain null hypotheses.  Hope you know what you're doing....")
-    fit.base <- gfit(g, mode = mode, diag = diag)
-    fit <- list()
-    fit$coefficients <- fit.base$coefficients
-    fit$fitted.values <- fit.base$fitted.values
-    fit$residuals <- fit.base$residuals
-    fit$se <- sqrt(diag(chol2inv(fit.base$qr$qr)))
-    tstat <- match.arg(test.statistic)
-    fit$test.statistic <- tstat
-    if (tstat == "beta") 
-        fit$tstat <- fit$coefficients
-    else if (tstat == "z-value") 
-        fit$tstat <- fit$coefficients/fit$se
-    fit$linear.predictors <- fit.base$linear.predictors
-    fit$n <- length(fit.base$y)
-    fit$df.model <- fit.base$rank
-    fit$df.residual <- fit.base$df.residual
-    fit$deviance <- fit.base$deviance
-    fit$null.deviance <- fit.base$null.deviance
-    fit$df.null <- fit.base$df.null
-    fit$aic <- fit.base$aic
-    fit$bic <- fit$deviance + fit$df.model * log(fit$n)
-    fit$qr <- fit.base$qr
-    fit$ctable <- table(as.numeric(fit$fitted.values >= 0.5), 
-        fit.base$y, dnn = c("Predicted", "Actual"))
-    if (NROW(fit$ctable) == 1) {
-        if (rownames(fit$ctable) == "0") 
-            fit$ctable <- rbind(fit$ctable, c(0, 0))
-        else fit$ctable <- rbind(c(0, 0), fit$ctable)
-        rownames(fit$ctable) <- c("0", "1")
-    }
-    nullhyp <- match.arg(nullhyp)
-    if ((nullhyp %in% c("qap", "qapspp")) && (nx == 1)) 
-        nullhyp <- "qapy"
-    if (nullhyp == "classical") {
-        cvm <- chol2inv(fit$qr$qr)
-        se <- sqrt(diag(cvm))
-        tval <- fit$coefficients/se
-        fit$dist <- NULL
-        fit$pleeq <- pt(tval, fit$df.residual)
-        fit$pgreq <- pt(tval, fit$df.residual, lower.tail = FALSE)
-        fit$pgreqabs <- 2 * pt(abs(tval), fit$df.residual, lower.tail = FALSE)
-    }
-    else if (nullhyp %in% c("cugtie", "cugden", "cuguman")) {
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            gr <- g
-            for (j in 1:reps) {
-                gr[[i + 1]] <- switch(nullhyp, cugtie = rgraph(n, 
-                  mode = mode, diag = diag, replace = FALSE, 
-                  tielist = g[[i + 1]]), cugden = rgraph(n, tprob = gden(g[[i + 
-                  1]], mode = mode, diag = diag), mode = mode, 
-                  diag = diag), cuguman = (function(dc, n) {
-                  rguman(1, n, mut = dc[1], asym = dc[2], null = dc[3], 
-                    method = "exact")
-                })(dyad.census(g[[i + 1]]), n))
-                repfit <- gfit(gr, mode = mode, diag = diag)
-                if (tstat == "beta") 
-                  repdist[j, i] <- repfit$coef[i]
-                else repdist[j, i] <- repfit$coef[i]/sqrt(diag(chol2inv(repfit$qr$qr)))[i]
-            }
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapy") {
-        repdist <- matrix(0, reps, nx)
-        gr <- g
-        for (i in 1:reps) {
-            gr[[1]] <- rmperm(g[[1]])
-            repfit <- gfit(gr, mode = mode, diag = diag)
-            if (tstat == "beta") 
-                repdist[i, ] <- repfit$coef
-            else repdist[i, ] <- repfit$coef/sqrt(diag(chol2inv(repfit$qr$qr)))
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapx") {
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            gr <- g
-            for (j in 1:reps) {
-                gr[[i + 1]] <- rmperm(gr[[i + 1]])
-                repfit <- gfit(gr, mode = mode, diag = diag)
-                if (tstat == "beta") 
-                  repdist[j, i] <- repfit$coef[i]
-                else repdist[j, i] <- repfit$coef[i]/sqrt(diag(chol2inv(repfit$qr$qr)))[i]
-            }
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if (nullhyp == "qapallx") {
-        repdist <- matrix(0, reps, nx)
-        gr <- g
-        for (i in 1:reps) {
-            for (j in 1:nx) gr[[1 + j]] <- rmperm(g[[1 + j]])
-            repfit <- gfit(gr, mode = mode, diag = diag)
-            if (tstat == "beta") 
-                repdist[i, ] <- repfit$coef
-            else repdist[i, ] <- repfit$coef/sqrt(diag(chol2inv(repfit$qr$qr)))
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    else if ((nullhyp == "qap") || (nullhyp == "qapspp")) {
-        xsel <- matrix(TRUE, n, n)
-        if (!diag) 
-            diag(xsel) <- FALSE
-        if (mode == "graph") 
-            xsel[upper.tri(xsel)] <- FALSE
-        repdist <- matrix(0, reps, nx)
-        for (i in 1:nx) {
-            xfit <- gfitlm(g[1 + c(i, (1:nx)[-i])], mode = mode, 
-                diag = diag, tol = tol)
-            xres <- g[[1 + i]]
-            xres[xsel] <- qr.resid(xfit[[1]], xfit[[2]])
-            if (mode == "graph") 
-                xres[upper.tri(xres)] <- t(xres)[upper.tri(xres)]
-            for (j in 1:reps) {
-                repfit <- gfit(c(g[-(1 + i)], list(rmperm(xres))), 
-                  mode = mode, diag = diag)
-                if (tstat == "beta") 
-                  repdist[j, i] <- repfit$coef[nx]
-                else repdist[j, i] <- repfit$coef[nx]/sqrt(diag(chol2inv(repfit$qr$qr)))[nx]
-            }
-        }
-        fit$dist <- repdist
-        fit$pleeq <- apply(sweep(fit$dist, 2, fit$tstat, "<="), 
-            2, mean)
-        fit$pgreq <- apply(sweep(fit$dist, 2, fit$tstat, ">="), 
-            2, mean)
-        fit$pgreqabs <- apply(sweep(abs(fit$dist), 2, abs(fit$tstat), 
-            ">="), 2, mean)
-    }
-    fit$nullhyp <- nullhyp
-    fit$names <- paste("x", 1:(nx - intercept), sep = "")
-    if (intercept) 
-        fit$names <- c("(intercept)", fit$names)
-    fit$intercept <- intercept
-    class(fit) <- "netlogit"
-    fit
-}
-
-npostpred (closure) = function (b, FUN, ...) 
-{
-    fun <- match.fun(FUN)
-    out <- apply(b$net, 1, fun, ...)
-    out
-}
-
-nties (closure) = function (dat, mode = "digraph", diag = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, nties, mode = mode, diag = diag))
-    if (length(dim(dat)) > 2) 
-        shiftit <- 1
-    else shiftit <- 0
-    n <- dim(dat)[1 + shiftit]
-    m <- dim(dat)[2 + shiftit]
-    if (mode == "hgraph") 
-        diag <- TRUE
-    count <- switch(mode, digraph = n * n, graph = (n * n - n)/2 + 
-        n, hgraph = n * m)
-    if (!diag) 
-        count <- count - n
-    if (shiftit) 
-        rep(count, dim(dat)[1])
-    else count
-}
-
-numperm (closure) = function (olength, permnum) 
-{
-    if ((permnum > gamma(olength + 1) - 1) | (permnum < 0)) {
-        cat("permnum must be an integer in [0,olength!-1]\n")
-    }
-    o <- vector(length = olength)
-    o[] <- -1
-    pnum <- permnum
-    for (i in 1:olength) {
-        relpos <- pnum%%(olength - i + 1)
-        flag <- FALSE
-        p <- 1
-        while (!flag) if (o[p] == -1) {
-            if (relpos == 0) {
-                o[p] <- i
-                flag <- TRUE
+        infobio = dat$biotypes
+        if (num == 0 && toplot != "global") 
+            stop("Error: No data available. Please, change toplot parameter.")
+        if ((exists("ylab") && !is.character(ylab)) || !exists("ylab")) 
+            ylab = "Expression values"
+        if (length(samples) == 1) {
+            escala = logscaling(conteos, base = 2)
+            if (is.null(infobio)) {
+                boxplot(escala$data, col = miscolores[1], ylab = ylab, 
+                  main = "", yaxt = "n", ...)
             }
             else {
-                p <- p + 1
-                relpos <- relpos - 1
+                par(mar = c(10, 4, 4, 2))
+                boxplot(escala$data ~ infobio, col = miscolores, 
+                  ylab = ylab, main = colnames(conteos), las = 2, 
+                  cex.axis = 0.8, cex.lab = 0.9, yaxt = "n", 
+                  ...)
+                cuantos = dat$bionum[-1]
+                cuantos = cuantos[sort(names(cuantos))]
+                mtext(cuantos, 3, at = 1:length(cuantos), cex = 0.6, 
+                  las = 2)
             }
         }
-        else p <- p + 1
-        pnum <- pnum%/%(olength - i + 1)
-    }
-    o
-}
-
-plot.bbnam (closure) = function (x, mode = "density", intlines = TRUE, ...) 
-{
-    UseMethod("plot", x)
-}
-
-plot.bbnam.actor (closure) = function (x, mode = "density", intlines = TRUE, ...) 
-{
-    oldpar <- par(no.readonly = TRUE)
-    par(ask = dev.interactive())
-    par(mfrow = c(2, 1))
-    if (mode == "density") {
-        plot(density(x$em), main = substitute(paste("Estimated Marginal Population Density of ", 
-            {
-                e^{
-                  "-"
-                }
-            }, ", ", draws, " Draws"), list(draws = x$draws)), 
-            xlab = expression({
-                e^{
-                  "-"
-                }
-            }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$em, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-        plot(density(x$ep), main = substitute(paste("Estimated Marginal Population Density of ", 
-            {
-                e^{
-                  "+"
-                }
-            }, ", ", draws, " Draws"), list(draws = x$draws)), 
-            xlab = expression({
-                e^{
-                  "+"
-                }
-            }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$ep, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-    }
-    else {
-        hist(x$em, main = substitute(paste("Histogram of ", {
-            e^{
-                "-"
-            }
-        }, ", ", draws, " Draws"), list(draws = x$draws)), xlab = expression({
-            e^{
-                "-"
-            }
-        }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$em, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-        hist(x$ep, main = substitute(paste("Histogram of ", {
-            e^{
-                "+"
-            }
-        }, ", ", draws, " Draws"), list(draws = x$draws)), xlab = expression({
-            e^{
-                "+"
-            }
-        }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$ep, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-    }
-    par(mfrow = c(floor(sqrt(x$nobservers)), ceiling(sqrt(x$nobservers))))
-    for (i in 1:x$nobservers) {
-        if (mode == "density") {
-            plot(density(x$em[, i]), main = substitute({
-                e^{
-                  "-"
-                }
-            }[it], list(it = i)), xlab = substitute({
-                e^{
-                  "-"
-                }
-            }[it], list(it = i)), xlim = c(0, 1), ...)
-            if (intlines) 
-                abline(v = quantile(x$em[, i], c(0.05, 0.5, 0.95)), 
-                  lty = c(3, 2, 3))
-        }
         else {
-            hist(x$em[, i], main = substitute({
-                e^{
-                  "-"
-                }
-            }[it], list(it = i)), xlab = substitute({
-                e^{
-                  "-"
-                }
-            }[it], list(it = i)), xlim = c(0, 1), ...)
-            if (intlines) 
-                abline(v = quantile(x$em[, i], c(0.05, 0.5, 0.95)), 
-                  lty = c(3, 2, 3))
+            if (toplot != "global") 
+                conteos = conteos[which(infobio == toplot), ]
+            escala = logscaling(conteos, base = 2)
+            main <- paste(toupper(toplot), " (", num, ")", sep = "")
+            par(mar = c(6, 4, 2, 2))
+            boxplot(escala$data, col = miscolores, ylab = ylab, 
+                main = main, las = 2, cex.lab = 0.9, cex.axis = 0.8, 
+                yaxt = "n", ...)
         }
+        axis(side = 2, at = escala$at, labels = escala$labels)
     }
-    par(mfrow = c(floor(sqrt(x$nobservers)), ceiling(sqrt(x$nobservers))))
-    for (i in 1:x$nobservers) {
-        if (mode == "density") {
-            plot(density(x$ep[, i]), main = substitute({
-                e^{
-                  "+"
-                }
-            }[it], list(it = i)), xlab = substitute({
-                e^{
-                  "+"
-                }
-            }[it], list(it = i)), xlim = c(0, 1), ...)
-            if (intlines) 
-                abline(v = quantile(x$ep[, i], c(0.05, 0.5, 0.95)), 
-                  lty = c(3, 2, 3))
-        }
-        else {
-            hist(x$ep[, i], main = substitute({
-                e^{
-                  "+"
-                }
-            }[it], list(it = i)), xlab = substitute({
-                e^{
-                  "+"
-                }
-            }[it], list(it = i)), xlim = c(0, 1), ...)
-            if (intlines) 
-                abline(v = quantile(x$ep[, i], c(0.05, 0.5, 0.95)), 
-                  lty = c(3, 2, 3))
-        }
-    }
-    par(mfrow = c(1, 1))
-    plot.sociomatrix(apply(x$net, c(2, 3), mean), labels = list(x$anames, 
-        x$anames), main = "Marginal Posterior Tie Probability Distribution")
-    par(oldpar)
-}
-
-plot.bbnam.fixed (closure) = function (x, mode = "density", intlines = TRUE, ...) 
-{
-    oldpar <- par()
-    par(mfrow = c(1, 1))
-    plot.sociomatrix(apply(x$net, c(2, 3), mean), labels = list(x$anames, 
-        x$anames), main = "Marginal Posterior Tie Probability Distribution")
-    par(oldpar)
-}
-
-plot.bbnam.pooled (closure) = function (x, mode = "density", intlines = TRUE, ...) 
-{
-    oldpar <- par()
-    par(ask = dev.interactive())
-    par(mfrow = c(2, 1))
-    if (mode == "density") {
-        plot(density(x$em), main = substitute(paste("Estimated Marginal Posterior Density of ", 
-            {
-                e^{
-                  "-"
-                }
-            }, ", ", draws, " Draws"), list(draws = x$draws)), 
-            xlab = expression({
-                e^{
-                  "-"
-                }
-            }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$em, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-        plot(density(x$ep), main = substitute(paste("Estimated Marginal Posterior Density of ", 
-            {
-                e^{
-                  "+"
-                }
-            }, ", ", draws, " Draws"), list(draws = x$draws)), 
-            xlab = expression({
-                e^{
-                  "+"
-                }
-            }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$ep, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-    }
-    else {
-        hist(x$em, main = substitute(paste("Histogram of ", {
-            e^{
-                "-"
-            }
-        }, ", ", draws, " Draws"), list(draws = x$draws)), xlab = expression({
-            e^{
-                "-"
-            }
-        }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$em, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-        hist(x$ep, main = substitute(paste("Histogram of ", {
-            e^{
-                "+"
-            }
-        }, ", ", draws, " Draws"), list(draws = x$draws)), xlab = expression({
-            e^{
-                "+"
-            }
-        }), xlim = c(0, 1), ...)
-        if (intlines) 
-            abline(v = quantile(x$ep, c(0.05, 0.5, 0.95)), lty = c(3, 
-                2, 3))
-    }
-    par(mfrow = c(1, 1))
-    plot.sociomatrix(apply(x$net, c(2, 3), mean), labels = list(x$anames, 
-        x$anames), main = "Marginal Posterior Tie Probability Distribution")
-    par(oldpar)
-}
-
-plot.blockmodel (closure) = function (x, ...) 
-{
-    oldpar <- par(no.readonly = TRUE)
-    on.exit(par(oldpar))
-    n <- dim(x$blocked.data)[2]
-    m <- stackcount(x$blocked.data)
-    if (!is.null(x$plabels)) 
-        plab <- x$plabels
-    else plab <- (1:n)[x$order.vector]
-    if (!is.null(x$glabels)) 
-        glab <- x$glabels
-    else glab <- 1:m
-    par(mfrow = c(floor(sqrt(m)), ceiling(m/floor(sqrt(m)))))
-    if (m > 1) 
-        for (i in 1:m) {
-            plot.sociomatrix(x$blocked.data[i, , ], labels = list(plab, 
-                plab), main = paste("Relation - ", glab[i]), 
-                drawlines = FALSE)
-            for (j in 2:n) if (x$block.membership[j] != x$block.membership[j - 
-                1]) 
-                abline(v = j - 0.5, h = j - 0.5, lty = 3)
-        }
-    else {
-        plot.sociomatrix(x$blocked.data, labels = list(plab, 
-            plab), main = paste("Relation - ", glab[1]), drawlines = FALSE)
-        for (j in 2:n) if (x$block.membership[j] != x$block.membership[j - 
-            1]) 
-            abline(v = j - 0.5, h = j - 0.5, lty = 3)
-    }
-}
-
-plot.bn (closure) = function (x, ...) 
-{
-    op <- par(no.readonly = TRUE)
-    on.exit(par(op))
-    par(mfrow = c(2, 2))
-    dc <- sum(x$dyads)
-    dp <- x$dyads.pred
-    dpm <- x$dyads.pred * dc
-    dpsd <- sqrt(dp * (1 - dp) * dc)
-    dr <- range(c(x$dyads, dpm + 1.96 * dpsd, dpm - 1.96 * dpsd))
-    if (all(x$dyads > 0) && (all(dpm > 0))) 
-        plot(1:3, dpm, axes = FALSE, ylim = dr, main = "Predicted Dyad Census", 
-            xlab = "Dyad Type", ylab = "Count", log = "y", col = 2, 
-            xlim = c(0.5, 3.5))
-    else plot(1:3, dpm, axes = FALSE, ylim = dr, main = "Predicted Dyad Census", 
-        xlab = "Dyad Type", ylab = "Count", col = 2, xlim = c(0.5, 
-            3.5))
-    segments(1:3, dpm - 1.96 * dpsd, 1:3, dpm + 1.96 * dpsd, 
-        col = 2)
-    segments(1:3 - 0.3, dpm - 1.96 * dpsd, 1:3 + 0.3, dpm - 1.96 * 
-        dpsd, col = 2)
-    segments(1:3 - 0.3, dpm + 1.96 * dpsd, 1:3 + 0.3, dpm + 1.96 * 
-        dpsd, col = 2)
-    points(1:3, x$dyads, pch = 19)
-    axis(2)
-    axis(1, at = 1:3, labels = names(x$dyads), las = 3)
-    tc <- sum(x$triads)
-    tp <- x$triads.pred
-    tpm <- x$triads.pred * tc
-    tpsd <- sqrt(tp * (1 - tp) * tc)
-    tr <- range(c(x$triads, tpm + 1.96 * tpsd, tpm - 1.96 * tpsd))
-    if (all(x$triads > 0) && (all(tpm > 0))) 
-        plot(1:16, tpm, axes = FALSE, ylim = tr, main = "Predicted Triad Census", 
-            xlab = "Triad Type", ylab = "Count", log = "y", col = 2)
-    else plot(1:16, tpm, axes = FALSE, ylim = tr, main = "Predicted Triad Census", 
-        xlab = "Triad Type", ylab = "Count", col = 2)
-    segments(1:16, tpm - 1.96 * tpsd, 1:16, tpm + 1.96 * tpsd, 
-        col = 2)
-    segments(1:16 - 0.3, tpm - 1.96 * tpsd, 1:16 + 0.3, tpm - 
-        1.96 * tpsd, col = 2)
-    segments(1:16 - 0.3, tpm + 1.96 * tpsd, 1:16 + 0.3, tpm + 
-        1.96 * tpsd, col = 2)
-    points(1:16, x$triads, pch = 19)
-    axis(2)
-    axis(1, at = 1:16, labels = names(x$triads), las = 3)
-    ssr <- range(c(x$ss, x$ss.pred))
-    plot(0:(length(x$ss) - 1), x$ss, type = "b", xlab = "Distance", 
-        ylab = "Proportion Reached", main = "Predicted Structure Statistics", 
-        ylim = ssr)
-    lines(0:(length(x$ss) - 1), x$ss.pred, col = 2, lty = 2)
-}
-
-plot.cug.test (closure) = function (x, main = "Univariate CUG Test", sub = paste("Conditioning:", 
-    x$cmode, "Reps:", x$reps), ...) 
-{
-    xl <- range(c(x$rep.stat, x$obs.stat))
-    hist(x$rep.stat, xlim = xl, xlab = "CUG Replicates", prob = TRUE, 
-        main = main, sub = sub, ...)
-    abline(v = x$obs.stat, col = 2, lwd = 3)
-}
-
-plot.cugtest (closure) = function (x, mode = "density", ...) 
-{
-    if (mode == "density") {
-        plot(density(x$dist), main = "Estimated Density of CUG Replications", 
-            xlab = "Test Statistic", ...)
-    }
-    else {
-        hist(x$dist, main = "Histogram of CUG Replications", 
-            xlab = "Test Statistic", ...)
-    }
-    abline(v = x$testval, lty = 2)
-}
-
-plot.equiv.clust (closure) = function (x, labels = NULL, ...) 
-{
-    if (is.null(labels)) 
-        plot(x$cluster, labales = x$labels, ...)
-    else plot(x$cluster, labels = labels, ...)
-}
-
-plot.lnam (closure) = function (x, ...) 
-{
-    r <- residuals(x)
-    f <- fitted(x)
-    d <- x$disturbances
-    sdr <- sd(r)
-    ci <- c(-1.959964, 1.959964)
-    old.par <- par(no.readonly = TRUE)
-    on.exit(par(old.par))
-    par(mfrow = c(2, 2))
-    plot(x$y, f, ylab = expression(hat(y)), xlab = expression(y), 
-        main = "Fitted vs. Observed Values")
-    abline(ci[1] * sdr, 1, lty = 3)
-    abline(0, 1, lty = 2)
-    abline(ci[2] * sdr, 1, lty = 3)
-    plot(f, d, ylab = expression(hat(nu)), xlab = expression(hat(y)), 
-        ylim = c(min(ci[1] * x$sigma, d), max(ci[2] * x$sigma, 
-            d)), main = "Fitted Values vs. Estimated Disturbances")
-    abline(h = c(ci[1] * x$sigma, 0, ci[2] * x$sigma), lty = c(3, 
-        2, 3))
-    qqnorm(r, main = "Normal Q-Q Residual Plot")
-    qqline(r)
-    if (!(is.null(x$W1) && is.null(x$W2))) {
-        inf <- matrix(0, ncol = x$df.total, nrow = x$df.total)
-        if (!is.null(x$W1)) 
-            inf <- inf + qr.solve(diag(x$df.total) - apply(sweep(x$W1, 
-                1, x$rho1, "*"), c(2, 3), sum))
-        if (!is.null(x$W2)) 
-            inf <- inf + qr.solve(diag(x$df.total) - apply(sweep(x$W2, 
-                1, x$rho2, "*"), c(2, 3), sum))
-        syminf <- abs(inf) + abs(t(inf))
-        diag(syminf) <- 0
-        infco <- cmdscale(as.dist(max(syminf) - syminf), k = 2)
-        diag(inf) <- NA
-        stdinf <- inf - mean(inf, na.rm = TRUE)
-        infsd <- sd(as.vector(stdinf), na.rm = TRUE)
-        stdinf <- stdinf/infsd
-        gplot(abs(stdinf), thresh = 1.96, coord = infco, main = "Net Influence Plot", 
-            edge.lty = 1, edge.lwd = abs(stdinf)/2, edge.col = 2 + 
-                (inf > 0))
-    }
-    invisible()
-}
-
-plot.qaptest (closure) = function (x, mode = "density", ...) 
-{
-    if (mode == "density") {
-        plot(density(x$dist), main = "Estimated Density of QAP Replications", 
-            xlab = "Test Statistic", ...)
-    }
-    else {
-        hist(x$dist, main = "Histogram of QAP Replications", 
-            xlab = "Test Statistic", ...)
-    }
-    abline(v = x$testval, lty = 2)
-}
-
-plot.sociomatrix (closure) = function (x, labels = NULL, drawlab = TRUE, diaglab = TRUE, drawlines = TRUE, 
-    xlab = NULL, ylab = NULL, cex.lab = 1, font.lab = 1, col.lab = 1, 
-    scale.values = TRUE, cell.col = gray, ...) 
-{
-    if ((!inherits(x, c("matrix", "array", "data.frame"))) || 
-        (length(dim(x)) > 2)) 
-        x <- as.sociomatrix.sna(x)
-    if (is.list(x)) 
-        x <- x[[1]]
-    n <- dim(x)[1]
-    o <- dim(x)[2]
-    if (is.null(labels)) 
-        labels <- list(NULL, NULL)
-    if (is.null(labels[[1]])) {
-        if (is.null(rownames(x))) 
-            labels[[1]] <- 1:dim(x)[1]
-        else labels[[1]] <- rownames(x)
-    }
-    if (is.null(labels[[2]])) {
-        if (is.null(colnames(x))) 
-            labels[[2]] <- 1:dim(x)[2]
-        else labels[[2]] <- colnames(x)
-    }
-    if (scale.values) 
-        d <- 1 - (x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - 
-            min(x, na.rm = TRUE))
-    else d <- x
-    if (is.null(xlab)) 
-        xlab <- ""
-    if (is.null(ylab)) 
-        ylab <- ""
-    plot(1, 1, xlim = c(0, o + 1), ylim = c(n + 1, 0), type = "n", 
-        axes = FALSE, xlab = xlab, ylab = ylab, ...)
-    for (i in 1:n) for (j in 1:o) rect(j - 0.5, i + 0.5, j + 
-        0.5, i - 0.5, col = cell.col(d[i, j]), xpd = TRUE, border = drawlines)
-    rect(0.5, 0.5, o + 0.5, n + 0.5, col = NA, xpd = TRUE)
-    if (drawlab) {
-        text(rep(0, n), 1:n, labels[[1]], cex = cex.lab, font = font.lab, 
-            col = col.lab)
-        text(1:o, rep(0, o), labels[[2]], cex = cex.lab, font = font.lab, 
-            col = col.lab)
-    }
-    if ((n == o) & (drawlab) & (diaglab)) 
-        if (all(labels[[1]] == labels[[2]])) 
-            text(1:o, 1:n, labels[[1]], cex = cex.lab, font = font.lab, 
-                col = col.lab)
-}
-
-potscalered.mcmc (closure) = function (psi) 
-{
-    J <- dim(psi)[2]
-    n <- dim(psi)[1]
-    mpsij <- apply(psi, 2, mean)
-    mpsitot <- mean(mpsij)
-    B <- (n/(J - 1)) * sum((mpsij - mpsitot)^2)
-    s2j <- apply(psi, 2, var)
-    W <- mean(s2j)
-    varppsi <- ((n - 1)/n) * W + (1/n) * B
-    sqrt(varppsi/W)
-}
-
-prestige (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    cmode = "indegree", tmaxdev = FALSE, rescale = FALSE, tol = 1e-07) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], prestige, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, cmode = cmode, tmaxdev = tmaxdev, 
-            rescale = rescale, tol = tol))
-    n <- attr(dat, "n")
-    if (tmaxdev) {
-        h <- matrix(nrow = 0, ncol = 3)
-        attr(h, "n") <- n
-        if (cmode == "indegree") 
-            p <- degree(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag, cmode = "indegree", rescale = FALSE)
-        else if (cmode == "indegree.rownorm") 
-            p <- degree(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag, cmode = "indegree", rescale = FALSE)
-        else if (cmode == "indegree.rowcolnorm") 
-            p <- degree(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag, cmode = "indegree", rescale = FALSE)
-        else if (cmode == "eigenvector") 
-            p <- evcent(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag)
-        else if (cmode == "eigenvector.rownorm") 
-            p <- evcent(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag)
-        else if (cmode == "eigenvector.colnorm") 
-            p <- evcent(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag)
-        else if (cmode == "eigenvector.rowcolnorm") 
-            p <- evcent(dat = h, g = 1, tmaxdev = TRUE, gmode = gmode, 
-                diag = diag)
-        else if (cmode == "domain") {
-            p <- (n - 1)^2
-        }
-        else if (cmode == "domain.proximity") {
-            p <- (n - 1)^2
-        }
-        else stop(paste("Cmode", cmode, "unknown.\n"))
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode %in% c("eigenvector")) {
-            td <- dat
-            if (!diag) {
-                td <- td[td[, 1] != td[, 2], c(2, 1, 3), drop = FALSE]
-                attr(td, "n") <- attr(dat, "n")
-            }
-        }
-        else if (cmode %in% c("indegree.rownorm", "indegree.colnorm", 
-            "indegree.rowcolnorm", "eigenvector.rownorm", "eigenvector.colnorm", 
-            "eigenvector.rowcolnorm", "domain", "domain.proximity")) {
-            d <- dat
-            if (!diag) {
-                d <- d[d[, 1] != d[, 2], , drop = FALSE]
-                attr(d, "n") <- attr(dat, "n")
-            }
-        }
-        if (cmode == "indegree") 
-            p <- degree(dat = dat, g = g, gmode = gmode, diag = diag, 
-                cmode = "indegree", rescale = FALSE)
-        else if (cmode == "indegree.rownorm") 
-            p <- degree(dat = make.stochastic(d, mode = "row"), 
-                g = 1, gmode = gmode, diag = diag, cmode = "indegree", 
-                rescale = FALSE)
-        else if (cmode == "indegree.rowcolnorm") 
-            p <- degree(dat = make.stochastic(d, mode = "rowcol"), 
-                g = 1, gmode = gmode, diag = diag, cmode = "indegree", 
-                rescale = FALSE)
-        else if (cmode == "eigenvector") 
-            p <- evcent(td)
-        else if (cmode == "eigenvector.rownorm") 
-            p <- eigen(t(make.stochastic(d, mode = "row")))$vector[, 
-                1]
-        else if (cmode == "eigenvector.colnorm") 
-            p <- eigen(t(make.stochastic(d, mode = "col")))$vector[, 
-                1]
-        else if (cmode == "eigenvector.rowcolnorm") 
-            p <- eigen(t(make.stochastic(d, mode = "rowcol")))$vector[, 
-                1]
-        else if (cmode == "domain") {
-            r <- reachability(d)
-            p <- apply(r, 2, sum) - 1
-        }
-        else if (cmode == "domain.proximity") {
-            g <- geodist(d)
-            p <- (apply(g$counts > 0, 2, sum) - 1)^2/(apply((g$counts > 
-                0) * (g$gdist), 2, sum) * (n - 1))
-            p[is.nan(p)] <- 0
-        }
-        else stop(paste("Cmode", cmode, "unknown.\n"))
-        if (rescale) 
-            p <- p/sum(p)
-        p <- p[nodes]
-    }
-    p
-}
-
-print.bayes.factor (closure) = function (x, ...) 
-{
-    tab <- x$int.lik
-    rownames(tab) <- x$model.names
-    colnames(tab) <- x$model.names
-    cat("Log Bayes Factors by Model:\n\n(Diagonals indicate raw integrated log likelihood estimates.)\n\n")
-    print(tab)
-    cat("\n")
-}
-
-print.bbnam (closure) = function (x, ...) 
-{
-    UseMethod("print", x)
-}
-
-print.bbnam.actor (closure) = function (x, ...) 
-{
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Multiple Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
-    cat("Marginal Posterior Global Error Distribution:\n\n")
-    d <- matrix(ncol = 2, nrow = 6)
-    d[1:3, 1] <- quantile(x$em, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 1] <- mean(x$em, na.rm = TRUE)
-    d[5:6, 1] <- quantile(x$em, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    d[1:3, 2] <- quantile(x$ep, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 2] <- mean(x$ep, na.rm = TRUE)
-    d[5:6, 2] <- quantile(x$ep, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    colnames(d) <- c("e^-", "e^+")
-    rownames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
+    if (!toreport) 
+        par(mypar)
 }
 
-print.bbnam.fixed (closure) = function (x, ...) 
+dat (closure) = function (input, type = c("biodetection", "cd", "countsbio", 
+    "GCbias", "lengthbias", "saturation", "PCA"), k = 0, ndepth = 6, 
+    factor = NULL, norm = FALSE, refColumn = 1, logtransf = FALSE) 
 {
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Fixed Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
+    type <- match.arg(type)
+    if (type == "biodetection") {
+        output = new("Biodetection", dat = biodetection.dat(input, 
+            factor = factor, k = k))
+    }
+    if (type == "cd") {
+        output = new("CD", dat = cd.dat(input, norm = norm, refColumn = refColumn))
+    }
+    if (type == "countsbio") {
+        output = new("CountsBio", dat = countsbio.dat(input, 
+            factor = factor, norm = norm))
+    }
+    if (type == "GCbias") {
+        output = new("GCbias", dat = GC.dat(input, factor = factor, 
+            norm = norm))
+    }
+    if (type == "lengthbias") {
+        output = new("lengthbias", dat = length.dat(input, factor = factor, 
+            norm = norm))
+    }
+    if (type == "saturation") {
+        output = new("Saturation", dat = saturation.dat(input, 
+            k = k, ndepth = ndepth))
+    }
+    if (type == "PCA") {
+        output = new("PCA", dat = PCA.dat(input, norm = norm, 
+            logtransf = logtransf))
+    }
+    output
 }
 
-print.bbnam.pooled (closure) = function (x, ...) 
-{
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Pooled Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
-    cat("Marginal Posterior Global Error Distribution:\n\n")
-    d <- matrix(ncol = 2, nrow = 6)
-    d[1:3, 1] <- quantile(x$em, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 1] <- mean(x$em, na.rm = TRUE)
-    d[5:6, 1] <- quantile(x$em, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    d[1:3, 2] <- quantile(x$ep, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 2] <- mean(x$ep, na.rm = TRUE)
-    d[5:6, 2] <- quantile(x$ep, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    colnames(d) <- c("e^-", "e^+")
-    rownames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
-}
+dat2save (closure) = new("standardGeneric", .Data = function (object) 
+standardGeneric("dat2save"), generic = structure("dat2save", package = "NOISeq"), 
+    package = "NOISeq", group = list(), valueClass = character(0), 
+    signature = "object", default = NULL, skeleton = (function (object) 
+    stop("invalid call in method dispatch to 'dat2save' (no default method)", 
+        domain = NA))(object))
 
-print.blockmodel (closure) = function (x, ...) 
+data2report (closure) = function (input, factor = NULL, norm = FALSE) 
 {
-    cat("\nNetwork Blockmodel:\n\n")
-    cat("Block membership:\n\n")
-    if (is.null(x$plabels)) 
-        plab <- (1:length(x$block.membership))[x$order.vector]
-    else plab <- x$plabels
-    temp <- matrix(x$block.membership, nrow = 1)
-    dimnames(temp) <- list("", plab)
-    print(temp[1, order(x$order.vector)])
-    cat("\nReduced form blockmodel:\n\n")
-    if (length(dim(x$block.model)) > 2) {
-        for (i in 1:dim(x$block.model)[1]) {
-            temp <- x$block.model[i, , ]
-            dimnames(temp) <- list(x$rlabels, x$rlabels)
-            cat("\t", x$glabels[i], "\n")
-            print(temp)
-            cat("\n")
-        }
+    if (!is.null(featureData(input)$Biotype)) {
+        mybiotdet = biodetection.dat(input, factor = factor, 
+            k = 0)
+        biot.avail = TRUE
+        mycountsbio1 = countsbio.dat(input, factor = factor, 
+            norm = norm)
     }
     else {
-        temp <- x$block.model
-        dimnames(temp) <- list(x$rlabels, x$rlabels)
-        cat("\t", x$glabels, "\n")
-        print(temp)
+        mybiotdet = NULL
+        mycountsbio1 = NULL
+        biot.avail = FALSE
     }
-}
-
-print.bn (closure) = function (x, digits = max(4, getOption("digits") - 3), ...) 
-{
-    cat("\nBiased Net Model\n\n")
-    cat("Parameters:\n\n")
-    cmat <- matrix(c(x$d, x$pi, x$sigma, x$rho), ncol = 1)
-    colnames(cmat) <- "Estimate"
-    rownames(cmat) <- c("d", "pi", "sigma", "rho")
-    printCoefmat(cmat, digits = digits, ...)
-    cat("\n")
-}
-
-print.cug.test (closure) = function (x, ...) 
-{
-    cat("\nUnivariate Conditional Uniform Graph Test\n\n")
-    cat("Conditioning Method:", x$cmode, "\nGraph Type:", x$mode, 
-        "\nDiagonal Used:", x$diag, "\nReplications:", x$reps, 
-        "\n\n")
-    cat("Observed Value:", x$obs.stat, "\n")
-    cat("Pr(X>=Obs):", x$pgteobs, "\n")
-    cat("Pr(X<=Obs):", x$plteobs, "\n\n")
-}
-
-print.cugtest (closure) = function (x, ...) 
-{
-    cat("\nCUG Test Results\n\n")
-    cat("Estimated p-values:\n")
-    cat("\tp(f(rnd) >= f(d)):", x$pgreq, "\n")
-    cat("\tp(f(rnd) <= f(d)):", x$pleeq, "\n\n")
-}
-
-print.equiv.clust (closure) = function (x, ...) 
-{
-    cat("Position Clustering:\n\n")
-    cat("\tEquivalence function:", x$equiv.fun, "\n")
-    cat("\tEquivalence metric:", x$metric, "\n")
-    cat("\tCluster method:", x$cluster.method, "\n")
-    cat("\tGraph order:", length(x$cluster$order), "\n\n")
-}
-
-print.lnam (closure) = function (x, digits = max(3, getOption("digits") - 3), ...) 
-{
-    cat("\nCall:\n", deparse(x$call), "\n\n", sep = "")
-    cat("Coefficients:\n")
-    print.default(format(coef(x), digits = digits), print.gap = 2, 
-        quote = FALSE)
-    cat("\n")
-}
-
-print.netcancor (closure) = function (x, ...) 
-{
-    cat("\nCanonical Network Correlation\n\n")
-    cat("Canonical Correlations:\n\n")
-    cmat <- matrix(data = x$cor, ncol = length(x$cor), nrow = 1)
-    rownames(cmat) <- ""
-    colnames(cmat) <- as.vector(x$cnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=cor):\n\n")
-    cmat <- matrix(data = format(x$cpgreq), ncol = length(x$cpgreq), 
-        nrow = 1)
-    colnames(cmat) <- as.vector(x$cnames)
-    rownames(cmat) <- ""
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=cor):\n\n")
-    cmat <- matrix(data = format(x$cpleeq), ncol = length(x$cpleeq), 
-        nrow = 1)
-    colnames(cmat) <- as.vector(x$cnames)
-    rownames(cmat) <- ""
-    print.table(cmat)
-    cat("\n")
-    cat("X Coefficients:\n\n")
-    cmat <- format(x$xcoef)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=xcoef):\n\n")
-    cmat <- format(x$xpgreq)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=xcoef):\n\n")
-    cmat <- format(x$xpleeq)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Y Coefficients:\n\n")
-    cmat <- format(x$ycoef)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=ycoef):\n\n")
-    cmat <- format(x$ypgreq)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=ycoef):\n\n")
-    cmat <- format(x$ypleeq)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-}
-
-print.netlm (closure) = function (x, ...) 
-{
-    cat("\nOLS Network Model\n\n")
-    cat("Coefficients:\n")
-    cmat <- as.vector(format(as.numeric(x$coefficients)))
-    cmat <- cbind(cmat, as.vector(format(x$pleeq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreqabs)))
-    colnames(cmat) <- c("Estimate", "Pr(<=b)", "Pr(>=b)", "Pr(>=|b|)")
-    rownames(cmat) <- as.vector(x$names)
-    print.table(cmat)
-    mss <- if (x$intercept) 
-        sum((fitted(x) - mean(fitted(x)))^2)
-    else sum(fitted(x)^2)
-    rss <- sum(resid(x)^2)
-    qn <- NROW(x$qr$qr)
-    df.int <- x$intercept
-    rdf <- qn - x$rank
-    resvar <- rss/rdf
-    fstatistic <- c(value = (mss/(x$rank - df.int))/resvar, numdf = x$rank - 
-        df.int, dendf = rdf)
-    r.squared <- mss/(mss + rss)
-    adj.r.squared <- 1 - (1 - r.squared) * ((qn - df.int)/rdf)
-    sigma <- sqrt(resvar)
-    cat("\nResidual standard error:", format(sigma, digits = 4), 
-        "on", rdf, "degrees of freedom\n")
-    cat("F-statistic:", formatC(fstatistic[1], digits = 4), "on", 
-        fstatistic[2], "and", fstatistic[3], "degrees of freedom, p-value:", 
-        formatC(1 - pf(fstatistic[1], fstatistic[2], fstatistic[3]), 
-            digits = 4), "\n")
-    cat("Multiple R-squared:", format(r.squared, digits = 4), 
-        "\t")
-    cat("Adjusted R-squared:", format(adj.r.squared, digits = 4), 
-        "\n")
-    cat("\n")
-}
-
-print.netlogit (closure) = function (x, ...) 
-{
-    cat("\nNetwork Logit Model\n\n")
-    cat("Coefficients:\n")
-    cmat <- as.vector(format(as.numeric(x$coefficients)))
-    cmat <- cbind(cmat, as.vector(format(exp(as.numeric(x$coefficients)))))
-    cmat <- cbind(cmat, as.vector(format(x$pleeq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreqabs)))
-    colnames(cmat) <- c("Estimate", "Exp(b)", "Pr(<=b)", "Pr(>=b)", 
-        "Pr(>=|b|)")
-    rownames(cmat) <- as.vector(x$names)
-    print.table(cmat)
-    cat("\nGoodness of Fit Statistics:\n")
-    cat("\nNull deviance:", x$null.deviance, "on", x$df.null, 
-        "degrees of freedom\n")
-    cat("Residual deviance:", x$deviance, "on", x$df.residual, 
-        "degrees of freedom\n")
-    cat("Chi-Squared test of fit improvement:\n\t", x$null.deviance - 
-        x$deviance, "on", x$df.null - x$df.residual, "degrees of freedom, p-value", 
-        1 - pchisq(x$null.deviance - x$deviance, df = x$df.null - 
-            x$df.residual), "\n")
-    cat("AIC:", x$aic, "\tBIC:", x$bic, "\nPseudo-R^2 Measures:\n\t(Dn-Dr)/(Dn-Dr+dfn):", 
-        (x$null.deviance - x$deviance)/(x$null.deviance - x$deviance + 
-            x$df.null), "\n\t(Dn-Dr)/Dn:", 1 - x$deviance/x$null.deviance, 
-        "\n")
-    cat("\n")
-}
-
-print.qaptest (closure) = function (x, ...) 
-{
-    cat("\nQAP Test Results\n\n")
-    cat("Estimated p-values:\n")
-    cat("\tp(f(perm) >= f(d)):", x$pgreq, "\n")
-    cat("\tp(f(perm) <= f(d)):", x$pleeq, "\n\n")
-}
-
-print.summary.bayes.factor (closure) = function (x, ...) 
-{
-    cat("Log Bayes Factors by Model:\n\n(Diagonals indicate raw integrated log likelihood estimates.)\n\n")
-    print(x$int.lik)
-    stdtab <- matrix(x$int.lik.std, nrow = 1)
-    colnames(stdtab) <- x$model.names
-    cat("\n\nLog Inverse Bayes Factors:\n\n(Diagonals indicate log posterior probability of model under within-set choice constraints and uniform model priors.\n\n")
-    print(x$inv.bf)
-    cat("\nEstimated model probabilities (within-set):\n")
-    temp <- exp(diag(x$inv.bf))
-    names(temp) <- x$model.names
-    print(temp)
-    cat("\n\nDiagnostics:\n\nReplications - ", x$reps, "\n\nLog std deviations of integrated likelihood estimates:\n")
-    names(x$int.lik.std) <- x$model.names
-    print(x$int.lik.std)
-    cat("\n\nVector of hyperprior parameters:\n\n")
-    priortab <- matrix(x$prior.param, nrow = 1, ncol = length(x$prior.param))
-    colnames(priortab) <- x$prior.param.names
-    print(priortab)
-    cat("\n\n")
-}
-
-print.summary.bbnam (closure) = function (x, ...) 
-{
-    UseMethod("print", x)
-}
-
-print.summary.bbnam.actor (closure) = function (x, ...) 
-{
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Multiple Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
-    cat("Marginal Posterior Global Error Distribution:\n\n")
-    d <- matrix(ncol = 2, nrow = 6)
-    d[1:3, 1] <- quantile(x$em, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 1] <- mean(x$em, na.rm = TRUE)
-    d[5:6, 1] <- quantile(x$em, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    d[1:3, 2] <- quantile(x$ep, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 2] <- mean(x$ep, na.rm = TRUE)
-    d[5:6, 2] <- quantile(x$ep, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    colnames(d) <- c("e^-", "e^+")
-    rownames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
-    cat("Marginal Posterior Error Distribution (by observer):\n\n")
-    cat("Probability of False Negatives (e^-):\n\n")
-    d <- matrix(ncol = 6)
-    for (i in 1:x$nobservers) {
-        dv <- matrix(c(quantile(x$em[, i], c(0, 0.25, 0.5), names = FALSE, 
-            na.rm = TRUE), mean(x$em[, i], na.rm = TRUE), quantile(x$em[, 
-            i], c(0.75, 1), names = FALSE, na.rm = TRUE)), nrow = 1, 
-            ncol = 6)
-        d <- rbind(d, dv)
-    }
-    d <- d[2:(x$nobservers + 1), ]
-    rownames(d) <- as.vector(x$onames)
-    colnames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
-    cat("Probability of False Positives (e^+):\n\n")
-    d <- matrix(ncol = 6)
-    for (i in 1:x$nobservers) {
-        dv <- matrix(c(quantile(x$ep[, i], c(0, 0.25, 0.5), names = FALSE, 
-            na.rm = TRUE), mean(x$ep[, i], na.rm = TRUE), quantile(x$ep[, 
-            i], c(0.75, 1), names = FALSE, na.rm = TRUE)), nrow = 1, 
-            ncol = 6)
-        d <- rbind(d, dv)
-    }
-    d <- d[2:(x$nobservers + 1), ]
-    rownames(d) <- as.vector(x$onames)
-    colnames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
-    cat("MCMC Diagnostics:\n\n")
-    cat("\tReplicate Chains:", x$reps, "\n")
-    cat("\tBurn Time:", x$burntime, "\n")
-    cat("\tDraws per Chain:", x$draws/x$reps, "Total Draws:", 
-        x$draws, "\n")
-    if ("sqrtrhat" %in% names(x)) 
-        cat("\tPotential Scale Reduction (G&R's sqrt(Rhat)):\n \t\tMax:", 
-            max(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n\t\tMed:", 
-            median(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n\t\tIQR:", 
-            IQR(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n")
-    cat("\n")
-}
-
-print.summary.bbnam.fixed (closure) = function (x, ...) 
-{
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Fixed Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
-    cat("Model Diagnostics:\n\n")
-    cat("\tTotal Draws:", x$draws, "\n\t(Note: Draws taken directly from network posterior.)")
-    cat("\n")
-}
-
-print.summary.bbnam.pooled (closure) = function (x, ...) 
-{
-    cat("\nButts' Hierarchical Bayes Model for Network Estimation/Informant Accuracy\n\n")
-    cat("Pooled Error Probability Model\n\n")
-    cat("Marginal Posterior Network Distribution:\n\n")
-    d <- apply(x$net, c(2, 3), mean)
-    rownames(d) <- as.vector(x$anames)
-    colnames(d) <- as.vector(x$anames)
-    print.table(d, digits = 2)
-    cat("\n")
-    cat("Marginal Posterior Error Distribution:\n\n")
-    d <- matrix(ncol = 2, nrow = 6)
-    d[1:3, 1] <- quantile(x$em, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 1] <- mean(x$em, na.rm = TRUE)
-    d[5:6, 1] <- quantile(x$em, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    d[1:3, 2] <- quantile(x$ep, c(0, 0.25, 0.5), names = FALSE, 
-        na.rm = TRUE)
-    d[4, 2] <- mean(x$ep, na.rm = TRUE)
-    d[5:6, 2] <- quantile(x$ep, c(0.75, 1), names = FALSE, na.rm = TRUE)
-    colnames(d) <- c("e^-", "e^+")
-    rownames(d) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(d, digits = 4)
-    cat("\n")
-    cat("MCMC Diagnostics:\n\n")
-    cat("\tReplicate Chains:", x$reps, "\n")
-    cat("\tBurn Time:", x$burntime, "\n")
-    cat("\tDraws per Chain:", x$draws/x$reps, "Total Draws:", 
-        x$draws, "\n")
-    if ("sqrtrhat" %in% names(x)) 
-        cat("\tPotential Scale Reduction (G&R's sqrt(Rhat)):\n \t\tMax:", 
-            max(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n\t\tMed:", 
-            median(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n\t\tIQR:", 
-            IQR(x$sqrtrhat[!is.nan(x$sqrtrhat)]), "\n")
-    cat("\n")
-}
-
-print.summary.blockmodel (closure) = function (x, ...) 
-{
-    cat("\nNetwork Blockmodel:\n\n")
-    cat("\nGeneral information:\n\n")
-    cat("\tEquivalence function: ", x$equiv.fun, "\n")
-    cat("\tEquivalence metric: ", x$equiv.metric, "\n")
-    cat("\tClustering method: ", x$cluster.method, "\n")
-    cat("\tBlockmodel content: ", x$block.content, "\n")
-    cat("\n\nBlock membership by actor:\n\n")
-    if (is.null(x$plabels)) 
-        plab <- (1:length(x$block.membership))[x$order.vector]
-    else plab <- x$plabels
-    temp <- matrix(x$block.membership, nrow = 1)
-    dimnames(temp) <- list("", plab)
-    print(temp[1, order(x$order.vector)])
-    cat("\n\nBlock membership by block:\n\n")
-    for (i in 1:max(x$block.membership)) cat("\t", x$rlabels[i], 
-        ":", plab[x$block.membership == i], "\n")
-    cat("\n\nReduced form blockmodel:\n\n")
-    if (length(dim(x$block.model)) > 2) {
-        for (i in 1:dim(x$block.model)[1]) {
-            temp <- x$block.model[i, , ]
-            dimnames(temp) <- list(x$rlabels, x$rlabels)
-            cat("\t", x$glabels[i], "\n")
-            print(temp)
-            cat("\n")
-        }
+    mysat = saturation.dat(input, k = 0, ndepth = 6)
+    mycountsbio2 = countsbio.dat(input, factor = factor, norm = norm)
+    if (!is.null(featureData(input)$Length)) {
+        mylength = length.dat(input, factor = factor, norm = norm)
+        length.avail = TRUE
     }
     else {
-        temp <- x$block.model
-        dimnames(temp) <- list(x$rlabels, x$rlabels)
-        cat("\t", x$glabels, "\n")
-        print(temp)
-    }
-    cat("\n\nBlocked data:\n\n")
-    if (length(dim(x$block.model)) > 2) {
-        for (i in 1:dim(x$block.model)[1]) {
-            temp <- x$blocked.data[i, , ]
-            dimnames(temp) <- list(plab, plab)
-            cat("\t", x$glabels[i], "\n")
-            print(temp)
-            cat("\n")
-        }
+        mylength = NULL
+        length.avail = FALSE
+    }
+    if (!is.null(featureData(input)$GC)) {
+        myGC = GC.dat(input, factor = factor, norm = norm)
+        GC.avail = TRUE
     }
     else {
-        temp <- x$blocked.data
-        dimnames(temp) <- list(plab, plab)
-        cat("\t", x$glabels, "\n")
-        print(temp)
+        myGC = NULL
+        GC.avail = FALSE
     }
+    myCD = cd.dat(input, norm = norm, refColumn = 1)
+    myPCA = PCA.dat(input, norm = norm, logtransf = FALSE)
+    list(data = list(biodet = mybiotdet, countsbiot = mycountsbio1, 
+        saturation = mysat, countsampl = mycountsbio2, length = mylength, 
+        GC = myGC, countdist = myCD, PCA = myPCA), parameters = list(biotypes = biot.avail, 
+        length = length.avail, GC = GC.avail))
 }
 
-print.summary.bn (closure) = function (x, digits = max(4, getOption("digits") - 3), signif.stars = getOption("show.signif.stars"), 
-    ...) 
+degenes (closure) = function (object, q = 0.95, M = NULL) 
 {
-    cat("\nBiased Net Model\n\n")
-    cat("\nParameters:\n\n")
-    cmat <- matrix(c(x$d, x$pi, x$sigma, x$rho), ncol = 1)
-    colnames(cmat) <- "Estimate"
-    rownames(cmat) <- c("d", "pi", "sigma", "rho")
-    printCoefmat(cmat, digits = digits, ...)
-    cat("\nDiagnostics:\n\n")
-    cat("\tFit method:", x$method, "\n")
-    cat("\tPseudolikelihood G^2:", x$G.square, "\n")
-    cat("\n\tEdge census comparison:\n\n")
-    ec <- sum(x$edges)
-    cmat <- cbind(x$edges, x$edges.pred * ec)
-    cmat <- cbind(cmat, (cmat[, 1] - cmat[, 2])/sqrt(x$edges.pred * 
-        (1 - x$edges.pred) * ec))
-    cmat <- cbind(cmat, 2 * (1 - pnorm(abs(cmat[, 3]))))
-    colnames(cmat) <- c("Observed", "Predicted", "Z Value", "Pr(>|z|)")
-    printCoefmat(cmat, digits = digits, signif.stars = signif.stars, 
-        ...)
-    chisq <- sum((cmat[, 1] - cmat[, 2])^2/cmat[, 2])
-    cat("\tChi-Square:", chisq, "on 1 degrees of freedom.  p-value:", 
-        1 - pchisq(chisq, 1), "\n\n")
-    cat("\n\tDyad census comparison:\n\n")
-    dc <- sum(x$dyads)
-    cmat <- cbind(x$dyads, x$dyads.pred * dc)
-    cmat <- cbind(cmat, (cmat[, 1] - cmat[, 2])/sqrt(x$dyads.pred * 
-        (1 - x$dyads.pred) * dc))
-    cmat <- cbind(cmat, 2 * (1 - pnorm(abs(cmat[, 3]))))
-    colnames(cmat) <- c("Observed", "Predicted", "Z Value", "Pr(>|z|)")
-    printCoefmat(cmat, digits = digits, signif.stars = signif.stars, 
-        ...)
-    chisq <- sum((cmat[, 1] - cmat[, 2])^2/cmat[, 2])
-    cat("\tChi-Square:", chisq, "on 2 degrees of freedom.  p-value:", 
-        1 - pchisq(chisq, 2), "\n\n")
-    cat("\n\tTriad census comparison:\n\n")
-    tc <- sum(x$triads)
-    cmat <- cbind(x$triads, x$triads.pred * tc)
-    cmat <- cbind(cmat, (cmat[, 1] - cmat[, 2])/sqrt(x$triads.pred * 
-        (1 - x$triads.pred) * tc))
-    cmat <- cbind(cmat, 2 * (1 - pnorm(abs(cmat[, 3]))))
-    colnames(cmat) <- c("Observed", "Predicted", "Z Value", "Pr(>|z|)")
-    printCoefmat(cmat, digits = digits, signif.stars = signif.stars, 
-        ...)
-    chisq <- sum((cmat[, 1] - cmat[, 2])^2/cmat[, 2])
-    cat("\tChi-Square:", chisq, "on 15 degrees of freedom.  p-value:", 
-        1 - pchisq(chisq, 15), "\n\n")
-}
-
-print.summary.brokerage (closure) = function (x, ...) 
-{
-    cat("Gould-Fernandez Brokerage Analysis\n\n")
-    cat("Global Brokerage Properties\n")
-    cmat <- cbind(x$raw.gli, x$exp.gli, x$sd.gli, x$z.gli, 2 * 
-        (1 - pnorm(abs(x$z.gli))))
-    rownames(cmat) <- names(x$raw.gli)
-    colnames(cmat) <- c("t", "E(t)", "Sd(t)", "z", "Pr(>|z|)")
-    printCoefmat(cmat)
-    cat("\nIndividual Properties (by Group)\n")
-    for (i in x$clid) {
-        cat("\n\tGroup ID:", i, "\n")
-        temp <- x$cl == i
-        cmat <- cbind(x$raw.nli, x$z.nli)[temp, , drop = FALSE]
-        print(cmat)
+    if (class(object) != "Output") 
+        stop("You must give the object returned by the noiseq function\n")
+    x <- object@results[[1]]
+    noiseqbio = "theta" %in% colnames(x)[1:4]
+    if (noiseqbio) {
+        y <- na.omit(x[c("theta", "prob")])
+        colnames(y)[1] = "M"
     }
-    cat("\n")
-}
-
-print.summary.cugtest (closure) = function (x, ...) 
-{
-    cat("\nCUG Test Results\n\n")
-    cat("Estimated p-values:\n")
-    cat("\tp(f(rnd) >= f(d)):", x$pgreq, "\n")
-    cat("\tp(f(rnd) <= f(d)):", x$pleeq, "\n")
-    cat("\nTest Diagnostics:\n")
-    cat("\tTest Value (f(d)):", x$testval, "\n")
-    cat("\tReplications:", length(x$dist), "\n")
-    cat("\tDistribution Summary:\n")
-    cat("\t\tMin:\t", quantile(x$dist, probs = 0, names = FALSE), 
-        "\n")
-    cat("\t\t1stQ:\t", quantile(x$dist, probs = 0.25, names = FALSE), 
-        "\n")
-    cat("\t\tMed:\t", quantile(x$dist, probs = 0.5, names = FALSE), 
-        "\n")
-    cat("\t\tMean:\t", mean(x$dist), "\n")
-    cat("\t\t3rdQ:\t", quantile(x$dist, probs = 0.75, names = FALSE), 
-        "\n")
-    cat("\t\tMax:\t", quantile(x$dist, probs = 1, names = FALSE), 
-        "\n")
-    cat("\n")
-}
-
-print.summary.lnam (closure) = function (x, digits = max(3, getOption("digits") - 3), signif.stars = getOption("show.signif.stars"), 
-    ...) 
-{
-    cat("\nCall:\n")
-    cat(paste(deparse(x$call), sep = "\n", collapse = "\n"), 
-        "\n\n", sep = "")
-    cat("Residuals:\n")
-    nam <- c("Min", "1Q", "Median", "3Q", "Max")
-    resid <- x$residuals
-    rq <- if (length(dim(resid)) == 2) 
-        structure(apply(t(resid), 1, quantile), dimnames = list(nam, 
-            dimnames(resid)[[2]]))
-    else structure(quantile(resid), names = nam)
-    print(rq, digits = digits, ...)
-    cat("\nCoefficients:\n")
-    cmat <- cbind(coef(x), se.lnam(x))
-    cmat <- cbind(cmat, cmat[, 1]/cmat[, 2], (1 - pnorm(abs(cmat[, 
-        1]), 0, cmat[, 2])) * 2)
-    colnames(cmat) <- c("Estimate", "Std. Error", "Z value", 
-        "Pr(>|z|)")
-    printCoefmat(cmat, digits = digits, signif.stars = signif.stars, 
-        ...)
-    cat("\n")
-    cmat <- cbind(x$sigma, x$sigma.se)
-    colnames(cmat) <- c("Estimate", "Std. Error")
-    rownames(cmat) <- "Sigma"
-    printCoefmat(cmat, digits = digits, signif.stars = signif.stars, 
-        ...)
-    cat("\nGoodness-of-Fit:\n")
-    rss <- sum(x$residuals^2)
-    mss <- sum((x$fitted - mean(x$fitted))^2)
-    rdfns <- x$df.residual + 1
-    cat("\tResidual standard error: ", format(sqrt(rss/rdfns), 
-        digits = digits), " on ", rdfns, " degrees of freedom (w/o Sigma)\n", 
-        sep = "")
-    cat("\tMultiple R-Squared: ", format(mss/(mss + rss), digits = digits), 
-        ", Adjusted R-Squared: ", format(1 - (1 - mss/(mss + 
-            rss)) * x$df.total/rdfns, digits = digits), "\n", 
-        sep = "")
-    cat("\tModel log likelihood:", format(x$lnlik.model, digits = digits), 
-        "on", x$df.resid, "degrees of freedom (w/Sigma)\n\tAIC:", 
-        format(-2 * x$lnlik.model + 2 * x$df.model, digits = digits), 
-        "BIC:", format(-2 * x$lnlik.model + log(x$df.total) * 
-            x$df.model, digits = digits), "\n")
-    cat("\n\tNull model:", x$null.model, "\n")
-    cat("\tNull log likelihood:", format(x$lnlik.null, digits = digits), 
-        "on", x$df.null.resid, "degrees of freedom\n\tAIC:", 
-        format(-2 * x$lnlik.null + 2 * x$df.null, digits = digits), 
-        "BIC:", format(-2 * x$lnlik.null + log(x$df.total) * 
-            x$df.null, digits = digits), "\n")
-    cat("\tAIC difference (model versus null):", format(-2 * 
-        x$lnlik.null + 2 * x$df.null + 2 * x$lnlik.model - 2 * 
-        x$df.model, digits = digits), "\n")
-    cat("\tHeuristic Log Bayes Factor (model versus null): ", 
-        format(-2 * x$lnlik.null + log(x$df.total) * x$df.null + 
-            2 * x$lnlik.model - log(x$df.total) * x$df.model, 
-            digits = digits), "\n")
-    cat("\n")
+    else {
+        y <- na.omit(x[c("M", "D", "prob")])
+    }
+    if (is.null(M)) {
+        losdeg <- y[y[, "prob"] > q, ]
+        print(paste(dim(losdeg)[1], "differentially expressed features"))
+    }
+    else if (M == "up") {
+        estos <- y[y[, "M"] > 0, ]
+        losdeg <- estos[estos[, "prob"] > q, ]
+        print(paste(dim(losdeg)[1], "differentially expressed features (up in first condition)"))
+    }
+    else if (M == "down") {
+        estos <- y[y[, "M"] < 0, ]
+        losdeg <- estos[estos[, "prob"] > q, ]
+        print(paste(dim(losdeg)[1], "differentially expressed features (down in first condition)"))
+    }
+    else {
+        stop("ERROR! Value for parameter M is not valid. Please, choose among NULL, 'up' or 'down'")
+    }
+    losdeg = x[rownames(losdeg), ]
+    losdeg[order(losdeg[, "prob"], decreasing = TRUE), ]
 }
 
-print.summary.netcancor (closure) = function (x, ...) 
-{
-    cat("\nCanonical Network Correlation\n\n")
-    cat("Canonical Correlations:\n\n")
-    cmat <- as.vector(x$cor)
-    cmat <- rbind(cmat, as.vector((x$cor)^2))
-    rownames(cmat) <- c("Correlation", "Coef. of Det.")
-    colnames(cmat) <- as.vector(x$cnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=cor):\n\n")
-    cmat <- matrix(data = format(x$cpgreq), ncol = length(x$cpgreq), 
-        nrow = 1)
-    colnames(cmat) <- as.vector(x$cnames)
-    rownames(cmat) <- ""
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=cor):\n\n")
-    cmat <- matrix(data = format(x$cpleeq), ncol = length(x$cpleeq), 
-        nrow = 1)
-    colnames(cmat) <- as.vector(x$cnames)
-    rownames(cmat) <- ""
-    print.table(cmat)
-    cat("\n")
-    cat("X Coefficients:\n\n")
-    cmat <- format(x$xcoef)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=xcoef):\n\n")
-    cmat <- format(x$xpgreq)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=xcoef):\n\n")
-    cmat <- format(x$xpleeq)
-    colnames(cmat) <- as.vector(x$xnames)
-    rownames(cmat) <- as.vector(x$xnames)
-    print.table(cmat)
-    cat("\n")
-    cat("Y Coefficients:\n\n")
-    cmat <- format(x$ycoef)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(>=ycoef):\n\n")
-    cmat <- format(x$ypgreq)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-    cat("Pr(<=ycoef):\n\n")
-    cmat <- format(x$ypleeq)
-    colnames(cmat) <- as.vector(x$ynames)
-    rownames(cmat) <- as.vector(x$ynames)
-    print.table(cmat)
-    cat("\n")
-    cat("Test Diagnostics:\n\n")
-    cat("\tNull Hypothesis:")
-    if (x$nullhyp == "qap") 
-        cat(" QAP\n")
-    else cat(" CUG\n")
-    cat("\tReplications:", dim(x$cdist)[1], "\n")
-    cat("\tDistribution Summary for Correlations:\n\n")
-    dmat <- apply(x$cdist, 2, min, na.rm = TRUE)
-    dmat <- rbind(dmat, apply(x$cdist, 2, quantile, probs = 0.25, 
-        names = FALSE, na.rm = TRUE))
-    dmat <- rbind(dmat, apply(x$cdist, 2, quantile, probs = 0.5, 
-        names = FALSE, na.rm = TRUE))
-    dmat <- rbind(dmat, apply(x$cdist, 2, mean, na.rm = TRUE))
-    dmat <- rbind(dmat, apply(x$cdist, 2, quantile, probs = 0.75, 
-        names = FALSE, na.rm = TRUE))
-    dmat <- rbind(dmat, apply(x$cdist, 2, max, na.rm = TRUE))
-    colnames(dmat) <- as.vector(x$cnames)
-    rownames(dmat) <- c("Min", "1stQ", "Median", "Mean", "3rdQ", 
-        "Max")
-    print.table(dmat, digits = 4)
-    cat("\n")
-}
+explo.plot (closure) = new("standardGeneric", .Data = function (object, ...) 
+standardGeneric("explo.plot"), generic = structure("explo.plot", package = "NOISeq"), 
+    package = "NOISeq", group = list(), valueClass = character(0), 
+    signature = "object", default = NULL, skeleton = (function (object, 
+        ...) 
+    stop("invalid call in method dispatch to 'explo.plot' (no default method)", 
+        domain = NA))(object, ...))
 
-print.summary.netlm (closure) = function (x, ...) 
+filtered.data (closure) = function (dataset, factor, norm = TRUE, depth = NULL, method = 1, 
+    cv.cutoff = 100, cpm = 1, p.adj = "fdr") 
 {
-    cat("\nOLS Network Model\n\n")
-    cat("Residuals:\n")
-    print.table(format(quantile(x$residuals)))
-    cat("\nCoefficients:\n")
-    cmat <- as.vector(format(as.numeric(x$coefficients)))
-    cmat <- cbind(cmat, as.vector(format(x$pleeq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreqabs)))
-    colnames(cmat) <- c("Estimate", "Pr(<=b)", "Pr(>=b)", "Pr(>=|b|)")
-    rownames(cmat) <- as.vector(x$names)
-    print.table(cmat)
-    mss <- if (x$intercept) 
-        sum((fitted(x) - mean(fitted(x)))^2)
-    else sum(fitted(x)^2)
-    rss <- sum(resid(x)^2)
-    qn <- NROW(x$qr$qr)
-    df.int <- x$intercept
-    rdf <- qn - x$rank
-    resvar <- rss/rdf
-    fstatistic <- c(value = (mss/(x$rank - df.int))/resvar, numdf = x$rank - 
-        df.int, dendf = rdf)
-    r.squared <- mss/(mss + rss)
-    adj.r.squared <- 1 - (1 - r.squared) * ((qn - df.int)/rdf)
-    sigma <- sqrt(resvar)
-    cat("\nResidual standard error:", format(sigma, digits = 4), 
-        "on", rdf, "degrees of freedom\n")
-    cat("Multiple R-squared:", format(r.squared, digits = 4), 
-        "\t")
-    cat("Adjusted R-squared:", format(adj.r.squared, digits = 4), 
-        "\n")
-    cat("F-statistic:", formatC(fstatistic[1], digits = 4), "on", 
-        fstatistic[2], "and", fstatistic[3], "degrees of freedom, p-value:", 
-        formatC(1 - pf(fstatistic[1], fstatistic[2], fstatistic[3]), 
-            digits = 4), "\n")
-    cat("\n\nTest Diagnostics:\n\n")
-    cat("\tNull Hypothesis:", x$nullhyp, "\n")
-    if (!is.null(x$dist)) {
-        cat("\tReplications:", dim(x$dist)[1], "\n")
-        cat("\tCoefficient Distribution Summary:\n\n")
-        dmat <- apply(x$dist, 2, min, na.rm = TRUE)
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.25, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.5, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, mean, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.75, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, max, na.rm = TRUE))
-        colnames(dmat) <- as.vector(x$names)
-        rownames(dmat) <- c("Min", "1stQ", "Median", "Mean", 
-            "3rdQ", "Max")
-        print.table(dmat, digits = 4)
-        cat("\n")
-    }
-}
-
-print.summary.netlogit (closure) = function (x, ...) 
-{
-    cat("\nNetwork Logit Model\n\n")
-    cat("Coefficients:\n")
-    cmat <- as.vector(format(as.numeric(x$coefficients)))
-    cmat <- cbind(cmat, as.vector(format(exp(as.numeric(x$coefficients)))))
-    cmat <- cbind(cmat, as.vector(format(x$pleeq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreq)))
-    cmat <- cbind(cmat, as.vector(format(x$pgreqabs)))
-    colnames(cmat) <- c("Estimate", "Exp(b)", "Pr(<=b)", "Pr(>=b)", 
-        "Pr(>=|b|)")
-    rownames(cmat) <- as.vector(x$names)
-    print.table(cmat)
-    cat("\nGoodness of Fit Statistics:\n")
-    cat("\nNull deviance:", x$null.deviance, "on", x$df.null, 
-        "degrees of freedom\n")
-    cat("Residual deviance:", x$deviance, "on", x$df.residual, 
-        "degrees of freedom\n")
-    cat("Chi-Squared test of fit improvement:\n\t", x$null.deviance - 
-        x$deviance, "on", x$df.null - x$df.residual, "degrees of freedom, p-value", 
-        1 - pchisq(x$null.deviance - x$deviance, df = x$df.null - 
-            x$df.residual), "\n")
-    cat("AIC:", x$aic, "\tBIC:", x$bic, "\nPseudo-R^2 Measures:\n\t(Dn-Dr)/(Dn-Dr+dfn):", 
-        (x$null.deviance - x$deviance)/(x$null.deviance - x$deviance + 
-            x$df.null), "\n\t(Dn-Dr)/Dn:", 1 - x$deviance/x$null.deviance, 
-        "\n")
-    cat("Contingency Table (predicted (rows) x actual (cols)):\n\n")
-    print.table(x$ctable, print.gap = 3)
-    cat("\n\tTotal Fraction Correct:", (x$ctable[1, 1] + x$ctable[2, 
-        2])/sum(x$ctable), "\n\tFraction Predicted 1s Correct:", 
-        x$ctable[2, 2]/sum(x$ctable[2, ]), "\n\tFraction Predicted 0s Correct:", 
-        x$ctable[1, 1]/sum(x$ctable[1, ]), "\n")
-    cat("\tFalse Negative Rate:", x$ctable[1, 2]/sum(x$ctable[, 
-        2]), "\n")
-    cat("\tFalse Positive Rate:", x$ctable[2, 1]/sum(x$ctable[, 
-        1]), "\n")
-    cat("\nTest Diagnostics:\n\n")
-    cat("\tNull Hypothesis:", x$nullhyp, "\n")
-    if (!is.null(x$dist)) {
-        cat("\tReplications:", dim(x$dist)[1], "\n")
-        cat("\tDistribution Summary:\n\n")
-        dmat <- apply(x$dist, 2, min, na.rm = TRUE)
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.25, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.5, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, mean, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, quantile, probs = 0.75, 
-            names = FALSE, na.rm = TRUE))
-        dmat <- rbind(dmat, apply(x$dist, 2, max, na.rm = TRUE))
-        colnames(dmat) <- as.vector(x$names)
-        rownames(dmat) <- c("Min", "1stQ", "Median", "Mean", 
-            "3rdQ", "Max")
-        print.table(dmat, digits = 4)
-        cat("\n")
-    }
-}
-
-print.summary.qaptest (closure) = function (x, ...) 
-{
-    cat("\nQAP Test Results\n\n")
-    cat("Estimated p-values:\n")
-    cat("\tp(f(perm) >= f(d)):", x$pgreq, "\n")
-    cat("\tp(f(perm) <= f(d)):", x$pleeq, "\n")
-    cat("\nTest Diagnostics:\n")
-    cat("\tTest Value (f(d)):", x$testval, "\n")
-    cat("\tReplications:", length(x$dist), "\n")
-    cat("\tDistribution Summary:\n")
-    cat("\t\tMin:\t", quantile(x$dist, probs = 0, names = FALSE), 
-        "\n")
-    cat("\t\t1stQ:\t", quantile(x$dist, probs = 0.25, names = FALSE), 
-        "\n")
-    cat("\t\tMed:\t", quantile(x$dist, probs = 0.5, names = FALSE), 
-        "\n")
-    cat("\t\tMean:\t", mean(x$dist), "\n")
-    cat("\t\t3rdQ:\t", quantile(x$dist, probs = 0.75, names = FALSE), 
-        "\n")
-    cat("\t\tMax:\t", quantile(x$dist, probs = 1, names = FALSE), 
-        "\n")
-    cat("\n")
-}
-
-pstar (closure) = function (dat, effects = c("choice", "mutuality", "density", 
-    "reciprocity", "stransitivity", "wtransitivity", "stranstri", 
-    "wtranstri", "outdegree", "indegree", "betweenness", "closeness", 
-    "degcentralization", "betcentralization", "clocentralization", 
-    "connectedness", "hierarchy", "lubness", "efficiency"), attr = NULL, 
-    memb = NULL, diag = FALSE, mode = "digraph") 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat) || (is.array(dat) && (length(dim(dat)) > 
-        2))) 
-        stop("Single graphs required in pstar.")
-    n <- dim(dat)[1]
-    m <- dim(dat)[2]
-    o <- list()
-    d <- dat
-    if (!diag) 
-        d <- diag.remove(d)
-    if (mode == "graph") 
-        d <- upper.tri.remove(d)
-    if (!is.null(attr)) {
-        if (is.vector(attr)) 
-            attr <- matrix(attr, ncol = 1)
-        if (is.null(colnames(attr))) 
-            colnames(attr) <- paste("Attribute", 1:dim(attr)[2], 
-                sep = ".")
-    }
-    if (!is.null(memb)) {
-        if (is.vector(memb)) 
-            memb <- matrix(memb, ncol = 1)
-        if (is.null(colnames(memb))) 
-            colnames(memb) <- paste("Membership", 1:dim(memb)[2], 
-                sep = ".")
-    }
-    tiedat <- vector()
-    for (i in 1:n) for (j in 1:m) if (!is.na(d[i, j])) {
-        td <- vector()
-        if (!is.na(pmatch("choice", effects))) {
-            td <- c(td, 1)
-        }
-        if (!is.na(pmatch("mutuality", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "mutuality"))
-        }
-        if (!is.na(pmatch("density", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "gden", 
-                mode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("reciprocity", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "grecip"))
-        }
-        if (!is.na(pmatch("stransitivity", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "gtrans", 
-                mode = mode, diag = diag, measure = "strong"))
-        }
-        if (!is.na(pmatch("wtransitivity", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "gtrans", 
-                mode = mode, diag = diag, measure = "weak"))
-        }
-        if (!is.na(pmatch("stranstri", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "gtrans", 
-                mode = mode, diag = diag, measure = "strongcensus"))
-        }
-        if (!is.na(pmatch("wtranstri", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "gtrans", 
-                mode = mode, diag = diag, measure = "weakcensus"))
-        }
-        if (!is.na(pmatch("outdegree", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "degree", 
-                cmode = "outdegree", gmode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("indegree", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "degree", 
-                cmode = "indegree", gmode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("betweenness", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "betweenness", 
-                gmode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("closeness", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "closeness", 
-                gmode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("degcentralization", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "centralization", 
-                "degree", mode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("betcentralization", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "centralization", 
-                "betweenness", mode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("clocentralization", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "centralization", 
-                "closeness", mode = mode, diag = diag))
-        }
-        if (!is.na(pmatch("connectedness", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "connectedness"))
-        }
-        if (!is.na(pmatch("hierarchy", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "hierarchy"))
-        }
-        if (!is.na(pmatch("lubness", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "lubness"))
-        }
-        if (!is.na(pmatch("efficiency", effects))) {
-            td <- c(td, eval.edgeperturbation(d, i, j, "efficiency", 
-                diag = diag))
-        }
-        if (!is.null(attr)) 
-            td <- c(td, abs(attr[i, ] - attr[j, ]))
-        if (!is.null(memb)) 
-            td <- c(td, as.numeric(memb[i, ] == memb[j, ]))
-        tiedat <- rbind(tiedat, c(d[i, j], td))
-    }
-    tiedat.lab <- "EdgeVal"
-    if (!is.na(pmatch("choice", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Choice")
-    if (!is.na(pmatch("mutuality", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Mutuality")
-    if (!is.na(pmatch("density", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Density")
-    if (!is.na(pmatch("reciprocity", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Reciprocity")
-    if (!is.na(pmatch("stransitivity", effects))) 
-        tiedat.lab <- c(tiedat.lab, "STransitivity")
-    if (!is.na(pmatch("wtransitivity", effects))) 
-        tiedat.lab <- c(tiedat.lab, "WTransitivity")
-    if (!is.na(pmatch("stranstri", effects))) 
-        tiedat.lab <- c(tiedat.lab, "STransTriads")
-    if (!is.na(pmatch("wtranstri", effects))) 
-        tiedat.lab <- c(tiedat.lab, "WTransTriads")
-    if (!is.na(pmatch("outdegree", effects))) 
-        tiedat.lab <- c(tiedat.lab, paste("Outdegree", 1:n, sep = "."))
-    if (!is.na(pmatch("indegree", effects))) 
-        tiedat.lab <- c(tiedat.lab, paste("Indegree", 1:n, sep = "."))
-    if (!is.na(pmatch("betweenness", effects))) 
-        tiedat.lab <- c(tiedat.lab, paste("Betweenness", 1:n, 
-            sep = "."))
-    if (!is.na(pmatch("closeness", effects))) 
-        tiedat.lab <- c(tiedat.lab, paste("Closeness", 1:n, sep = "."))
-    if (!is.na(pmatch("degcent", effects))) 
-        tiedat.lab <- c(tiedat.lab, "DegCentralization")
-    if (!is.na(pmatch("betcent", effects))) 
-        tiedat.lab <- c(tiedat.lab, "BetCentralization")
-    if (!is.na(pmatch("clocent", effects))) 
-        tiedat.lab <- c(tiedat.lab, "CloCentralization")
-    if (!is.na(pmatch("connectedness", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Connectedness")
-    if (!is.na(pmatch("hierarchy", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Hierarchy")
-    if (!is.na(pmatch("lubness", effects))) 
-        tiedat.lab <- c(tiedat.lab, "LUBness")
-    if (!is.na(pmatch("efficiency", effects))) 
-        tiedat.lab <- c(tiedat.lab, "Efficiency")
-    if (!is.null(attr)) 
-        tiedat.lab <- c(tiedat.lab, colnames(attr))
-    if (!is.null(memb)) 
-        tiedat.lab <- c(tiedat.lab, colnames(memb))
-    colnames(tiedat) <- tiedat.lab
-    fmla <- as.formula(paste("EdgeVal ~ -1 + ", paste(colnames(tiedat)[2:dim(tiedat)[2]], 
-        collapse = " + ")))
-    o <- glm(fmla, family = "binomial", data = as.data.frame(tiedat))
-    o$tiedata <- tiedat
-    o
-}
-
-qaptest (closure) = function (dat, FUN, reps = 1000, ...) 
-{
-    out <- list()
-    dat <- as.sociomatrix(dat)
-    fun <- match.fun(FUN)
-    out$testval <- fun(dat, ...)
-    out$dist <- vector(mode = "numeric", length = reps)
-    for (i in 1:reps) {
-        out$dist[i] <- fun(rmperm(dat), ...)
-    }
-    out$pgreq <- mean(as.numeric(out$dist >= out$testval))
-    out$pleeq <- mean(as.numeric(out$dist <= out$testval))
-    class(out) <- c("qaptest", "qap")
-    out
-}
-
-reachability (closure) = function (dat, geodist.precomp = NULL, return.as.edgelist = FALSE, 
-    na.omit = TRUE) 
-{
-    if (!is.null(geodist.precomp)) {
-        dat <- as.sociomatrix.sna(dat)
-        if (is.list(dat)) 
-            return(lapply(dat, reachability, geodist.precomp = geodist.precomp, 
-                return.as.edgelist = return.as.edgelist, na.omit = na.omit))
-        else if (length(dim(dat)) > 2) 
-            return(unlist(apply(dat, 1, function(x, geodist.precomp, 
-                return.as.edgelist, na.omit) {
-                list(reachability(x, geodist.precomp = geodist.precomp, 
-                  return.as.edgelist = return.as.edgelist, na.omit = na.omit))
-            }, geodist.precomp = geodist.precomp, return.as.edgelist = return.as.edgelist, 
-                na.omit = na.omit), recursive = FALSE))
-    }
-    else {
-        dat <- as.edgelist.sna(dat)
-        if (is.list(dat)) 
-            return(lapply(dat, reachability, geodist.precomp = geodist.precomp, 
-                return.as.edgelist = return.as.edgelist, na.omit = na.omit))
-    }
-    if (!is.null(geodist.precomp)) {
-        cnt <- geodist.precomp$counts
-        if (!return.as.edgelist) 
-            apply(cnt > 0, c(1, 2), as.numeric)
-        else as.edgelist.sna(apply(cnt > 0, c(1, 2), as.numeric))
-    }
-    else {
-        n <- attr(dat, "n")
-        if (na.omit) 
-            sel <- !is.na(dat[, 3])
-        else sel <- rep(TRUE, NROW(dat))
-        dat <- dat[(dat[, 1] != dat[, 2]) & sel, , drop = FALSE]
-        m <- NROW(dat)
-        rg <- .Call("reachability_R", dat, n, m, PACKAGE = "sna")
-        if (return.as.edgelist) 
-            rg
-        else as.sociomatrix.sna(rg)
-    }
-}
-
-read.dot (closure) = function (...) 
-{
-    lines <- readLines(...)
-    body <- lines[grep("->", lines, fixed = TRUE)]
-    nodePairs <- sub("^[[:space:]]+\"", "\"", sub("\"[;[:space:]]+$", 
-        "\"", unlist(strsplit(body, "->"))))
-    nodeLists <- split(nodePairs, 1:length(nodePairs)%%2)
-    nodes <- unique(nodePairs)
-    edges <- data.frame(orig = nodeLists[[2]], dest = nodeLists[[1]])
-    n <- length(nodes)
-    graph <- matrix(0, n, n, dimnames = list(nodes, nodes))
-    for (node in nodes) {
-        graph[node, nodes %in% edges$dest[edges$orig == node]] <- 1
-    }
-    return(graph)
-}
-
-read.nos (closure) = function (file, return.as.edgelist = FALSE) 
-{
-    f <- sapply(readLines(file, n = 2), strsplit, " ")
-    m <- as.numeric((f[[1]])[1])
-    n <- as.numeric((f[[2]])[1])
-    o <- as.numeric((f[[2]])[2])
-    dat <- scan(file, skip = 3)
-    gstack <- array(dim = c(m, n, o))
-    for (i in 1:m) for (j in 1:n) for (k in 1:o) gstack[i, j, 
-        k] <- dat[(i - 1) * n * o + (j - 1) * o + k]
-    if (return.as.edgelist) 
-        as.edgelist.sna(gstack)
-    else gstack
-}
-
-redist (closure) = function (dat, g = NULL, method = c("catrege"), mode = "digraph", 
-    diag = FALSE, seed.partition = NULL, code.diss = TRUE, ...) 
-{
-    neighb <- function() {
-        nmat <- array(0, dim = c(r, n, n))
-        for (i in 1:n) for (j in 1:n) if (d[i, j] > 0) 
-            nmat[d[i, j], i, part1[j]] <- TRUE
-        nmat
-    }
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("redist requires input graphs to be of identical order.")
-    if (is.null(g)) 
-        g <- 1:dim(dat)[1]
-    if (length(dim(dat)) > 2) {
-        n <- dim(dat)[2]
-        m <- length(g)
-        d <- dat[g, , ]
-    }
-    else {
-        n <- dim(dat)[2]
-        m <- 1
-        d <- array(dim = c(m, n, n))
-        d[1, , ] <- dat
-    }
-    if (mode == "graph") 
-        d <- symmetrize(d)
-    if (m == 1) 
-        d <- array(d, dim = c(1, n, n))
-    if (!diag) 
-        d <- diag.remove(d, 0)
-    da <- array(dim = c(2 * m, n, n))
-    for (i in 1:m) {
-        da[i * 2 - 1, , ] <- d[i, , ]
-        da[i * 2, , ] <- t(d[i, , ])
-    }
-    d <- apply(da, c(2, 3), paste, collapse = " ")
-    vals <- apply(sapply((1:2^(2 * m)) - 1, function(z) {
-        (z%/%2^((1:(2 * m)) - 1))%%2
-    }), 2, paste, collapse = " ")
-    r <- length(vals) - 1
-    d <- apply(d, c(1, 2), match, vals) - 1
-    if (match.arg(method) == "catrege") {
-        outpart <- vector()
-        if (is.null(seed.partition)) 
-            part1 <- rep(1, n)
-        else part1 <- seed.partition
-        flag <- TRUE
-        while (flag) {
-            nmat <- neighb()
-            outpart <- rbind(outpart, part1)
-            flag <- FALSE
-            part2 <- 1:n
-            for (i in 2:n) for (j in 1:(i - 1)) if (part1[i] == 
-                part1[j]) {
-                if (all(nmat[, i, ] == nmat[, j, ])) 
-                  part2[i] <- part2[j]
-                else flag <- TRUE
-            }
-            part1 <- part2
-        }
-        imax <- function(i, j) {
-            if (any(outpart[, i] == outpart[, j])) 
-                max((1:NROW(outpart))[outpart[, i] == outpart[, 
-                  j]])
-            else 0
-        }
-        eq <- matrix(0, n, n)
-        for (i in 1:n) for (j in 1:n) eq[i, j] <- imax(i, j)
-    }
-    if (!code.diss) 
-        eq
-    else {
-        if (max(eq) == min(eq)) 
-            matrix(0, NROW(eq), NCOL(eq))
-        else (max(eq) - eq)/(max(eq) - min(eq))
-    }
-}
-
-rewire.ud (closure) = function (g, p, return.as.edgelist = FALSE) 
-{
-    g <- as.sociomatrix.sna(g)
-    if (is.list(g)) 
-        return(lapply(g, rewire.ud, p = p))
-    if (length(dim(g)) == 2) 
-        g <- array(g, dim = c(1, NROW(g), NCOL(g)))
-    n <- dim(g)[1]
-    nv <- dim(g)[2]
-    rewired <- .C("udrewire_R", g = as.double(g), as.double(n), 
-        as.double(nv), as.double(p), PACKAGE = "sna")
-    if (!return.as.edgelist) 
-        array(rewired$g, dim = c(n, nv, nv))
-    else as.edgelist.sna(array(rewired$g, dim = c(n, nv, nv)))
-}
-
-rewire.ws (closure) = function (g, p, return.as.edgelist = FALSE) 
-{
-    g <- as.sociomatrix.sna(g)
-    if (is.list(g)) 
-        return(lapply(g, rewire.ud, p = p))
-    if (length(dim(g)) == 2) 
-        gi <- array(g, dim = c(1, NROW(g), NCOL(g)))
-    go <- gi
-    n <- dim(gi)[1]
-    nv <- dim(gi)[2]
-    rewired <- .C("wsrewire_R", as.double(gi), go = as.double(go), 
-        as.double(n), as.double(nv), as.double(p), PACKAGE = "sna")
-    if (!return.as.edgelist) 
-        array(rewired$go, dim = c(n, nv, nv))
-    else as.edgelist.sna(array(rewired$go, dim = c(n, nv, nv)))
-}
-
-rgbn (closure) = function (n, nv, param = list(pi = 0, sigma = 0, rho = 0, d = 0.5, 
-    delta = 0), burn = nv * nv * 5 * 100, thin = nv * nv * 5, 
-    maxiter = 1e+07, method = c("mcmc", "cftp"), dichotomize.sib.effects = FALSE, 
-    return.as.edgelist = FALSE) 
-{
-    g <- array(0, dim = c(n, nv, nv))
-    p <- rep(0, 4)
-    if (!is.null(param$pi)) 
-        p[1] <- param$pi[1]
-    if (!is.null(param$sigma)) 
-        p[2] <- param$sigma[1]
-    if (!is.null(param$rho)) 
-        p[3] <- param$rho[1]
-    if (!is.null(param$delta)) 
-        p[4] <- param$delta[1]
-    if ((p[4] > 0) && (match.arg(method) == "cftp")) 
-        stop("Satiation parameter (delta) not supported with CFTP at present; use MCMC instead.\n")
-    if (!is.null(param$d)) {
-        d <- matrix(param$d, nv, nv)
-    }
-    else d <- matrix(0, nv, nv)
-    if (match.arg(method) == "mcmc") 
-        g <- array(.C("bn_mcmc_R", g = as.integer(g), as.double(nv), 
-            as.double(n), as.double(burn), as.integer(thin), 
-            as.double(p[1]), as.double(p[2]), as.double(p[3]), 
-            as.double(d), as.double(p[4]), as.integer(dichotomize.sib.effects), 
-            PACKAGE = "sna")$g, dim = c(n, nv, nv))
-    else {
-        if (any(d > 0)) {
-            if (all(d == 1)) {
-                for (i in 1:n) {
-                  g[i, , ] <- 1
-                  diag(g[i, , ]) <- 0
-                }
-            }
-            else {
-                d[d == 0] <- 1e-10
-                d[d == 1] <- 1 - 1e-10
-                for (i in 1:n) {
-                  g[i, , ] <- matrix(.C("bn_cftp_R", g = as.integer(g[i, 
-                    , ]), as.integer(nv), as.double(p[1]), as.double(p[2]), 
-                    as.double(p[3]), as.double(d), as.integer(maxiter), 
-                    as.integer(dichotomize.sib.effects), PACKAGE = "sna", 
-                    NAOK = TRUE)$g, nv, nv)
-                }
-            }
+    dataset0 = dataset[rowSums(dataset) > 0, ]
+    dataset = dataset0
+    if ((method == 3) && (norm)) {
+        if (is.null(depth)) {
+            stop("ERROR: Sequencing depth for each column in dataset must be provided.\n")
         }
+        dataset = t(t(dataset0)/(colSums(dataset0)/depth))
     }
-    if (return.as.edgelist) 
-        as.edgelist.sna(g)
-    else {
-        if (dim(g)[1] == 1) 
-            g[1, , ]
-        else g
+    if ((method < 3) && (!norm)) {
+        dataset = 10^6 * t(t(dataset0)/colSums(dataset0))
     }
+    grupos = unique(factor)
+    cumple = NULL
+    cat("Filtering out low count features...\n")
+    for (gg in grupos) {
+        datos = as.matrix(dataset[, factor == gg])
+        if (method == 1) {
+            if (ncol(datos) == 1) {
+                cumplecond = (datos > cpm)
+            }
+            else {
+                cumplecond = (apply(datos, 1, CV) < cv.cutoff) * 
+                  (rowMeans(datos) > cpm)
+                cumplecond[which(is.na(cumplecond) == TRUE)] = 0
+            }
+            cumple = cbind(cumple, cumplecond)
+        }
+        if (method == 2) {
+            if (ncol(datos) == 1) 
+                stop("ERROR: At least 2 replicates per condition are required to apply this method.")
+            mytest = apply(datos, 1, function(x) {
+                suppressWarnings(wilcox.test(x, alternative = "greater", 
+                  conf.int = FALSE, mu = 0))$p.value
+            })
+            mytest = p.adjust(mytest, method = p.adj)
+            cumple = cbind(cumple, 1 * (mytest < 0.05))
+        }
+        if (method == 3) {
+            p0 = cpm/10^6
+            mytest = apply(datos, 1, function(x) suppressWarnings(prop.test(sum(x), 
+                n = sum(datos), p = p0, alternative = "greater"))$p.value)
+            mytest = p.adjust(mytest, method = p.adj)
+            cumple = cbind(cumple, 1 * (mytest < 0.05))
+        }
+    }
+    cumple = which(rowSums(as.matrix(cumple)) >= 1)
+    cat(paste(length(cumple), "features are to be kept for differential expression analysis with filtering method", 
+        method))
+    cat("\n")
+    dataset0[cumple, ]
 }
 
-rgnm (closure) = function (n, nv, m, mode = "digraph", diag = FALSE, return.as.edgelist = FALSE) 
+hideOutput (NULL) = NULL
+
+int.mult (closure) = function (lista, todos = NULL) 
 {
-    g <- vector(mode = "list", n)
-    if (mode == "graph") {
-        enum <- matrix(1:nv^2, nv, nv)
-        enum <- enum[lower.tri(enum, diag = diag)]
-    }
-    else if (mode == "digraph") {
-        enum <- matrix(1:nv^2, nv, nv)
-        diag(enum) <- NA
-        enum <- enum[!is.na(enum)]
+    if (is.null(todos)) {
+        todos <- unlist(lista)
     }
-    else stop("Unsupported mode in rgnm.")
-    for (i in 1:n) {
-        if (nv == 0) {
-            if (m > 0) 
-                stop("Too many edges requested in rgnm.")
-            else {
-                mat <- matrix(nrow = 0, ncol = 3)
-                attr(mat, "n") <- 0
-            }
-            g[[i]] <- mat
-        }
-        else if (nv == 1) {
-            if (m > diag) 
-                stop("Too many edges requested in rgnm.")
-            if (diag) {
-                mat <- matrix(c(1, 1, 1), nrow = 1, ncol = 3)
-                attr(mat, "n") <- 1
-            }
-            else {
-                mat <- matrix(nrow = 0, ncol = 3)
-                attr(mat, "n") <- 1
-            }
-            g[[i]] <- mat
+    comunes <- todos
+    for (i in 1:length(lista)) {
+        comunes <- intersect(comunes, lista[[i]])
+    }
+    comunes
+}
+
+length.dat (closure) = function (input, factor = NULL, norm = FALSE) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object\n")
+    if (!is.null(assayData(input)$exprs)) 
+        datos <- assayData(input)$exprs
+    else datos <- assayData(input)$counts
+    ceros = which(rowSums(datos) == 0)
+    if (length(ceros) > 0) {
+        print(paste("Warning:", length(ceros), "features with 0 counts in all samples are to be removed for this analysis."))
+        datos = datos[-ceros, ]
+    }
+    nsam <- NCOL(datos)
+    if (nsam == 1) 
+        datos <- as.matrix(datos)
+    if (is.null(factor)) {
+        print("Length bias detection information is to be computed for:")
+        print(colnames(datos))
+    }
+    else {
+        mifactor = as.factor(pData(input)[, factor])
+        niveles = levels(mifactor)
+        print("Length bias detection information is to be computed for:")
+        print(niveles)
+        if (norm) {
+            datos = sapply(niveles, function(k) {
+                rowMeans(as.matrix(datos[, mifactor == k]))
+            })
         }
         else {
-            if (m > 0) {
-                if (length(enum) > 1) 
-                  el <- sample(enum, m)
-                else el <- enum
-                head <- ((el - 1)%/%nv) + 1
-                tail <- ((el - 1)%%nv) + 1
-                mat <- cbind(tail, head, rep(1, m))
-                if (mode == "graph") 
-                  mat <- rbind(mat, mat[mat[, 1] != mat[, 2], 
-                    c(2, 1, 3), drop = FALSE])
-                attr(mat, "n") <- nv
-            }
-            else {
-                mat <- matrix(nrow = 0, ncol = 3)
-                attr(mat, "n") <- nv
-            }
-            g[[i]] <- mat
+            datos = sapply(niveles, function(k) {
+                rowMeans(t(10^6 * t(datos[, mifactor == k])/colSums(as.matrix(datos[, 
+                  mifactor == k]))))
+            })
         }
+        colnames(datos) = niveles
     }
-    if (!return.as.edgelist) 
-        as.sociomatrix.sna(g)
-    else {
-        if (n > 1) 
-            g
-        else g[[1]]
-    }
-}
-
-rgnmix (closure) = function (n, tv, mix, mode = "digraph", diag = FALSE, method = c("probability", 
-    "exact"), return.as.edgelist = FALSE) 
-{
-    if (match.arg(method) == "probability") {
-        return(rgraph(n = length(tv), m = n, tprob = mix[tv, 
-            tv], mode = mode, diag = diag, return.as.edgelist = return.as.edgelist))
-    }
-    else {
-        g <- array(0, dim = c(n, length(tv), length(tv)))
-        if (is.character(tv)) {
-            if (is.null(rownames(mix))) 
-                stop("Vertex types may only be given as characters for mixing matrices with applicable rownames.\n")
-            tv <- match(tv, rownames(mix))
-        }
-        tcounts <- tabulate(tv, NROW(mix))
-        if (mode == "graph") {
-            for (i in 1:n) {
-                for (j in 1:NROW(mix)) if (tcounts[j] > 0) {
-                  for (k in j:NROW(mix)) if (tcounts[k] > 0) {
-                    if (j == k) {
-                      if (tcounts[j] == 1) {
-                        if (diag) 
-                          g[i, tv == j, tv == k] <- mix[j, k]
-                      }
-                      else if ((tcounts[j] == 2) && (!diag)) {
-                        if (mix[j, k]) 
-                          g[i, tv == j, tv == k] <- rbind(c(0, 
-                            1), c(1, 0))
-                      }
-                      else {
-                        g[i, tv == j, tv == k] <- rgnm(n = 1, 
-                          nv = tcounts[j], m = mix[j, k], mode = "graph", 
-                          diag = diag)
-                      }
-                    }
-                    else {
-                      g[i, tv == j, tv == k][sample(1:(tcounts[j] * 
-                        tcounts[k]), mix[j, k], replace = FALSE)] <- 1
-                    }
-                  }
+    if (any(!is.na(featureData(input)$Length)) == FALSE) 
+        stop("Feature length was not provided.\nPlease run addData() function to add \n          this information\n")
+    long <- as.numeric(as.character(featureData(input)$Length))
+    if (length(ceros) > 0) 
+        long = long[-ceros]
+    if (!is.null(featureData(input)$Biotype)) {
+        infobio <- as.character(featureData(input)$Biotype)
+        if (length(ceros) > 0) 
+            infobio = infobio[-ceros]
+        biotypes <- unique(infobio)
+        names(biotypes) <- biotypes
+        biog <- lapply(biotypes, function(x) {
+            which(is.element(infobio, x))
+        })
+        names(biog) = biotypes
+        bionum <- c(NROW(datos), sapply(biog, length))
+        names(bionum) <- c("global", names(biotypes))
+    }
+    else {
+        infobio = NULL
+        biotypes = NULL
+        bionum = NULL
+    }
+    longexpr = vector("list", length = 1 + length(biotypes))
+    names(longexpr) = c("global", names(biotypes))
+    numXbin = 200
+    for (i in 1:length(longexpr)) {
+        if (i == 1) {
+            numdatos = length(long)
+            numbins = floor(numdatos/numXbin)
+            misbins = quantile(long, probs = seq(0, 1, 1/numbins), 
+                na.rm = TRUE)
+            if (length(misbins) != length(unique(misbins))) {
+                repes = names(table(misbins))[which(table(misbins) > 
+                  1)]
+                for (rr in repes) {
+                  cuantos = length(which(misbins == rr))
+                  cuales = which(misbins == rr)
+                  sumo = (misbins[cuales[1] + cuantos] - misbins[cuales[1]])/cuantos
+                  for (j in cuales[-1]) misbins[j] = misbins[j - 
+                    1] + sumo
                 }
-                g[i, , ] <- g[i, , ] | t(g[i, , ])
             }
+            miclasi = cut(long, breaks = misbins, labels = FALSE)
+            misbins = sapply(1:numbins, function(i) mean(misbins[i:(i + 
+                1)]))
+            miclasi = misbins[miclasi]
+            longexpr[[i]] = aggregate(datos, by = list(lengthbin = miclasi), 
+                mean, trim = 0.025)
         }
         else {
-            for (i in 1:n) {
-                for (j in 1:NROW(mix)) if (tcounts[j] > 0) {
-                  for (k in 1:NROW(mix)) if (tcounts[k] > 0) {
-                    if (j == k) {
-                      if (tcounts[j] == 1) {
-                        if (diag) 
-                          g[i, tv == j, tv == k] <- mix[j, k]
-                      }
-                      else {
-                        g[i, tv == j, tv == k] <- rgnm(n = 1, 
-                          nv = tcounts[j], m = mix[j, k], mode = "digraph", 
-                          diag = diag)
-                      }
-                    }
-                    else {
-                      g[i, tv == j, tv == k][sample(1:(tcounts[j] * 
-                        tcounts[k]), mix[j, k], replace = FALSE)] <- 1
-                    }
+            datos2 = datos[biog[[i - 1]], ]
+            long2 = long[biog[[i - 1]]]
+            if (bionum[i] >= numXbin * 10) {
+                numdatos = length(long2)
+                numbins = floor(numdatos/numXbin)
+                misbins = quantile(long2, probs = seq(0, 1, 1/numbins), 
+                  na.rm = TRUE)
+                if (length(misbins) != length(unique(misbins))) {
+                  repes = names(table(misbins))[which(table(misbins) > 
+                    1)]
+                  for (rr in repes) {
+                    cuantos = length(which(misbins == rr))
+                    cuales = which(misbins == rr)
+                    sumo = (misbins[cuales[1] + cuantos] - misbins[cuales[1]])/cuantos
+                    for (j in cuales[-1]) misbins[j] = misbins[j - 
+                      1] + sumo
                   }
                 }
+                miclasi = cut(long2, breaks = misbins, labels = FALSE)
+                misbins = sapply(1:numbins, function(i) mean(misbins[i:(i + 
+                  1)]))
+                miclasi = misbins[miclasi]
+                longexpr[[i]] = aggregate(datos2, by = list(lengthbin = miclasi), 
+                  mean, trim = 0.025, na.rm = TRUE)
+            }
+            else {
+                longexpr[[i]] = cbind(long2, datos2)
             }
         }
     }
-    if (n == 1) 
-        g <- g[1, , ]
-    if (return.as.edgelist) 
-        as.edgelist.sna(g)
-    else g
-}
-
-rgraph (closure) = function (n, m = 1, tprob = 0.5, mode = "digraph", diag = FALSE, 
-    replace = FALSE, tielist = NULL, return.as.edgelist = FALSE) 
-{
-    if (is.null(tielist)) {
-        g <- list()
-        directed <- (mode == "digraph")
-        if (length(dim(tprob)) > 3) 
-            stop("tprob must be a single element, vector, matrix, or 3-d array.")
-        if (length(dim(tprob)) == 3) {
-            pmode <- 3
-            if ((dim(tprob)[1] != m) || (dim(tprob)[2] != n) || 
-                (dim(tprob)[3] != n)) 
-                stop("Incorrect tprob dimensions.")
-        }
-        else if (length(dim(tprob)) == 2) {
-            pmode <- 3
-            if ((dim(tprob)[1] != n) || (dim(tprob)[2] != n)) 
-                stop("Incorrect tprob dimensions.")
-        }
-        else {
-            pmode <- 0
-            tprob <- rep(tprob, length = m)
-        }
-        for (i in 1:m) {
-            if (length(dim(tprob)) == 3) 
-                g[[i]] <- .Call("rgbern_R", n, tprob[i, , ], 
-                  directed, diag, pmode, PACKAGE = "sna")
-            else if (length(dim(tprob)) == 2) 
-                g[[i]] <- .Call("rgbern_R", n, tprob, directed, 
-                  diag, pmode, PACKAGE = "sna")
-            else g[[i]] <- .Call("rgbern_R", n, tprob[i], directed, 
-                diag, pmode, PACKAGE = "sna")
-        }
-        if (return.as.edgelist) {
-            if (m == 1) 
-                g[[1]]
-            else g
-        }
-        else as.sociomatrix.sna(g)
-    }
-    else {
-        g <- array(dim = c(m, n, n))
-        if (length(dim(tielist)) == 3) {
-            for (i in 1:m) g[i, , ] <- array(sample(as.vector(tielist[i, 
-                , ]), n * n, replace = replace), dim = c(n, n))
-        }
-        else {
-            for (i in 1:m) g[i, , ] <- array(sample(as.vector(tielist), 
-                n * n, replace = replace), dim = c(n, n))
-        }
-        if (!diag) 
-            for (i in 1:m) diag(g[i, , ]) <- 0
-        if (mode != "digraph") 
-            for (i in 1:m) {
-                temp <- g[i, , ]
-                temp[upper.tri(temp)] <- t(temp)[upper.tri(temp)]
-                g[i, , ] <- temp
-            }
-        if (!return.as.edgelist) {
-            if (m == 1) 
-                g[1, , ]
-            else g
-        }
-        else as.edgelist.sna(g)
+    datos = longexpr[[1]]
+    longi = datos[, 1]
+    knots = c(rep(longi[1], 3), seq(longi[1], longi[length(longi) - 
+        1], length.out = round(length(longi)/10, 0)), rep(longi[length(longi)], 
+        4))
+    bx = splineDesign(knots, longi, outer.ok = TRUE)
+    mismodelos = vector("list", length = ncol(datos) - 1)
+    names(mismodelos) = colnames(datos)[-1]
+    for (i in 2:ncol(datos)) {
+        print(colnames(datos)[i])
+        mismodelos[[i - 1]] = lm(datos[, i] ~ bx)
+        print(summary(mismodelos[[i - 1]]))
     }
+    list(data2plot = longexpr, RegressionModels = mismodelos)
 }
 
-rguman (closure) = function (n, nv, mut = 0.25, asym = 0.5, null = 0.25, method = c("probability", 
-    "exact"), return.as.edgelist = FALSE) 
-{
-    g <- array(0, dim = c(n, nv, nv))
-    dl <- matrix(1:(nv^2), nv, nv)
-    dlu <- dl[upper.tri(dl)]
-    dll <- t(dl)[upper.tri(dl)]
-    ndl <- length(dlu)
-    if ((match.arg(method) == "exact") && (mut + asym + null != 
-        ndl)) 
-        stop("Sum of dyad counts must equal number of dyads for method==exact.\n")
-    else if ((match.arg(method) == "probability") && (mut + asym + 
-        null != 1)) {
-        s <- mut + asym + null
-        mut <- mut/s
-        asym <- asym/s
-        null <- null/s
-    }
-    for (i in 1:n) {
-        if (match.arg(method) == "probability") {
-            mc <- rbinom(1, ndl, mut)
-            ac <- rbinom(1, ndl - mc, asym/(asym + null))
-            nc <- ndl - mc - ac
-        }
-        else {
-            mc <- mut
-            ac <- asym
-            nc <- null
-        }
-        ds <- sample(rep(1:3, times = c(mc, ac, nc)))
-        if (mc > 0) {
-            g[i, , ][dlu[ds == 1]] <- 1
-            g[i, , ][dll[ds == 1]] <- 1
-        }
-        if (ac > 0) {
-            g[i, , ][dlu[ds == 2]] <- rbinom(ac, 1, 0.5)
-            g[i, , ][dll[ds == 2]] <- 1 - g[i, , ][dlu[ds == 
-                2]]
+length.plot (closure) = function (dat, samples = NULL, toplot = "global", toreport = FALSE, 
+    ...) 
+{
+    datos = dat[["data2plot"]]
+    mismodelos = dat[["RegressionModels"]]
+    if (is.null(samples)) 
+        samples <- 1:(ncol(datos[[1]]) - 1)
+    if (length(samples) > 12) 
+        stop("Please select 12 samples or less to be plotted.")
+    if (is.numeric(samples)) {
+        samples = colnames(datos[[1]])[samples + 1]
+    }
+    if (is.numeric(toplot)) {
+        if (toplot == 1) {
+            toplot = "global"
+        }
+        else {
+            toplot = names(toplot)[toplot + 1]
+        }
+    }
+    if ((toplot == "global") && (length(samples) <= 2)) {
+        if ((!toreport) && (length(samples) == 2)) 
+            par(mfrow = c(1, 2))
+        for (i in 1:length(samples)) {
+            matplot(datos[[1]][, 1], cbind(datos[[1]][, samples[i]], 
+                mismodelos[[samples[i]]]$fit), type = "pl", main = samples[i], 
+                pch = 20, lty = 1, lwd = 2, ylab = "Mean expression", 
+                xlab = "Length bins", ylim = c(0, max(datos[[1]][, 
+                  samples[i]])), ...)
+            text(max(datos[[1]][, 1]), 0.2 * max(datos[[1]][, 
+                samples[i]]), col = 2, adj = 1, paste("R2 = ", 
+                100 * round(summary(mismodelos[[samples[i]]])$r.squared, 
+                  4), "%", sep = ""))
+            laF = summary(mismodelos[[samples[i]]])$fstatistic
+            text(max(datos[[1]][, 1]), 0.1 * max(datos[[1]][, 
+                samples[i]]), col = 2, adj = 1, paste("p-value:", 
+                signif(pf(laF[1], df1 = laF[2], df2 = laF[3], 
+                  lower.tail = FALSE), 2)))
         }
     }
-    if (return.as.edgelist) 
-        as.edgelist.sna(g)
     else {
-        if (n > 1) 
-            g
-        else g[1, , ]
-    }
+        matplot(datos[[toplot]][, 1], datos[[toplot]][, samples], 
+            xlab = "Length bins", ylab = "Mean expression", type = "l", 
+            main = toupper(toplot), col = miscolores, lwd = 2, 
+            ylim = range(datos[[toplot]][, -1]), lty = 1, ...)
+        legend("bottomright", samples, col = miscolores[1:length(samples)], 
+            lwd = 2, bty = "n")
+    }
+    if ((!toreport) && (length(samples) == 2)) 
+        layout(1)
+}
+
+logscaling (closure) = function (data, base = 2, k = 1) 
+{
+    logmaximo = round(max(data, na.rm = TRUE), 0)
+    numceros = nchar(logmaximo) - 1
+    etiquetas = c(0, 10^(1:numceros))
+    donde = log(etiquetas + k, base = base)
+    data = log(data + k, base = base)
+    list(data = data, at = donde, labels = etiquetas)
 }
 
-rgws (closure) = function (n, nv, d, z, p, return.as.edgelist = FALSE) 
+make.ASCA.design (closure) = function (x) 
 {
-    tnv <- nv^d
-    temp <- vector()
-    nums <- 1:nv
-    count <- tnv/nv
-    for (i in 1:d) {
-        temp <- cbind(temp, rep(nums, count))
-        nums <- rep(nums, each = nv)
-        count <- count/nv
+    x <- as.factor(x)
+    levels <- unique(x)
+    n <- length(x)
+    p <- length(levels)
+    Design <- matrix(0, nrow = n, ncol = p)
+    for (i in 1:n) {
+        for (j in 1:p) {
+            if (x[i] == levels[j]) {
+                Design[i, j] = 1
+            }
+        }
+    }
+    colnames(Design) <- levels
+    output <- Design
+    output
+}
+
+miscolores (character) = c("red2", "darkolivegreen4", "darkslategray3", "orchid4", "azure4", 
+"sienna2", "dodgerblue4", "lightsalmon4", "slategray2", "salmon", 
+"darkolivegreen1", "lavenderblush2")
+
+myDfunction (closure) = function (mydif, myrat, stat, coef) 
+{
+    if (stat == 1) {
+        myDvalues = coef * mydif + (1 - coef) * myrat
+    }
+    if (stat == 2) {
+        myDvalues = sign(mydif) * sqrt((mydif)^2 + (myrat)^2)
+    }
+    myDvalues
+}
+
+mypretty (closure) = function (x, n = 5) 
+{
+    mywidth <- diff(x)
+    mybin <- ceiling(mywidth/(n - 1))
+    mylabels0 <- x[1] + mybin * (0:(n - 1))
+    ndig <- nchar(as.character(mylabels0))
+    mylabels <- mylabels0
+    k <- 0
+    for (i in 2:(n - 1)) {
+        mylabels[i] <- (round(mylabels0[i]/10^(ndig[i] - 1), 
+            k)) * 10^(ndig[i] - 1)
+        while (mylabels[i] == mylabels[i - 1]) {
+            k <- k + 1
+            mylabels[i] <- (round(mylabels0[i]/10^(ndig[i] - 
+                1), k)) * 10^(ndig[i] - 1)
+        }
+    }
+    mylabels
+}
+
+n.menor (closure) = function (x, S1, S2) 
+{
+    length(which(S1 <= x[1] & S2 <= x[2]))
+}
+
+noceros (closure) = function (x, num = TRUE, k = 0) 
+{
+    nn <- length(which(x > k))
+    if (num) {
+        nn
+    }
+    else {
+        if (nn > 0) {
+            which(x > k)
+        }
+        else {
+            NULL
+        }
+    }
+}
+
+noiseq (closure) = function (input, k = 0.5, norm = c("rpkm", "uqua", "tmm", "n"), 
+    replicates = c("technical", "biological", "no"), factor = NULL, 
+    conditions = NULL, pnr = 0.2, nss = 5, v = 0.02, lc = 0) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an object generated by the readData function\n")
+    if (is.null(factor)) 
+        stop("Error. You must specify the factor to know which conditions you wish to compare.\n         Please, give the argument 'factor'.\n")
+    replicates <- match.arg(replicates)
+    if (replicates == "biological") 
+        print("WARNING: Your experiment has biological replicates. You should consider using NOISeqBIO instead of NOISeq.")
+    norm <- match.arg(norm)
+    print("Computing (M,D) values...")
+    miMD <- allMD(input, factor, k = k, replicates = replicates, 
+        norm = norm, conditions = conditions, pnr = pnr, nss = nss, 
+        v = v, lc = lc)
+    print("Computing probability of differential expression...")
+    prob.concounts <- probdeg(miMD$Ms, miMD$Ds, miMD$Mn, miMD$Dn)$prob
+    if (!is.null(assayData(input)$exprs)) 
+        todos <- rownames(as.matrix(assayData(input)$exprs))
+    else todos <- rownames(as.matrix(assayData(input)$counts))
+    prob <- prob.concounts[todos]
+    names(prob) <- todos
+    resultat <- data.frame(level_1 = miMD$Level1, level_2 = miMD$Level2, 
+        M = miMD$Ms, D = miMD$Ds, prob = prob)
+    rownames(resultat) <- todos
+    colnames(resultat)[1] <- paste(unlist(strsplit(miMD$comp, 
+        " "))[1], "mean", sep = "_")
+    colnames(resultat)[2] <- paste(unlist(strsplit(miMD$comp, 
+        " "))[3], "mean", sep = "_")
+    resultat <- data.frame(resultat, ranking = ranking(resultat)$statistic)
+    if (!is.null(featureData(input)@data$Length)) 
+        resultat <- data.frame(resultat, Length = as.numeric(as.character(featureData(input)@data[todos, 
+            "Length"])), stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$GC)) 
+        resultat <- data.frame(resultat, GC = as.numeric(as.character(featureData(input)@data[todos, 
+            "GC"])), stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$Chromosome)) 
+        resultat <- data.frame(resultat, Chrom = as.character(featureData(input)@data$Chromosome), 
+            GeneStart = as.numeric(as.character(featureData(input)@data$GeneStart)), 
+            GeneEnd = as.numeric(as.character(featureData(input)@data$GeneEnd)), 
+            stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$Biotype)) 
+        resultat <- data.frame(resultat, Biotype = as.character(featureData(input)@data[todos, 
+            "Biotype"]), stringsAsFactors = FALSE)
+    Output(data = list(resultat), method = norm, k = miMD$k, 
+        lc = lc, factor = factor, v = v, nss = nss, pnr = pnr, 
+        comparison = miMD$comp, replicates = replicates)
+}
+
+noiseqbio (closure) = function (input, k = 0.5, norm = c("rpkm", "uqua", "tmm", "n"), 
+    nclust = 15, plot = FALSE, factor = NULL, conditions = NULL, 
+    lc = 0, r = 50, adj = 1.5, a0per = 0.9, random.seed = 12345, 
+    filter = 1, depth = NULL, cv.cutoff = 500, cpm = 1) 
+{
+    if (inherits(input, "eSet") == FALSE) 
+        stop("ERROR: You must give an object generated by the readData function\n")
+    if (is.null(factor)) 
+        stop("ERROR: You must specify the factor to know which conditions you wish to compare.\n         Please, give the argument 'factor'.\n")
+    if (min(table(input@phenoData@data[, factor])) < 2) 
+        stop("ERROR: To run NOISeqBIO at least two replicates per condition are needed.\n         Please, run NOISeq if there are not enough replicates in your experiment.\n")
+    norm <- match.arg(norm)
+    if (!is.null(random.seed)) 
+        set.seed(random.seed)
+    cat("Computing Z values...\n")
+    miMD <- allMDbio(input, factor, k = k, norm = norm, conditions = conditions, 
+        lc = lc, r = r, a0per = a0per, nclust = nclust, filter = filter, 
+        depth = depth, cv.cutoff = cv.cutoff, cpm = cpm)
+    cat("Computing probability of differential expression...\n")
+    desde <- min(c(miMD$Zs, miMD$Zn), na.rm = TRUE)
+    hasta <- max(c(miMD$Zs, miMD$Zn), na.rm = TRUE)
+    fdens <- density(miMD$Zs, adjust = adj, n = 5000, from = desde, 
+        to = hasta, na.rm = TRUE)
+    f <- approxfun(fdens)
+    f0dens <- density(miMD$Zn, adjust = adj, n = 5000, from = desde, 
+        to = hasta, na.rm = TRUE)
+    f0 <- approxfun(f0dens)
+    if (f0(0)/f(0) < 1) 
+        print("WARNING: f0(0)/f(0) < 1 => FP with Z~0 will be detected.")
+    f0.f <- f0(miMD$Zs)/f(miMD$Zs)
+    if (plot) {
+        plot(f0dens, lwd = 2, col = 4, main = paste("r=", r, 
+            "; a0per=", a0per, sep = ""), xlab = "theta")
+        lines(fdens, lwd = 2, col = 1)
+        legend("topleft", c("f", "f0"), col = c(1, 4), lwd = 2)
+    }
+    p0 <- min(1/f0.f, na.rm = TRUE)
+    p0 = min(p0, 1)
+    cat(paste("p0 =", p0))
+    cat("\n")
+    myprob <- 1 - p0 * f0.f
+    if (min(myprob, na.rm = TRUE) < 0) {
+        print(summary(f0.f))
+    }
+    names(myprob) <- names(miMD$Zs)
+    cat("Probability\n")
+    print(summary(myprob))
+    if (!is.null(assayData(input)$exprs)) 
+        todos <- rownames(as.matrix(assayData(input)$exprs))
+    else todos <- rownames(as.matrix(assayData(input)$counts))
+    myprob <- myprob[todos]
+    names(myprob) <- todos
+    resultat <- data.frame(level_1 = miMD$Level1, level_2 = miMD$Level2, 
+        theta = miMD$Zs, prob = myprob, log2FC = log2(miMD$Level1/miMD$Level2))
+    rownames(resultat) <- todos
+    colnames(resultat)[1] <- paste(unlist(strsplit(miMD$comp, 
+        " "))[1], "mean", sep = "_")
+    colnames(resultat)[2] <- paste(unlist(strsplit(miMD$comp, 
+        " "))[3], "mean", sep = "_")
+    if (!is.null(featureData(input)@data$Length)) 
+        resultat <- data.frame(resultat, length = as.numeric(as.character(featureData(input)@data[todos, 
+            "Length"])), stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$GC)) 
+        resultat <- data.frame(resultat, GC = as.numeric(as.character(featureData(input)@data[todos, 
+            "GC"])), stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$Chromosome)) 
+        resultat <- data.frame(resultat, Chrom = (as.character(featureData(input)@data$Chromosome)), 
+            GeneStart = as.numeric(as.character(featureData(input)@data$GeneStart)), 
+            GeneEnd = as.numeric(as.character(featureData(input)@data$GeneEnd)), 
+            stringsAsFactors = FALSE)
+    if (!is.null(featureData(input)@data$Biotype)) 
+        resultat <- data.frame(resultat, Biotype = as.character(featureData(input)@data[todos, 
+            "Biotype"]), stringsAsFactors = FALSE)
+    Output(data = list(resultat), method = norm, k = miMD$k, 
+        lc = lc, factor = factor, comparison = miMD$comp, replicates = "biological", 
+        v = 0, nss = 0, pnr = 0)
+}
+
+plot.y2 (closure) = function (x, yright, yleft, yrightlim = range(yright, na.rm = TRUE), 
+    yleftlim = range(yleft, na.rm = TRUE), xlim = range(x, na.rm = TRUE), 
+    xlab = NULL, yylab = c("", ""), lwd = c(2, 2), pch = c(1, 
+        2), col = c(1, 2), type = c("o", "o"), linky = TRUE, 
+    smooth = 0, bg = c("white", "white"), lwds = 1, length = 10, 
+    ..., x2 = NULL, yright2 = NULL, yleft2 = NULL, col2 = c(3, 
+        4)) 
+{
+    plot(x, yright, axes = FALSE, ylab = "", xlab = xlab, ylim = yrightlim, 
+        xlim = xlim, pch = pch[1], type = type[1], lwd = lwd[1], 
+        col = col[1], ...)
+    axis(4, pretty(yrightlim, length), col = 1, col.axis = 1)
+    if (is.null(yright2) == FALSE) {
+        points(x2, yright2, type = type[1], pch = pch[1], lwd = lwd[1], 
+            col = col2[1], ...)
+    }
+    if (smooth != 0) 
+        lines(supsmu(x, yright, span = smooth), col = col[1], 
+            lwd = lwds, ...)
+    if (yylab[1] == "") {
+        mtext(deparse(substitute(yright)), side = 4, outer = FALSE, 
+            line = 2, col = 1, ...)
     }
-    lat <- as.matrix(dist(temp, method = "manhattan")) <= z
-    diag(lat) <- 0
-    if (n > 1) 
-        lat <- apply(lat, c(1, 2), rep, n)
-    else lat <- array(lat, dim = c(1, tnv, tnv))
-    g <- lat
-    lat <- array(.C("wsrewire_R", as.double(lat), g = as.double(g), 
-        as.double(n), as.double(tnv), as.double(p), PACKAGE = "sna")$g, 
-        dim = c(n, tnv, tnv))
-    if (return.as.edgelist) 
-        as.edgelist.sna(lat)
     else {
-        if (n > 1) 
-            lat
-        else lat[1, , ]
+        mtext(yylab[1], side = 4, outer = FALSE, line = 2, col = 1, 
+            ...)
     }
-}
-
-rmperm (closure) = function (m) 
-{
-    m <- as.sociomatrix.sna(m)
-    if (is.list(m)) 
-        return(lapply(m, rmperm))
-    if (length(dim(m)) == 2) {
-        o <- sample(1:dim(m)[1])
-        p <- matrix(data = m[o, o], nrow = dim(m)[1], ncol = dim(m)[2])
+    par(new = T)
+    plot(x, yleft, axes = FALSE, ylab = "", xlab = xlab, ylim = yleftlim, 
+        xlim = xlim, bg = bg[1], pch = pch[2], type = type[2], 
+        lwd = lwd[2], col = col[2], ...)
+    box()
+    axis(2, pretty(yleftlim, length), col = 1, col.axis = 1)
+    if (is.null(yleft2) == FALSE) {
+        points(x2, yleft2, type = type[2], pch = pch[2], bg = bg[2], 
+            lwd = lwd[2], col = col2[2], ...)
+    }
+    if (smooth != 0) 
+        lines(supsmu(x, yleft, span = smooth), col = col[2], 
+            lwd = lwds, ...)
+    if (yylab[2] == "") {
+        mtext(deparse(substitute(yleft)), side = 2, outer = FALSE, 
+            line = 2, col = 1, ...)
     }
     else {
-        p <- array(dim = c(dim(m)[1], dim(m)[2], dim(m)[3]))
-        for (i in 1:dim(m)[1]) {
-            o <- sample(1:dim(m)[2])
-            p[i, , ] <- array(m[i, o, o])
-        }
+        mtext(yylab[2], side = 2, outer = FALSE, line = 2, col = 1, 
+            ...)
     }
-    p
+    axis(1, at = pretty(xlim, length))
 }
 
-rperm (closure) = function (exchange.list) 
+probdeg (closure) = function (Mg, Dg, Mn, Dn, prec = 2) 
 {
-    n <- length(exchange.list)
-    grp <- unique(exchange.list)
-    o <- 1:n
-    for (i in grp) {
-        v <- (1:n)[exchange.list == i]
-        if (length(v) > 1) 
-            o[v] <- sample(v)
-    }
-    o
+    tot <- length(Mn)
+    gens <- names(Mg)
+    Mruido <- abs(round(Mn, prec))
+    Druido <- round(Dn, prec)
+    Mgen <- abs(round(Mg, prec))
+    Dgen <- round(Dg, prec)
+    MDgen <- na.omit(cbind(Mgen, Dgen))
+    MDunic <- unique(MDgen)
+    Nres <- apply(MDunic, 1, n.menor, S1 = Mruido, S2 = Druido)
+    lugares <- apply(MDgen, 1, busca, S = MDunic)
+    Nconj <- Nres[lugares]
+    names(Nconj) <- names(lugares)
+    laprob <- Nconj/tot
+    laprob <- laprob[gens]
+    names(laprob) <- gens
+    Nconj <- Nconj[gens]
+    names(Nconj) <- gens
+    laprob <- list(prob = laprob, numDE = Nconj, numNOISE = tot)
+    laprob
+}
+
+ranking (closure) = function (results) 
+{
+    M <- results$M
+    D <- results$D
+    prob <- results$prob
+    M[is.na(M)] <- 0
+    D[is.na(D)] <- 0
+    prob[is.na(prob)] <- 0
+    ranking5 <- sqrt(M * M + D * D) * sign(M)
+    theranking <- data.frame(rownames(results), ranking5)
+    rownames(theranking) <- NULL
+    colnames(theranking) <- c("ID", "statistic")
+    theranking
+}
+
+readData (closure) = function (data = NULL, factors = NULL, length = NULL, biotype = NULL, 
+    chromosome = NULL, gc = NULL) 
+{
+    if (is.null(data)) 
+        stop("Expression information must be provided to the readData function")
+    if (is.null(factors)) 
+        stop("Condition information must be provided to the readData funcion")
+    if (is.null(length) == FALSE && is.vector(length) == FALSE && 
+        is.data.frame(length) == FALSE && is.matrix(length) == 
+        FALSE) 
+        stop("The length info should be a vector or a data.frame/matrix.")
+    if (is.null(gc) == FALSE && is.vector(gc) == FALSE && is.data.frame(gc) == 
+        FALSE && is.matrix(gc) == FALSE) 
+        stop("The GC content info should be a vector or a data.frame/matrix.")
+    if (is.null(chromosome) == FALSE && ncol(chromosome) != 3) 
+        stop("The chromosome object should be a matrix or data.frame with 3 columns: chromosome, start position and end position.")
+    if (is.null(biotype) == FALSE && is.vector(biotype) == FALSE && 
+        is.data.frame(biotype) == FALSE && is.matrix(biotype) == 
+        FALSE) 
+        stop("The biotype info should be a vector or a data.frame/matrix.")
+    countData <- as.matrix(data)
+    rowNames <- rownames(countData)
+    if (nrow(factors) == ncol(countData)) {
+        rownames(factors) <- colnames(countData)
+    }
+    else {
+        stop("Number of rows in factors must be equal to number of columns in data.\n")
+    }
+    pheno <- AnnotatedDataFrame(data = as.data.frame(factors))
+    input <- ExpressionSet(assayData = countData, phenoData = pheno)
+    if (!is.null(length)) 
+        input <- addData(data = input, length = length)
+    if (!is.null(gc)) 
+        input <- addData(data = input, gc = gc)
+    if (!is.null(biotype)) 
+        input <- addData(data = input, biotype = biotype)
+    if (!is.null(chromosome)) 
+        input <- addData(data = input, chromosome = chromosome)
+    input
+}
+
+rpkm (closure) = function (datos, long = 1000, lc = 1, k = 0) 
+{
+    if (!is.null(ncol(long))) {
+        mynames = long[, 1]
+        long = long[, 2]
+        names(long) = mynames
+    }
+    total <- colSums(as.matrix(datos))
+    datos0 <- sinceros(datos, k)
+    datos.norm <- (t(t(datos0)/total) * 10^6)/((long/1000)^lc)
+    na.omit(datos.norm)
 }
 
 safeDeparse (closure) = function (obj) 
 {
     tryCatch({
         deparse(obj)
     }, error = function(e) {
         (deparse(e))
     })
 }
 
-sdmat (closure) = function (dat, normalize = FALSE, diag = FALSE, mode = "digraph", 
-    output = "matrix", method = "mc", exchange.list = NULL, ...) 
+saturation.dat (closure) = function (input, k = 0, biotypes = NULL, ndepth = 6) 
 {
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in sdmat.")
-    if (is.null(exchange.list)) 
-        exchange.list <- rep(0, dim(dat)[2])
-    m <- dim(dat)[1]
-    sdm <- matrix(nrow = m, ncol = m)
-    for (i in 1:m) if (i < m) 
-        for (j in i:m) sdm[i, j] <- structdist(dat, g1 = i, g2 = j, 
-            normalize = normalize, diag = diag, mode = mode, 
-            method = method, exchange.list = exchange.list, ...)
-    diag(sdm) <- 0
-    for (i in 1:m) sdm[i, c(1:i)[-i]] <- sdm[c(1:i)[-i], i]
-    if (output == "dist") {
-        sdm <- as.dist(sdm)
-    }
-    sdm
-}
-
-se.lnam (closure) = function (object, ...) 
-{
-    se <- vector()
-    sen <- vector()
-    if (!is.null(object$beta.se)) {
-        se <- c(se, object$beta.se)
-        sen <- c(sen, names(object$beta.se))
-    }
-    if (!is.null(object$rho1.se)) {
-        se <- c(se, object$rho1.se)
-        sen <- c(sen, "rho1")
-    }
-    if (!is.null(object$rho2.se)) {
-        se <- c(se, object$rho2.se)
-        sen <- c(sen, "rho2")
-    }
-    names(se) <- sen
-    se
-}
-
-sedist (closure) = function (dat, g = c(1:dim(dat)[1]), method = "hamming", joint.analysis = FALSE, 
-    mode = "digraph", diag = FALSE, code.diss = FALSE) 
-{
-    dat <- as.sociomatrix.sna(dat, simplify = TRUE)
-    if (is.list(dat)) 
-        stop("sedist requires input graphs to be of identical order.")
-    if (length(dim(dat)) > 2) {
-        n <- dim(dat)[2]
-        m <- length(g)
-        d <- dat[g, , , drop = FALSE]
-    }
-    else {
-        n <- dim(dat)[2]
-        m <- 1
-        d <- array(dim = c(m, n, n))
-        d[1, , ] <- dat
-    }
-    if (!diag) 
-        d <- diag.remove(d)
-    if (joint.analysis) {
-        o <- array(dim = c(1, n, n))
-        v <- vector()
-        for (i in 1:n) v <- cbind(v, c(as.vector(d[, i, ]), as.vector(d[, 
-            , i])))
-        if (method == "correlation") {
-            o[1, , ] <- cor(v, use = "pairwise")
-            if (code.diss) 
-                o <- -o
-        }
-        else if (method == "euclidean") {
-            for (i in 1:n) for (j in 1:n) o[1, i, j] <- sqrt(sum((v[, 
-                i] - v[, j])^2, na.rm = TRUE))
-        }
-        else if (method == "hamming") {
-            for (i in 1:n) for (j in 1:n) o[1, i, j] <- sum(abs(v[, 
-                i] - v[, j]), na.rm = TRUE)
-        }
-        else if (method == "gamma") {
-            for (i in 1:n) for (j in 1:n) {
-                concord <- sum(as.numeric(v[, i] == v[, j]), 
-                  na.rm = TRUE)
-                discord <- sum(as.numeric(v[, i] != v[, j]), 
-                  na.rm = TRUE)
-                o[1, i, j] <- (concord - discord)/(concord + 
-                  discord)
-            }
-            if (code.diss) 
-                o <- -o
-        }
-        else if (method == "exact") {
-            for (i in 1:n) for (j in 1:n) o[1, i, j] <- as.numeric(any(v[!(is.na(v[, 
-                i]) | is.na(v[, j])), i] != v[!(is.na(v[, i]) | 
-                is.na(v[, j])), j]))
+    if (inherits(input, "eSet") == FALSE) 
+        stop("Error. You must give an eSet object\n")
+    if (!is.null(assayData(input)$exprs)) 
+        datos <- assayData(input)$exprs
+    else datos <- assayData(input)$counts
+    if (!is.null(featureData(input)$Biotype)) {
+        infobio <- featureData(input)$Biotype
+    }
+    else {
+        infobio = NULL
+    }
+    nsam <- NCOL(datos)
+    if (!is.null(infobio)) {
+        if (is.null(biotypes)) {
+            biotypes <- unique(infobio)
+            names(biotypes) <- biotypes
         }
     }
     else {
-        o <- array(dim = c(m, n, n))
-        for (k in 1:m) {
-            v <- vector()
-            for (i in 1:n) v <- cbind(v, c(as.vector(d[k, i, 
-                ]), as.vector(d[k, , i])))
-            if (method == "correlation") {
-                o[k, , ] <- cor(v, use = "pairwise")
-                o[k, , ][is.na(o[k, , ])] <- 0
-                if (code.diss) 
-                  o[k, , ] <- -o[k, , ]
-            }
-            else if (method == "euclidean") {
-                for (i in 1:n) for (j in 1:n) o[k, i, j] <- sqrt(sum((v[, 
-                  i] - v[, j])^2, na.rm = TRUE))
-            }
-            else if (method == "hamming") {
-                for (i in 1:n) for (j in 1:n) o[k, i, j] <- sum(abs(v[, 
-                  i] - v[, j]), na.rm = TRUE)
-            }
-            else if (method == "gamma") {
-                for (i in 1:n) for (j in 1:n) {
-                  concord <- sum(as.numeric(v[, i] == v[, j]), 
-                    na.rm = TRUE)
-                  discord <- sum(as.numeric(v[, i] != v[, j]), 
-                    na.rm = TRUE)
-                  o[k, i, j] <- (concord - discord)/(concord + 
-                    discord)
-                }
-                if (code.diss) 
-                  o[k, , ] <- -o[k, , ]
+        biotypes = NULL
+    }
+    satura <- vector("list", length = length(biotypes) + 1)
+    names(satura) <- c("global", names(biotypes))
+    ndepth1 = ceiling(ndepth/2)
+    datos = round(datos, 0)
+    datos0 = datos + 0.2
+    submuestras <- seq.depth <- vector("list", length = nsam)
+    names(submuestras) <- names(seq.depth) <- colnames(datos)
+    for (n in 1:nsam) {
+        total <- sum(datos[, n])
+        varias <- vector("list", length = ndepth + 1)
+        for (i in 1:(ndepth1)) {
+            muestra <- rmultinom(10, size = round(total/(ndepth1 + 
+                1), 0), prob = datos[, n])
+            if (i == 1) {
+                varias[[i]] <- muestra
             }
-            else if (method == "exact") {
-                for (i in 1:n) for (j in 1:n) o[k, i, j] <- as.numeric(any(v[!(is.na(v[, 
-                  i]) | is.na(v[, j])), i] != v[!(is.na(v[, i]) | 
-                  is.na(v[, j])), j]))
-            }
-        }
-    }
-    if (dim(o)[1] == 1) 
-        as.matrix(o[1, , ])
-    else o
-}
-
-simmelian (closure) = function (dat, dichotomize = TRUE, return.as.edgelist = FALSE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, simmelian, dichotomize = dichotomize))
-    g <- symmetrize(dat, rule = "strong", return.as.edgelist = TRUE)
-    ccen <- kcycle.census(g, mode = "graph", tabulate.by.vertex = FALSE, 
-        cycle.comembership = "bylength")
-    if (dichotomize) 
-        comemb <- ccen$cycle.comemb[2, , ] > 0
-    else comemb <- ccen$cycle.comemb[2, , ]
-    diag(comemb) <- 0
-    if (return.as.edgelist) 
-        as.edgelist.sna(comemb)
-    else comemb
-}
-
-sociomatrixplot (closure) = function (x, labels = NULL, drawlab = TRUE, diaglab = TRUE, drawlines = TRUE, 
-    xlab = NULL, ylab = NULL, cex.lab = 1, font.lab = 1, col.lab = 1, 
-    scale.values = TRUE, cell.col = gray, ...) 
-{
-    if ((!inherits(x, c("matrix", "array", "data.frame"))) || 
-        (length(dim(x)) > 2)) 
-        x <- as.sociomatrix.sna(x)
-    if (is.list(x)) 
-        x <- x[[1]]
-    n <- dim(x)[1]
-    o <- dim(x)[2]
-    if (is.null(labels)) 
-        labels <- list(NULL, NULL)
-    if (is.null(labels[[1]])) {
-        if (is.null(rownames(x))) 
-            labels[[1]] <- 1:dim(x)[1]
-        else labels[[1]] <- rownames(x)
-    }
-    if (is.null(labels[[2]])) {
-        if (is.null(colnames(x))) 
-            labels[[2]] <- 1:dim(x)[2]
-        else labels[[2]] <- colnames(x)
-    }
-    if (scale.values) 
-        d <- 1 - (x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - 
-            min(x, na.rm = TRUE))
-    else d <- x
-    if (is.null(xlab)) 
-        xlab <- ""
-    if (is.null(ylab)) 
-        ylab <- ""
-    plot(1, 1, xlim = c(0, o + 1), ylim = c(n + 1, 0), type = "n", 
-        axes = FALSE, xlab = xlab, ylab = ylab, ...)
-    for (i in 1:n) for (j in 1:o) rect(j - 0.5, i + 0.5, j + 
-        0.5, i - 0.5, col = cell.col(d[i, j]), xpd = TRUE, border = drawlines)
-    rect(0.5, 0.5, o + 0.5, n + 0.5, col = NA, xpd = TRUE)
-    if (drawlab) {
-        text(rep(0, n), 1:n, labels[[1]], cex = cex.lab, font = font.lab, 
-            col = col.lab)
-        text(1:o, rep(0, o), labels[[2]], cex = cex.lab, font = font.lab, 
-            col = col.lab)
-    }
-    if ((n == o) & (drawlab) & (diaglab)) 
-        if (all(labels[[1]] == labels[[2]])) 
-            text(1:o, 1:n, labels[[1]], cex = cex.lab, font = font.lab, 
-                col = col.lab)
-}
-
-sr2css (closure) = function (net) 
-{
-    dat <- as.sociomatrix.sna(net)
-    if (is.list(net)) 
-        return(lapply(net))
-    n <- dim(net)[1]
-    css <- array(dim = c(n, n, n))
-    for (i in 1:n) {
-        css[i, , ] <- NA
-        css[i, i, ] <- net[i, ]
-    }
-    css
-}
-
-stackcount (closure) = function (d) 
-{
-    d <- as.edgelist.sna(d)
-    if (is.list(d)) 
-        length(d)
-    else 1
-}
-
-stresscent (closure) = function (dat, g = 1, nodes = NULL, gmode = "digraph", diag = FALSE, 
-    tmaxdev = FALSE, cmode = "directed", geodist.precomp = NULL, 
-    rescale = FALSE, ignore.eval = TRUE) 
-{
-    dat <- as.edgelist.sna(dat)
-    if (is.list(dat)) 
-        return(sapply(dat[g], stresscent, g = 1, nodes = nodes, 
-            gmode = gmode, diag = diag, tmaxdev = tmaxdev, cmode = cmode, 
-            geodist.precomp = geodist.precomp, rescale = rescale, 
-            ignore.eval = ignore.eval))
-    n <- attr(dat, "n")
-    if (gmode == "graph") 
-        cmode <- "undirected"
-    if (tmaxdev) {
-        str <- switch(cmode, directed = (n - 1)^2 * (n - 2), 
-            undirected = (n - 1)^2 * (n - 2)/2)
-    }
-    else {
-        if (is.null(nodes)) 
-            nodes <- 1:n
-        if (cmode == "undirected") 
-            dat <- symmetrize(dat, rule = "weak", return.as.edgelist = TRUE)
-        if (!is.null(geodist.precomp)) {
-            if (is.null(geodist.precomp$gdist) || is.null(geodist.precomp$counts) || 
-                is.null(geodist.precomp$predecessors)) {
-                warning("Precomputed geodist output must include distance, count, and predecessor information (at least one of which was missing in geodist.precomp).  Re-computing on the fly.\n")
-                precomp <- FALSE
+            else {
+                varias[[i]] <- varias[[i - 1]] + muestra
             }
-            else precomp <- TRUE
-        }
-        else {
-            precomp <- FALSE
-        }
-        str <- .Call("betweenness_R", dat, n, NROW(dat), 7, precomp, 
-            ignore.eval, geodist.precomp$gdist, geodist.precomp$counts, 
-            geodist.precomp$predecessors, PACKAGE = "sna")
-        if (cmode == "undirected") 
-            str <- str/2
-        if (rescale) 
-            str <- str/sum(str)
-        str <- str[nodes]
-    }
-    str
-}
-
-structdist (closure) = function (dat, g1 = NULL, g2 = NULL, normalize = FALSE, diag = FALSE, 
-    mode = "digraph", method = "anneal", reps = 1000, prob.init = 0.9, 
-    prob.decay = 0.85, freeze.time = 25, full.neighborhood = TRUE, 
-    mut = 0.05, pop = 20, trials = 5, exchange.list = NULL) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        stop("Identical graph orders required in structdist.")
-    d <- dat
-    n <- dim(dat)[2]
-    if (is.null(g1)) 
-        g1 <- 1:dim(dat)[1]
-    if (is.null(g2)) 
-        g2 <- 1:dim(dat)[1]
-    if (is.null(exchange.list)) 
-        exchange.list <- rep(0, dim(dat)[2])
-    gn <- dim(dat)[1]
-    gn1 <- length(g1)
-    gn2 <- length(g2)
-    if (is.null(dim(exchange.list))) {
-        if (length(exchange.list) == 1) {
-            el <- matrix(rep(exchange.list, gn * n), nrow = gn, 
-                ncol = n)
         }
-        else {
-            el <- sapply(exchange.list, rep, gn)
-        }
-    }
-    else el <- exchange.list
-    hd <- matrix(nrow = gn1, ncol = gn2)
-    rownames(hd) <- g1
-    colnames(hd) <- g2
-    if (mode == "graph") {
-        if (diag) 
-            dfun <- function(m1, m2) {
-                sum(abs(m1 - m2), na.rm = TRUE)/2 + sum(abs(diag(m1) - 
-                  diag(m2)), na.rm = TRUE)/2
+        varias[[ndepth1 + 1]] <- as.matrix(datos[, n])
+        for (i in (ndepth1 + 2):(ndepth + 1)) {
+            muestra <- rmultinom(10, size = round(total/(ndepth1 + 
+                1), 0), prob = datos0[, n])
+            if (i == ndepth1 + 2) {
+                varias[[i]] <- matrix(varias[[i - 1]], ncol = 10, 
+                  nrow = nrow(varias[[i - 1]])) + muestra
             }
-        else dfun <- function(m1, m2) {
-            dm <- abs(m1 - m2)
-            sum(dm[diag(NROW(dm)) == 0], na.rm = TRUE)/2
-        }
-    }
-    else {
-        if (diag) 
-            dfun <- function(m1, m2) {
-                sum(abs(m1 - m2), na.rm = TRUE)
+            else {
+                varias[[i]] <- varias[[i - 1]] + muestra
             }
-        else dfun <- function(m1, m2) {
-            dm <- abs(m1 - m2)
-            sum(dm[diag(NROW(dm)) == 0], na.rm = TRUE)
         }
+        submuestras[[n]] <- varias
+        seq.depth[[n]] <- c(round(total/(ndepth1 + 1), 0) * (1:ndepth1), 
+            total, round(total/(ndepth1 + 1), 0) * ((ndepth1 + 
+                2):(ndepth + 1)))
+    }
+    satura[[1]] <- vector("list", length = nsam)
+    names(satura[[1]]) <- colnames(datos)
+    for (n in 1:nsam) {
+        satura[[1]][[n]] <- sapply(submuestras[[n]], function(x) {
+            mean(apply(x, 2, noceros, k = k))
+        })
     }
-    if (method == "exhaustive") {
-        for (i in 1:gn1) for (j in 1:gn2) hd[i, j] <- lab.optimize.exhaustive(d[g1[i], 
-            , ], d[g2[j], , ], dfun, exchange.list = el[c(g1[i], 
-            g2[j]), ], seek = "min")
-    }
-    else if (method == "anneal") {
-        for (i in 1:gn1) for (j in 1:gn2) {
-            hd[i, j] <- lab.optimize.anneal(d[g1[i], , ], d[g2[j], 
-                , ], dfun, exchange.list = el[c(g1[i], g2[j]), 
-                ], seek = "min", prob.init = prob.init, prob.decay = prob.decay, 
-                freeze.time = freeze.time, full.neighborhood = full.neighborhood)
+    if (!is.null(infobio)) {
+        biog <- lapply(biotypes, function(x) {
+            which(is.element(infobio, x))
+        })
+        names(biog) = names(biotypes)
+        for (j in 2:length(satura)) {
+            satura[[j]] <- vector("list", length = nsam)
+            names(satura[[j]]) <- colnames(datos)
+            for (n in 1:nsam) {
+                conbio <- lapply(submuestras[[n]], function(x) {
+                  as.matrix(x[biog[[j - 1]], ])
+                })
+                satura[[j]][[n]] <- sapply(conbio, function(x) {
+                  mean(apply(x, 2, noceros, k = k))
+                })
+            }
         }
     }
-    else if (method == "hillclimb") {
-        for (i in 1:gn1) for (j in 1:gn2) hd[i, j] <- lab.optimize.hillclimb(d[g1[i], 
-            , ], d[g2[j], , ], dfun, exchange.list = el[c(g1[i], 
-            g2[j]), ], seek = "min")
-    }
-    else if (method == "mc") {
-        for (i in 1:gn1) for (j in 1:gn2) hd[i, j] <- lab.optimize.mc(d[g1[i], 
-            , ], d[g2[j], , ], dfun, exchange.list = el[c(g1[i], 
-            g2[j]), ], seek = "min", draws = reps)
-    }
-    else if (method == "ga") {
-        stop("Sorry, GA mode is not currently supported.\n")
+    else {
+        biog <- NULL
     }
-    else if (method == "none") {
-        for (i in 1:gn1) for (j in 1:gn2) {
-            d1 <- d[g1[i], order(el[1, ]), order(el[1, ])]
-            d2 <- d[g2[j], order(el[2, ]), order(el[2, ])]
-            if (any(el[1, ] != el[2, ])) 
-                stop("Illegal exchange list; lists must be comparable!\n")
-            hd[i, j] <- dfun(d1, d2)
+    newdet <- vector("list", length = 1 + length(biotypes))
+    names(newdet) <- c("global", names(biotypes))
+    for (j in 1:length(newdet)) {
+        newdet[[j]] <- vector("list", length = nsam)
+        names(newdet[[j]]) <- colnames(datos)
+        for (n in 1:nsam) {
+            puntos <- data.frame(x = seq.depth[[n]], y = satura[[j]][[n]])
+            pendi <- NULL
+            for (i in 2:nrow(puntos)) {
+                pendi <- c(pendi, (puntos$y[i] - puntos$y[i - 
+                  1])/(puntos$x[i] - puntos$x[i - 1]))
+            }
+            newdet[[j]][[n]] <- c(NA, pendi * 1e+06)
+        }
+    }
+    bionum <- c(NROW(datos), sapply(biog, length))
+    names(bionum) <- c("global", names(biog))
+    real = vector("list", length = length(satura))
+    names(real) = names(satura)
+    realdepth = sapply(seq.depth, function(x) x[ndepth1 + 1])/10^6
+    for (i in 1:length(real)) {
+        real[[i]] = data.frame(depth = realdepth, detec = sapply(satura[[i]], 
+            function(x) x[ndepth1 + 1]))
+        rownames(real[[i]]) = colnames(datos)
+    }
+    satura <- list(saturation = satura, bionum = bionum, depth = seq.depth, 
+        newdet = newdet, real = real)
+    satura
+}
+
+saturation.plot (closure) = function (satdat, samples = NULL, toplot = 1, yrightlim = NULL, 
+    toreport = FALSE, yleftlim = NULL, ...) 
+{
+    mypar = par(no.readonly = TRUE)
+    lwdL = 2
+    lwdR = 10
+    xlab = "Sequencing depth (million reads)"
+    ylabL = "Number of detected features"
+    ylabR = "New detections per million reads"
+    cex.main = cex.lab = cex.axis = 1
+    cex = 0.8
+    if (is.null(samples)) {
+        samples <- 1:length(sat)
+    }
+    sat <- satdat$saturation[[toplot]]
+    depth <- satdat$depth
+    num <- satdat$bionum[[toplot]]
+    nuevo <- satdat$newdet[[toplot]]
+    real = satdat$real[[toplot]][samples, ]
+    if (is.numeric(toplot)) {
+        main <- paste(toupper(names(satdat[[1]])[toplot]), " (", 
+            num, ")", sep = "")
+    }
+    else {
+        main <- paste(toupper(toplot), " (", num, ")", sep = "")
+    }
+    legend = names(satdat$saturation[[1]])[samples]
+    if (toreport) 
+        legend = samples
+    miscolores <- colors()[c(554, 89, 111, 512, 17, 586, 132, 
+        428, 601, 568, 86, 390)]
+    if (length(samples) > 2) {
+        colL <- miscolores
+    }
+    else {
+        colL <- miscolores[c(4, 2)]
+    }
+    colR <- miscolores[c(12, 11)]
+    mybg <- colL
+    xlim <- range(unlist(depth[samples])/10^6)
+    if (is.null(yleftlim)) {
+        yleftlim <- range(unlist(sat[samples]))
+    }
+    else {
+        yleftlim = yleftlim
+    }
+    percen <- round(100 * real[, "detec"]/num, 1)
+    if (length(samples) <= 2) {
+        bars <- TRUE
+    }
+    else {
+        bars <- FALSE
+    }
+    if (!bars) {
+        plot(depth[[samples[1]]]/10^6, sat[[samples[1]]], pch = 21, 
+            col = colL[1], lwd = lwdL, ylim = yleftlim, xlim = xlim, 
+            main = main, type = "b", xlab = xlab, ylab = ylabL, 
+            cex.main = cex.main, cex.lab = cex.lab, cex.axis = cex.axis, 
+            ...)
+        if (length(samples) > 1) {
+            j <- 2
+            for (i in samples[-1]) {
+                lines(depth[[i]]/10^6, sat[[i]], pch = 21, col = colL[j], 
+                  lwd = lwdL, type = "b")
+                j <- j + 1
+            }
+        }
+        points(real, pch = 21, col = colL[1:length(samples)], 
+            bg = mybg[1:length(samples)])
+        legend("bottom", legend = paste(legend, ": ", percen, 
+            "% detected", sep = ""), pch = 21, pt.bg = mybg, 
+            text.col = colL, bty = "n", ncol = 2, lwd = lwdL, 
+            col = colL, cex = cex)
+    }
+    else {
+        if (is.null(yrightlim)) {
+            yrightlim <- c(0, max(10, max(na.omit(unlist(nuevo[samples])))))
+        }
+        if (!toreport) 
+            nf <- layout(matrix(c(1, 2), 2, 1, byrow = TRUE), 
+                heights = c(0.8, 0.2))
+        par(mar = c(5, 4, 4, 4) + 0.1)
+        plot.y2(x = depth[[samples[1]]]/10^6, yright = nuevo[[samples[1]]], 
+            yleft = sat[[samples[1]]], type = c("h", "o"), lwd = c(lwdR, 
+                lwdL), xlab = xlab, xlim = xlim, yrightlim = yrightlim, 
+            yleftlim = yleftlim, yylab = c(ylabR, ylabL), pch = c(1, 
+                21), col = c(colR[1], colL[1]), main = main, 
+            x2 = depth[[samples[2]]]/10^6, yright2 = nuevo[[samples[2]]], 
+            yleft2 = sat[[samples[2]]], col2 = c(colR[2], colL[2]), 
+            cex.main = cex.main, cex.lab = cex.lab, cex.axis = cex.axis, 
+            cex = cex, ...)
+        points(real, pch = 21, col = colL, bg = mybg)
+        par(mar = c(0, 0, 0, 0))
+        plot(0, axes = FALSE, type = "n")
+        rect(0.7, -0.7, 1.3, 1, col = "grey90", border = "grey90")
+        text(0.93, 0.7, "Left axis", font = 3, cex = 1.2)
+        text(1.07, 0.68, "Right axis", font = 3, cex = 1.2)
+        text(1.22, 0.7, "%detected", font = 3, cex = 1.2)
+        text(0.72, 0.15, legend[1], font = 2, adj = 0)
+        points(0.93, 0.15, lty = 1, pch = 21, col = colL[1], 
+            bg = mybg[1])
+        points(1.07, 0.15, pch = "-", col = colR[1], cex = lwdR)
+        text(1.24, 0.15, percen[1], adj = 1)
+        if (length(samples) == 2) {
+            text(x = 0.72, -0.25, legend[2], font = 2, adj = 0)
+            points(0.93, -0.25, lty = 1, pch = 21, col = colL[2], 
+                bg = mybg[2])
+            points(1.07, -0.25, pch = "-", col = colR[2], cex = lwdR)
+            text(1.24, -0.25, percen[2], adj = 1)
+        }
+        if (!toreport) 
+            par(mypar)
+        layout(1)
+    }
+}
+
+share.info (closure) = function (mydata, n1, n2, r, nclust) 
+{
+    gc()
+    cl = suppressWarnings(kmeans(mydata, nclust, nstart = 25, 
+        iter.max = nclust + 30))
+    cat("...k-means clustering done\n")
+    cat(paste("Size of", nclust, "clusters:\n"))
+    print(cl$size)
+    cluster.data = lapply(1:nclust, function(k) {
+        mydata[cl$cluster == k, ]
+    })
+    npermu = cl$size * r
+    npermu = sapply(npermu, function(x) min(x, 1000))
+    cat("Resampling cluster...")
+    myres = vector("list", length = nclust)
+    for (i in 1:nclust) {
+        print(i)
+        if (cl$size[i] > 1 && cl$size[i] < 1000) {
+            myres[[i]] = t(sapply(1:npermu[i], function(j) {
+                permu = sample(cluster.data[[i]])
+                nn1 = n1 * cl$size[i]
+                nn2 = n2 * cl$size[i]
+                mean1 = mean(permu[1:nn1])
+                mean2 = mean(permu[(nn1 + 1):(nn1 + nn2)])
+                sd1 = sd(as.numeric(permu[1:nn1]))
+                sd2 = sd(as.numeric(permu[(nn1 + 1):(nn1 + nn2)]))
+                data.frame(M = log2(mean1/mean2), D = mean1 - 
+                  mean2, M.sd = sqrt(sd1^2/(mean1^2 * log(2)^2 * 
+                  nn1) + sd2^2/(mean2^2 * log(2)^2 * nn2)), D.sd = sqrt(sd1^2/sqrt(nn1) + 
+                  sd2^2/sqrt(nn2)))
+            }))
+        }
+        if (cl$size[i] >= 1000) {
+            cl2 = kmeans(cluster.data[[i]], nclust, nstart = 25, 
+                iter.max = nclust + 20)
+            cat(paste("Size of", nclust, "subclusters of cluster:", 
+                i))
+            cat("\n")
+            print(cl2$size)
+            subcluster.data = lapply(1:nclust, function(k) {
+                cluster.data[[i]][cl2$cluster == k, ]
+            })
+            npermu2 = cl2$size * r
+            npermu2 = sapply(npermu2, function(x) min(x, 1000))
+            myres2 = vector("list", length = nclust)
+            for (h in 1:nclust) {
+                if (cl2$size[h] > 1) {
+                  myres2[[h]] = t(sapply(1:npermu2[h], function(j) {
+                    permu = sample(subcluster.data[[h]])
+                    nn1 = n1 * cl2$size[h]
+                    nn2 = n2 * cl2$size[h]
+                    mean1 = mean(permu[1:nn1])
+                    mean2 = mean(permu[(nn1 + 1):(nn1 + nn2)])
+                    sd1 = sd(as.numeric(permu[1:nn1]))
+                    sd2 = sd(as.numeric(permu[(nn1 + 1):(nn1 + 
+                      nn2)]))
+                    data.frame(M = log2(mean1/mean2), D = mean1 - 
+                      mean2, M.sd = sqrt(sd1^2/(mean1^2 * log(2)^2 * 
+                      nn1) + sd2^2/(mean2^2 * log(2)^2 * nn2)), 
+                      D.sd = sqrt(sd1^2/sqrt(nn1) + sd2^2/sqrt(nn2)))
+                  }))
+                }
+            }
+            myres[[i]] = do.call("rbind", myres2)
         }
     }
-    else {
-        cat("Method", method, "not implemented yet.\n")
-    }
-    if (normalize) 
-        hd <- hd/nties(dat[1, , ], mode = mode, diag = diag)
-    if ((gn1 == 1) & (gn2 == 1)) 
-        hd[1, 1]
-    else hd
-}
-
-structure.statistics (closure) = function (dat, geodist.precomp = NULL) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, structure.statistics, geodist.precomp = geodist.precomp))
-    else if (length(dim(dat)) > 2) 
-        return(apply(dat, 1, structure.statistics, geodist.precomp = geodist.precomp))
-    if (is.null(geodist.precomp)) 
-        gd <- geodist(dat)$gdist
-    else gd <- geodist.precomp$gdist
-    ss <- vector()
-    for (i in 1:NROW(dat)) ss[i] <- mean(apply(gd <= i - 1, 1, 
-        mean))
-    names(ss) <- 0:(NROW(dat) - 1)
-    ss
-}
-
-summary.bayes.factor (closure) = function (object, ...) 
-{
-    o <- object
-    rownames(o$int.lik) <- o$model.names
-    colnames(o$int.lik) <- o$model.names
-    o$inv.bf <- -o$int.lik
-    for (i in 1:dim(o$int.lik)[1]) o$inv.bf[i, i] <- o$int.lik[i, 
-        i] - logSum(diag(o$int.lik))
-    class(o) <- c("summary.bayes.factor", "bayes.factor")
-    o
-}
-
-summary.bbnam (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.bbnam", class(out))
-    out
-}
-
-summary.bbnam.actor (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.bbnam.actor", class(out))
-    out
-}
-
-summary.bbnam.fixed (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.bbnam.fixed", class(out))
-    out
-}
-
-summary.bbnam.pooled (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.bbnam.pooled", class(out))
-    out
-}
-
-summary.blockmodel (closure) = function (object, ...) 
-{
-    o <- object
-    class(o) <- "summary.blockmodel"
-    o
-}
-
-summary.bn (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.bn", class(out))
-    out
-}
-
-summary.brokerage (closure) = function (object, ...) 
-{
-    class(object) <- "summary.brokerage"
-    object
-}
-
-summary.cugtest (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.cugtest", class(out))
-    out
-}
-
-summary.lnam (closure) = function (object, ...) 
-{
-    ans <- object
-    class(ans) <- c("summary.lnam", "lnam")
-    ans
-}
-
-summary.netcancor (closure) = function (object, ...) 
-{
-    out <- object
-    class(out) <- c("summary.netcancor", class(out))
-    out
+    cat("Computing Z for noise...\n")
+    myres = do.call("rbind", myres)
+    a0.M <- quantile(as.numeric(myres[, "M.sd"]), probs = 0.9, 
+        na.rm = TRUE)
+    a0.D <- quantile(as.numeric(myres[, "D.sd"]), probs = 0.9, 
+        na.rm = TRUE)
+    M <- as.numeric(myres[, "M"])/(a0.M + as.numeric(myres[, 
+        "M.sd"]))
+    D <- as.numeric(myres[, "D"])/(a0.D + as.numeric(myres[, 
+        "D.sd"]))
+    (M + D)/2
 }
 
-summary.netlm (closure) = function (object, ...) 
+sim.samples (closure) = function (counts1, counts2 = NULL, pnr = 1, nss = 5, v = 0.02) 
 {
-    out <- object
-    class(out) <- c("summary.netlm", class(out))
-    out
+    seqdep <- c(sum(counts1), sum(counts2))
+    num.reads1 <- (pnr + c(-v, v)) * seqdep[1]
+    muestras <- vector("list")
+    muestras$c1 <- NULL
+    for (s in 1:nss) {
+        tama <- round(runif(1, num.reads1[1], num.reads1[2]), 
+            0)
+        muestras$c1 <- cbind(muestras$c1, rmultinom(1, size = tama, 
+            prob = counts1))
+    }
+    if (!is.null(counts2)) {
+        num.reads2 <- (pnr + c(-v, v)) * seqdep[2]
+        muestras$c2 <- NULL
+        for (s in 1:nss) {
+            tama <- round(runif(1, num.reads2[1], num.reads2[2]), 
+                0)
+            muestras$c2 <- cbind(muestras$c2, rmultinom(1, size = tama, 
+                prob = counts2))
+        }
+    }
+    muestras
 }
 
-summary.netlogit (closure) = function (object, ...) 
+sinceros (closure) = function (datos, k) 
 {
-    out <- object
-    class(out) <- c("summary.netlogit", class(out))
-    out
+    datos = as.matrix(datos)
+    datos0 <- as.matrix(datos)
+    if (is.null(k)) {
+        mini0 <- min(datos[noceros(datos, num = FALSE, k = 0)])
+        kc <- mini0/2
+        datos0[datos0 == 0] <- kc
+    }
+    else {
+        datos0[datos0 == 0] <- k
+    }
+    datos0
 }
 
-summary.qaptest (closure) = function (object, ...) 
+tmm (closure) = function (datos, long = 1000, lc = 0, k = 0, refColumn = 1, logratioTrim = 0.3, 
+    sumTrim = 0.05, doWeighting = TRUE, Acutoff = -1e+10) 
 {
-    out <- object
-    class(out) <- c("summary.qaptest", class(out))
-    out
+    if (!is.null(ncol(long))) {
+        mynames = long[, 1]
+        long = long[, 2]
+        names(long) = mynames
+    }
+    L <- (long/1000)^lc
+    datos = datos/L
+    total <- colSums(as.matrix(datos))
+    datos0 <- sinceros(datos, k)
+    if (ncol(as.matrix(datos)) > 1) {
+        fk <- .calcNormFactors(as.matrix(datos), refColumn = refColumn, 
+            method = "TMM", logratioTrim = logratioTrim, sumTrim = sumTrim, 
+            doWeighting = doWeighting, Acutoff = Acutoff)
+        fk = fk * (total/mean(total))
+        datos.norm <- t(t(datos0)/fk)
+    }
+    else {
+        datos.norm <- datos0/L
+    }
+    na.omit(datos.norm)
 }
 
-symmetrize (closure) = function (mats, rule = "weak", return.as.edgelist = FALSE) 
+uqua (closure) = function (datos, long = 1000, lc = 0, k = 0) 
 {
-    if (!return.as.edgelist) {
-        mats <- as.sociomatrix.sna(mats)
-        if (is.list(mats)) 
-            return(lapply(mats, symmetrize, rule = rule, return.as.edgelist = return.as.edgelist))
-        if (length(dim(mats)) > 2) {
-            m <- dim(mats)[1]
-            n <- dim(mats)[2]
-            o <- dim(mats)[3]
-            d <- mats
+    if (!is.null(ncol(long))) {
+        mynames = long[, 1]
+        long = long[, 2]
+        names(long) = mynames
+    }
+    L <- (long/1000)^lc
+    datos = datos/L
+    datos0 <- sinceros(datos, k)
+    if (ncol(as.matrix(datos)) > 1) {
+        sumatot <- rowSums(datos)
+        supertot <- sum(sumatot)
+        counts0 <- which(sumatot == 0)
+        if (length(counts0) > 0) {
+            datitos <- datos[-counts0, ]
         }
         else {
-            m <- 1
-            n <- dim(mats)[1]
-            o <- dim(mats)[2]
-            d <- array(dim = c(1, n, o))
-            d[1, , ] <- mats
-        }
-        for (i in 1:m) {
-            if (rule == "upper") {
-                d[i, , ][lower.tri(d[i, , ])] <- t(d[i, , ])[lower.tri(d[i, 
-                  , ])]
-            }
-            else if (rule == "lower") {
-                d[i, , ][upper.tri(d[i, , ])] <- t(d[i, , ])[upper.tri(d[i, 
-                  , ])]
-            }
-            else if (rule == "weak") {
-                d[i, , ] <- matrix(as.numeric(d[i, , ] | t(d[i, 
-                  , ])), nrow = n, ncol = o)
-            }
-            else if (rule == "strong") {
-                d[i, , ] <- matrix(as.numeric(d[i, , ] & t(d[i, 
-                  , ])), nrow = n, ncol = o)
-            }
-        }
-        if (m == 1) 
-            out <- d[1, , ]
-        else out <- d
-        out
-    }
-    else {
-        mats <- as.edgelist.sna(mats)
-        if (is.list(mats)) 
-            return(lapply(mats, symmetrize, rule = rule, return.as.edgelist = return.as.edgelist))
-        n <- attr(mats, "n")
-        vn <- attr(mats, "vnames")
-        bip <- attr(mats, "bipartite")
-        if (!is.null(bip)) 
-            return(mats)
-        if (rule == "upper") {
-            loops <- mats[mats[, 1] == mats[, 2], , drop = FALSE]
-            upedge <- mats[mats[, 1] < mats[, 2], , drop = FALSE]
-            mats <- rbind(upedge, upedge[, c(2, 1, 3)], loops)
-        }
-        else if (rule == "lower") {
-            loops <- mats[mats[, 1] == mats[, 2], , drop = FALSE]
-            loedge <- mats[mats[, 1] > mats[, 2], , drop = FALSE]
-            mats <- rbind(loedge, loedge[, c(2, 1, 3)], loops)
-        }
-        else if (rule == "weak") {
-            isloop <- mats[, 1] == mats[, 2]
-            loops <- mats[isloop, , drop = FALSE]
-            mats <- mats[!isloop, , drop = FALSE]
-            dc <- .C("dyadcode_R", as.double(mats), as.integer(n), 
-                as.integer(NROW(mats)), dc = as.double(rep(0, 
-                  NROW(mats))), PACKAGE = "sna", NAOK = TRUE)$dc
-            isdup <- duplicated(dc)
-            mats <- mats[!isdup, , drop = FALSE]
-            mats <- rbind(mats, mats[, c(2, 1, 3)], loops)
-        }
-        else if (rule == "strong") {
-            isloop <- mats[, 1] == mats[, 2]
-            loops <- mats[isloop, , drop = FALSE]
-            mats <- mats[!isloop, , drop = FALSE]
-            dc <- .C("dyadcode_R", as.double(mats), as.integer(n), 
-                as.integer(NROW(mats)), dc = as.double(rep(0, 
-                  NROW(mats))), PACKAGE = "sna", NAOK = TRUE)$dc
-            isdup <- duplicated(dc)
-            mats <- mats[isdup, , drop = FALSE]
-            mats <- rbind(mats, mats[, c(2, 1, 3)], loops)
-        }
-        attr(mats, "n") <- n
-        attr(mats, "vnames") <- vn
-        mats
-    }
-}
-
-triad.census (closure) = function (dat, g = NULL, mode = c("digraph", "graph")) 
-{
-    dat <- as.edgelist.sna(dat)
-    tc <- switch(match.arg(mode), graph = 0:3, digraph = c("003", 
-        "012", "102", "021D", "021U", "021C", "111D", "111U", 
-        "030T", "030C", "201", "120D", "120U", "120C", "210", 
-        "300"))
-    if (!is.list(dat)) 
-        dat <- list(dat)
-    rnam <- names(dat)
-    gm <- as.integer(switch(match.arg(mode), graph = 0, digraph = 1))
-    tcm <- matrix(nrow = length(dat), ncol = length(tc))
-    for (i in 1:length(dat)) {
-        n <- as.integer(attr(dat[[i]], "n"))
-        m <- as.integer(NROW(dat[[i]]))
-        tcv <- as.double(rep(0, length(tc)))
-        if (n > 2) 
-            tcm[i, ] <- .C("triad_census_R", as.double(dat[[i]]), 
-                n, m, tcv = tcv, gm, as.integer(1), PACKAGE = "sna", 
-                NAOK = TRUE)$tcv
-    }
-    colnames(tcm) <- tc
-    rownames(tcm) <- rnam
-    tcm
-}
-
-triad.classify (closure) = function (dat, g = 1, tri = c(1, 2, 3), mode = c("digraph", "graph")) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        d <- dat[[g]][tri, tri]
-    else if (length(dim(dat)) == 2) 
-        d <- dat[tri, tri]
-    else d <- dat[g, tri, tri]
-    if (any(is.na(d[upper.tri(d) | lower.tri(d)]))) 
-        return(NA)
-    tc <- switch(match.arg(mode), graph = 0:3, digraph = c("003", 
-        "012", "102", "021D", "021U", "021C", "111D", "111U", 
-        "030T", "030C", "201", "120D", "120U", "120C", "210", 
-        "300"))
-    tt <- as.integer(0)
-    gm <- as.integer(switch(match.arg(mode), graph = 0, digraph = 1))
-    tt <- .C("triad_classify_R", as.integer(d), tt = tt, gm, 
-        PACKAGE = "sna")$tt
-    tc[tt + 1]
-}
-
-upper.tri.remove (closure) = function (dat, remove.val = NA) 
-{
-    dat <- as.sociomatrix.sna(dat)
-    if (is.list(dat)) 
-        return(lapply(dat, upper.tri.remove, remove.val = remove.val))
-    if (length(dim(dat)) > 2) {
-        d <- dat
-        for (i in 1:dim(dat)[1]) {
-            temp <- d[i, , ]
-            temp[upper.tri(temp, diag = FALSE)] <- remove.val
-            d[i, , ] <- temp
-        }
-    }
-    else {
-        d <- dat
-        d[upper.tri(d, diag = FALSE)] <- remove.val
-    }
-    d
-}
-
-write.dl (closure) = function (x, file, vertex.lab = NULL, matrix.lab = NULL) 
-{
-    x <- as.sociomatrix.sna(x)
-    if (is.list(x)) 
-        stop("DL format requires all graphs to be of identical order.")
-    if (is.matrix(x)) 
-        x <- array(x, dim = c(1, NROW(x), NCOL(x)))
-    m <- dim(x)[1]
-    n <- dim(x)[2]
-    cat("DL n = ", n, ", nm = ", m, ", format = edgelist1\n", 
-        sep = "", file = file)
-    if (is.null(vertex.lab)) 
-        vertex.lab <- dimnames(x)[[2]]
-    if (is.null(vertex.lab)) 
-        vertex.lab <- 1:n
-    if (is.character(vertex.lab)) 
-        vertex.lab <- paste("\"", vertex.lab, "\"", sep = "")
-    cat("labels:\n", file = file, append = TRUE)
-    cat(paste(vertex.lab, collapse = ","), "\n", sep = "", file = file, 
-        append = TRUE)
-    if (is.null(matrix.lab)) 
-        matrix.lab <- dimnames(x)[[1]]
-    if (is.null(matrix.lab)) 
-        matrix.lab <- 1:m
-    if (is.character(matrix.lab)) 
-        matrix.lab <- paste("\"", matrix.lab, "\"", sep = "")
-    cat("matrix labels:\n", file = file, append = TRUE)
-    cat(paste(matrix.lab, sep = "", collapse = ","), "\n", sep = "", 
-        file = file, append = TRUE)
-    cat("data:\n", file = file, append = TRUE)
-    for (i in 1:m) {
-        edges <- x[i, , ]
-        edges[is.na(edges)] <- 0
-        edges <- edges != 0
-        rn <- row(x[i, , ])[edges]
-        cn <- col(x[i, , ])[edges]
-        val <- x[i, , ][edges]
-        if (sum(edges > 0)) {
-            for (j in 1:length(rn)) cat(rn[j], cn[j], val[j], 
-                "\n", file = file, append = TRUE)
-        }
-        if (i < m) 
-            cat("!\n", file = file, append = TRUE)
-    }
-}
-
-write.nos (closure) = function (x, file, row.col = NULL, col.col = NULL) 
-{
-    if (is.list(x) || inherits(x, "network")) 
-        x <- as.sociomatrix.sna(x)
-    if (is.list(x)) 
-        stop("NOS format requires all graphs to be of identical order.")
-    if (is.matrix(x)) 
-        x <- array(x, dim = c(1, NROW(x), NCOL(x)))
-    m <- dim(x)[1]
-    n <- dim(x)[2]
-    o <- dim(x)[3]
-    cat(m, "\n", n, " ", o, "\n", sep = "", file = file)
-    if (is.null(row.col)) 
-        row.col <- rep(0, n)
-    if (is.character(row.col)) 
-        row.col <- paste("\"", row.col, "\"", sep = "")
-    if (is.null(col.col)) 
-        col.col <- rep(0, o)
-    if (is.character(col.col)) 
-        col.col <- paste("\"", col.col, "\"", sep = "")
-    cat(paste(c(row.col, col.col), collapse = " "), "\n", sep = "", 
-        file = file, append = TRUE)
-    for (i in 1:m) {
-        for (j in 1:n) cat(paste(x[i, j, ], collapse = " "), 
-            "\n", sep = "", file = file, append = TRUE)
+            datitos <- datos
+        }
+        q3 <- apply(datitos, 2, quantile, probs = 0.75)
+        d <- q3 * supertot/sum(q3)
+        datos.norm <- t(t(datos0)/d) * 10^6
+    }
+    else {
+        datos.norm <- datos0/L
     }
+    na.omit(datos.norm)
 }
 
